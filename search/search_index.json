{"config":{"lang":["en"],"separator":"[\\s\\u200b\\u3000\\-\u3001\u3002\uff0c\uff0e\uff1f\uff01\uff1b]+","pipeline":["stemmer"]},"docs":[{"location":"","title":"Home","text":"QQMusic-API-CXX"},{"location":"#_1","title":"\u7b80\u4ecb","text":"<p>\u672c\u9879\u76ee\u4f7f\u7528C++\u501f\u52a9Boost Beast\u5e93\u5c01\u88c5QQ\u97f3\u4e50\u7684API.</p>"},{"location":"#_2","title":"\u4f7f\u7528\u7684\u7b2c\u4e09\u65b9\u5e93","text":"<ul> <li> <p>Boost Asio</p> </li> <li> <p>Boost Beast</p> </li> <li> <p>Boost Uuid</p> </li> <li> <p>Boost Url</p> </li> <li> <p>Nlohmann Json</p> </li> <li> <p>zlib</p> </li> <li> <p>Botan</p> </li> <li> <p>OpenSSL</p> </li> </ul>"},{"location":"#-","title":"\u4f7f\u7528\u65b9\u6cd5--\u5982\u4f55\u5728\u9879\u76ee\u4e2d\u4f7f\u7528","text":"<p>\u8bbe\u7f6e\u6784\u5efa\u7c7b\u578b</p> <pre><code>set(QQMUSIC_API_BUILD_TYPE SharedLib)\n</code></pre> <p>\u4f5c\u4e3a\u5b50\u9879\u76ee\u5f15\u5165</p> <pre><code>add_subdirectory(path/to/qqmusic-api)\n\ntarget_include_library(\n    demo PRIVATE\n    path/to/qqmusic-api/include\n)\n\ntarget_link_library(\n    demo PRIVATE\n    qmapi\n)\n</code></pre>"},{"location":"#_3","title":"\u9879\u76ee\u67b6\u6784","text":"<p>\u53ef\u7528\u5934\u6587\u4ef6\u76ee\u5f55:</p> <pre><code>./include\n\u2514\u2500\u2500 qqmusic\n    \u251c\u2500\u2500 crypto\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 cipher.h\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 cipher_map.h\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 cipher_rc4.h\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 cipher_tea.h\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 key_derive.h\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 qmc.h\n    \u251c\u2500\u2500 details\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 api.h\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 context.h\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 result.h\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 tripledes.h\n    \u251c\u2500\u2500 utils\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 async-executor.h\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 buffer.h\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 common.h\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 cookie.h\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 credential.h\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 device.h\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 exception.h\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 paths.h\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 qimei.h\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 session.h\n    \u251c\u2500\u2500 album.h\n    \u251c\u2500\u2500 login.h\n    \u251c\u2500\u2500 lyric.h\n    \u251c\u2500\u2500 mv.h\n    \u251c\u2500\u2500 result.h\n    \u251c\u2500\u2500 search.h\n    \u251c\u2500\u2500 singer.h\n    \u251c\u2500\u2500 song.h\n    \u251c\u2500\u2500 songlist.h\n    \u251c\u2500\u2500 toplist.h\n    \u2514\u2500\u2500 user.h\n</code></pre>"},{"location":"#_4","title":"\u53c2\u8003\u9879\u76ee","text":"<p>luren-dc QQMusicApi</p> <p>Unlock Music</p>"},{"location":"#_5","title":"\u9879\u76ee\u7ef4\u62a4\u8005","text":""},{"location":"Contributing/Contributing/","title":"\u8d21\u732e\u6307\u5357","text":"<p>\u611f\u8c22\u60a8\u5bf9\u672c\u9879\u76ee\u611f\u5174\u8da3, \u8bf7\u9075\u5faa\u4ee5\u4e0b\u89c4\u8303\u63d0\u4ea4\u8d21\u732e</p>"},{"location":"Contributing/Contributing/#_1","title":"\u9884\u5148\u914d\u7f6e","text":"<ul> <li> <p>\u7f16\u8bd1\u5668: gcc &gt;= 13, clang &gt;= 19, Visual Studio 2022</p> </li> <li> <p>vcpkg \u548c CMake &gt;= 3.20, \u6216 xmake</p> </li> </ul> <p>About Xmake</p> <p>Xmake \u76ee\u524d\u53ea\u80fd\u5728Linux\u5e73\u53f0\u6210\u529f\u7f16\u8bd1\u51fa\u53ef\u6267\u884c\u6587\u4ef6, Windows\u548cMacOS\u5c1a\u672a\u901a\u8fc7\u6d4b\u8bd5</p> <ul> <li> <p>pre-commit</p> </li> <li> <p>mkdocs</p> </li> </ul>"},{"location":"Contributing/Contributing/#_2","title":"\u914d\u7f6e\u73af\u5883","text":"<ul> <li> <p>Step1: \u5728github\u4e0afork\u4e00\u4efd\u4ee3\u7801</p> </li> <li> <p>Step2: \u4e0b\u8f7d\u5e76\u5b89\u88c5pre-commit\u94a9\u5b50</p> </li> </ul> <pre><code># download your forked repo from github\ngit clone --recursive git@github.com:&lt;your username&gt;/qqmusic-api-cxx.git\ncd qqmusic-api-cxx\n\n# install pre-commit hooks\npre-commit install --all\n</code></pre> <ul> <li>Step3: \u7f16\u8bd1\u914d\u7f6e</li> </ul> <pre><code>#                If you want to add a demo program,     You will need this if you\n#                    please set this to `Demo`                use clangd\n#                                       \\                     /\ncmake -B build -DQQMUSIC_API_BUILD_TYPE=Test -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DCMAKE_BUILD_TYPE=Debug\n</code></pre> <p>\u51fa\u73b0\u7c7b\u4f3c\u8fd9\u6837\u7684\u56fe\u5f62\u5373\u914d\u7f6e\u6210\u529f:</p> <pre><code>+---------------QQMUSIC API CXX---------------+\n|                                             |\n|              QQMUSIC BUILD TYPE             |\n|                                             |\n|    DEMO                           OFF       |\n|                                             |\n|    SHARED LIBRARY                 OFF       |\n|                                             |\n|    TEST                           ON        |\n|                                             |\n+---------------------------------------------+\n</code></pre> <p>\u7f16\u8bd1</p> <pre><code>cmake --build build --parallel 8\n</code></pre> <p>About xmake</p> <p>\u63a8\u8350\u4f7f\u7528CMake, \u4f46\u662f\u76ee\u524d\u7f3a\u5c11\u4eba\u624b\u505axmake\u65b9\u9762\u7684\u9002\u914dqwq</p> <pre><code>$ xmake config -m [debug|release] -y &amp;&amp; xmake build [test|demo|qmapi]\n</code></pre>"},{"location":"Contributing/Contributing/#pr","title":"\u5173\u4e8e\u63d0\u4ea4\u548cPR","text":"<p>\u63d0\u4ea4\u89c4\u8303\u8bf7\u9075\u5faaConventional Commits\u89c4\u8303</p> <p>Note</p> <p>\u8bf7\u5411dev\u5206\u652f\u63d0\u4ea4PR, \u6240\u6709\u5411main\u5206\u652f\u63d0\u4ea4\u7684PR\u5c06\u88ab\u5ffd\u7565</p>"},{"location":"Contributing/Contributing/#_3","title":"\u6587\u6863","text":"<p>\u4f9d\u8d56Mkdocs Material</p>"},{"location":"Contributing/_Architecture/","title":"\u9879\u76ee\u67b6\u6784","text":"<p>\u6211\u4eec\u901a\u8fc7\u4e00\u4e2aApi\u51fd\u6570\u4ecb\u7ecd\u9879\u76ee\u7684\u6574\u4f53\u67b6\u6784</p> <pre><code>// \u4f7f\u7528\u901a\u7528\u5f02\u6b65\u4efb\u52a1`qqmusic::Task&lt;T&gt;`\u8fd4\u56de\u534f\u7a0btask\n// \u4f7f\u7528\u901a\u7528\u8fd4\u56de\u7ed3\u679c`qqmusic::Result&lt;T&gt;`\u5305\u88c5nlohmann_json\u63d0\u4f9b\u7684json\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_album_detail(std::string_view album_mid) {\n\n    // \u901a\u8fc7SessionManager\u5355\u4f8b\u83b7\u53d6session\u5b9e\u4f8b\n    auto session = utils::SessionManager::get_instance().get_session();\n\n    // \u901a\u8fc7session\u5b9e\u4f8b\u5316Api\u7c7b, \u540c\u65f6\u4f20\u5165\u5fc5\u8981\u7684\u4fe1\u606f\n    auto api = details::Api(session, \"music.musichallAlbum.AlbumInfoServer\", \"GetAlbumDetail\");\n\n    // \u6784\u9020json\u683c\u5f0f\u7684\u8bf7\u6c42\u6570\u636e\u8868\u5355\n    nlohmann::json params = {{\"albumMId\", album_mid}};\n\n    // \u6784\u9020\u8bf7\u6c42\n    auto req_param_res = co_await api.prepare_request(params);\n    if (req_param_res.isErr()) {\n        // \u8fd9\u91cc\u8fd4\u56de\u7684\u662fResult&lt;&gt;, \u9700\u8981\u68c0\u67e5request\u662f\u5426\u6784\u9020\u6210\u529f\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_album_detail] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n    // *\u8fd9\u91cc\u6784\u9020\u7684\u8bf7\u6c42\u4e0d\u5305\u542bcookie\u4fe1\u606f, \u5982\u679c\u8981\u5305\u542bcookie, \u8bf7\u67e5\u9605qqmusic::utils::CookieJar\u7684\u6587\u6863\n    // \u5e76\u624b\u52a8\u6dfb\u52a0cookie\n    // `req.set(boost::beast::http::field::cookie, \"cookie string\");`\n\n\n    // \u53d1\u9001\u8bf7\u6c42, \u83b7\u53d6\u7ed3\u679c\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_album_detail] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    // \u5982\u679c\u7ed3\u679c\u65e0\u8bef, \u5c31\u8fdb\u884c\u89e3\u6790. \n    // \u8fd4\u56de\u7684\u7ed3\u679c\u662f\u539f\u59cb\u7684boost::beast::http::response&lt;boost::beast::http::dynamic_body&gt;\n    // \u5982\u679c\u662f\u4e8c\u8fdb\u5236\u7684\u5a92\u4f53\u6570\u636e, \u53ef\u4ee5\u901a\u8fc7utils::to_buffer\u51fd\u6570\u8f6c\u6362\u6210\u901a\u7528buffer\n    // \u4e00\u822c\u7684json\u683c\u5f0f\u4e00\u822c\u76f4\u63a5\u8fd4\u56dejson\u5bf9\u8c61\n    auto response_json_res = api.parse_response(utils::to_buffer(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_album_detail] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n    auto response_json = response_json_res.unwrap();\n    co_return Ok(response_json);\n}\n</code></pre> <p>\u5176\u4e2d<code>Session</code>\u662f\u8d1f\u8d23\u7ba1\u7406\u8bf7\u6c42\u4e0a\u4e0b\u6587, \u5e76\u53d1\u8d77\u8bf7\u6c42\u7684\u7c7b, \u5185\u90e8\u6709\u6bcf\u4e2a\u5b9e\u4f8b\u5404\u81ea\u7684\u4e0a\u4e0b\u6587\u62f7\u8d1d\u548c\u6307\u5411\u5168\u5c40\u4e0a\u4e0b\u6587\u7684\u5f15\u7528. \u6240\u6709\u7684\u8bf7\u6c42\u90fd\u901a\u8fc7<code>Session::perform_request</code>\u51fd\u6570\u53d1\u9001</p> <p><code>Api</code>\u7c7b\u8d1f\u8d23\u6784\u9020\u8bf7\u6c42, \u7701\u53bb\u624b\u52a8\u62fc\u63a5\u53c2\u6570\u7684\u5de5\u4f5c. \u591a\u6570Api\u90fd\u53ef\u4ee5\u81ea\u52a8\u62fc\u63a5\u53c2\u6570, \u90e8\u5206\u60c5\u51b5\u4e0b\u9700\u8981\u624b\u52a8\u6784\u9020\u8bf7\u6c42.</p>"},{"location":"Documents/album/","title":"Album","text":"<p>\u4e13\u8f91\u76f8\u5173Api</p>"},{"location":"Documents/album/#function-get_album_cover_url","title":"function get_album_cover_url","text":"<p>\u83b7\u53d6\u4e13\u8f91\u5c01\u9762url <pre><code>std::string qqmusic::get_album_cover_url (\n    std::string_view mid,\n    CoverSize size\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u66f2mid </li> <li><code>size</code> \u6b4c\u66f2\u5c01\u9762\u5c3a\u5bf8</li> </ul> <p>Returns:</p> <p>std::string\u683c\u5f0f\u6b4c\u66f2\u5c01\u9762\u7684url </p>"},{"location":"Documents/album/#function-get_album_detail","title":"function get_album_detail","text":"<p>\u4ecemid\u83b7\u53d6\u4e13\u8f91\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_album_detail (\n    std::string_view album_mid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>album_mid</code> \u4e13\u8f91mid</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/album/#function-get_album_detail_1","title":"function get_album_detail","text":"<p>\u4eceid\u83b7\u53d6\u4e13\u8f91\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_album_detail (\n    uint64_t album_id\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>album_id</code> \u4e13\u8f91id</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/album/#function-get_album_songs","title":"function get_album_songs","text":"<p>\u4ecemid\u83b7\u53d6\u4e13\u8f91\u6b4c\u66f2\u5217\u8868 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_album_songs (\n    std::string_view album_mid,\n    unsigned int num=10,\n    unsigned int page=1\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>album_mid</code> \u4e13\u8f91mid</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/album/#function-get_album_songs_1","title":"function get_album_songs","text":"<p>\u4eceid\u83b7\u53d6\u4e13\u8f91\u6b4c\u66f2\u5217\u8868 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_album_songs (\n    uint64_t album_id,\n    unsigned int num=10,\n    unsigned int page=1\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>album_id</code> \u4e13\u8f91id</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/login/","title":"Login","text":"<p>\u767b\u9646\u76f8\u5173Api</p> <pre><code>/**\n * @brief \u767b\u9646\u7c7b\u578b\u679a\u4e3e\n * */\nenum class QRLoginType { QQ, WX };\n\n/**\n * @brief \u624b\u673a\u53f7\u767b\u9646\u72b6\u6001\u679a\u4e3e\n * */\nenum class PhoneLoginEvent : int { \n    SEND = 0,           ///&lt; \u5df2\u53d1\u9001\n    CAPTCHA = 20276,    ///&lt; \u9700\u8981\u6ed1\u5757\u9a8c\u8bc1\n    FREQUENCY = 100001, ///&lt; \u64cd\u4f5c\u8fc7\u4e8e\u9891\u7e41\n    OTHER = -1          ///&lt; \u5176\u4ed6\n};\n\n/**\n * @struct PhoneLoginEvent\n *\n * @brief \u624b\u673a\u53f7\u767b\u9646\u4e8b\u4ef6\u5305\u88c5\u5668\n * */\nstruct PhoneLoginResult {\n    PhoneLoginEvent event;\n    std::string msg;\n};\n\n/**\n * @struct QRCode\n *\n * @brief \u4e8c\u7ef4\u7801\u4fe1\u606f\n * */\nstruct QRCode {\n    QRLoginType qr_type;         ///&lt; qr code type\n    std::string identifier;      ///&lt; qr code identifier\n    std::string mimie_type;      ///&lt; qr code image type\n    qqmusic::utils::buffer data; ///&lt; qr code image binary data\n};\n\n/**\n * @brief \u4e8c\u7ef4\u7801\u767b\u9646\u7ed3\u679c\u5c01\u88c5\n * */\nstruct QRCodeLoginResult {\n    QRCodeLoginEvent status{QRCodeLoginEvent::Status::OTHER};\n    std::optional&lt;utils::Credential&gt; credential;\n};\n</code></pre>"},{"location":"Documents/login/#class-qqmusicqrcodeloginevent","title":"Class qqmusic::QRCodeLoginEvent","text":"<p>ClassList &gt; qqmusic &gt; QRCodeLoginEvent</p> <p>\u4e8c\u7ef4\u7801\u767b\u9646\u4e8b\u4ef6 </p> <ul> <li><code>#include &lt;login.h&gt;</code></li> </ul>"},{"location":"Documents/login/#public-types","title":"Public Types","text":"Type Name enum Status \u4e8c\u7ef4\u7801\u72b6\u6001"},{"location":"Documents/login/#public-functions","title":"Public Functions","text":"Type Name QRCodeLoginEvent (Status stat) \u4ece\u72b6\u6001\u6784\u9020 QRCodeLoginEvent (unsigned int code) \u4eceHttp\u8bf7\u6c42\u8fd4\u56de\u7684\u72b6\u6001\u7801\u6784\u9020 std::string_view name () const\u83b7\u53d6\u5f53\u524d\u72b6\u6001\u7684\u540d\u5b57 bool operator!= (const QRCodeLoginEvent &amp; e) \u72b6\u6001\u662f\u5426\u4e0d\u76f8\u540c bool operator!= (Status stat) \u548c\u679a\u4e3e\u76f4\u63a5\u6bd4\u8f83\u662f\u5426\u4e0d\u76f8\u540c bool operator== (const QRCodeLoginEvent &amp; e) \u72b6\u6001\u662f\u5426\u76f8\u540c bool operator== (Status stat) \u548c\u679a\u4e3e\u76f4\u63a5\u6bd4\u8f83\u662f\u5426\u76f8\u540c"},{"location":"Documents/login/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Documents/login/#enum-status","title":"enum Status","text":"<p>\u4e8c\u7ef4\u7801\u72b6\u6001 <pre><code>enum qqmusic::QRCodeLoginEvent::Status {\n    DONE,\n    SCAN,\n    CONF,\n    REFUSE,\n    TIMEOUT,\n    OTHER\n};\n</code></pre></p>"},{"location":"Documents/login/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Documents/login/#function-qrcodeloginevent-12","title":"function QRCodeLoginEvent [1/2]","text":"<p>\u4ece\u72b6\u6001\u6784\u9020 <pre><code>inline qqmusic::QRCodeLoginEvent::QRCodeLoginEvent (\n    Status stat\n) \n</code></pre></p>"},{"location":"Documents/login/#function-qrcodeloginevent-22","title":"function QRCodeLoginEvent [2/2]","text":"<p>\u4eceHttp\u8bf7\u6c42\u8fd4\u56de\u7684\u72b6\u6001\u7801\u6784\u9020 <pre><code>inline qqmusic::QRCodeLoginEvent::QRCodeLoginEvent (\n    unsigned int code\n) \n</code></pre></p>"},{"location":"Documents/login/#function-name","title":"function name","text":"<p>\u83b7\u53d6\u5f53\u524d\u72b6\u6001\u7684\u540d\u5b57 <pre><code>inline std::string_view qqmusic::QRCodeLoginEvent::name () const\n</code></pre></p>"},{"location":"Documents/login/#function-operator","title":"function operator!=","text":"<p>\u72b6\u6001\u662f\u5426\u4e0d\u76f8\u540c <pre><code>inline bool qqmusic::QRCodeLoginEvent::operator!= (\n    const QRCodeLoginEvent &amp; e\n) \n</code></pre></p>"},{"location":"Documents/login/#function-operator_1","title":"function operator!=","text":"<p>\u548c\u679a\u4e3e\u76f4\u63a5\u6bd4\u8f83\u662f\u5426\u4e0d\u76f8\u540c <pre><code>inline bool qqmusic::QRCodeLoginEvent::operator!= (\n    Status stat\n) \n</code></pre></p>"},{"location":"Documents/login/#function-operator_2","title":"function operator==","text":"<p>\u72b6\u6001\u662f\u5426\u76f8\u540c <pre><code>inline bool qqmusic::QRCodeLoginEvent::operator== (\n    const QRCodeLoginEvent &amp; e\n) \n</code></pre></p>"},{"location":"Documents/login/#function-operator_3","title":"function operator==","text":"<p>\u548c\u679a\u4e3e\u76f4\u63a5\u6bd4\u8f83\u662f\u5426\u76f8\u540c <pre><code>inline bool qqmusic::QRCodeLoginEvent::operator== (\n    Status stat\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/login.h</code></p>"},{"location":"Documents/login/#function-get_qrcode","title":"function get_qrcode","text":"<p>\u83b7\u53d6\u767b\u9646\u4e8c\u7ef4\u7801 <pre><code>qqmusic::Task&lt; qqmusic::Result&lt; QRCode &gt; &gt; qqmusic::get_qrcode (\n    QRLoginType login_type\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>login_type</code> \u767b\u9646\u7c7b\u578b</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786e\u7ed3\u679c\u7684<code>Task&lt; Result &lt; QRCode &gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/login/#function-check_qq_qr","title":"function check_qq_qr","text":"<p>\u68c0\u67e5QQ\u4e8c\u7ef4\u7801\u72b6\u6001 <pre><code>qqmusic::Task&lt; qqmusic::Result&lt; QRCodeLoginResult &gt; &gt; qqmusic::check_qq_qr (\n    QRCode &amp; qrc\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>qrc</code> QQ\u4e8c\u7ef4\u7801</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786e\u7ed3\u679c\u7684<code>Task&lt; Result &lt; QRCodeLoginResult &gt;&gt;</code>. \u5982\u679c\u767b\u9646\u6210\u529f\u4f1a\u5305\u542bCredential</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/login/#function-check_wx_qr","title":"function check_wx_qr","text":"<p>\u68c0\u67e5\u5fae\u4fe1\u4e8c\u7ef4\u7801\u72b6\u6001 <pre><code>qqmusic::Task&lt; qqmusic::Result&lt; QRCodeLoginResult &gt; &gt; qqmusic::check_wx_qr (\n    QRCode &amp; qrc\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>qrc</code> \u5fae\u4fe1\u4e8c\u7ef4\u7801</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786e\u7ed3\u679c\u7684<code>Task&lt; Result &lt; QRCodeLoginResult &gt;&gt;</code>. \u5982\u679c\u767b\u9646\u6210\u529f\u4f1a\u5305\u542bCredential</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/login/#function-send_authcode","title":"function send_authcode","text":"<p>\u5411\u6307\u5b9a\u624b\u673a\u53f7\u53d1\u9001\u9a8c\u8bc1\u7801 <pre><code>qqmusic::Task&lt; qqmusic::Result&lt; PhoneLoginResult &gt; &gt; qqmusic::send_authcode (\n    std::string_view phone,\n    std::string_view country_code=\"86\"\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>phone</code> \u624b\u673a\u53f7 </li> <li><code>country_code</code> \u5730\u533a\u524d\u7f00</li> </ul> <p>Returns:</p> <p><code>qqmusic::Task&lt;qqmusic::Result&lt; PhoneLoginResult &gt;&gt;</code> \u51fa\u9519\u5c31\u4f1a\u8fd4\u56de<code>Err</code></p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code></p> <p>Warning:</p> <p>\u8be5\u51fd\u6570\u4ecd\u6709\u95ee\u9898, \u4e0d\u5e94\u4f7f\u7528 </p>"},{"location":"Documents/login/#function-phone_authorize","title":"function phone_authorize","text":"<p>\u624b\u673a\u53f7\u8ba4\u8bc1 <pre><code>qqmusic::Task&lt; qqmusic::Result&lt; utils::Credential &gt; &gt; qqmusic::phone_authorize (\n    std::string_view phone,\n    std::string_view auth_code,\n    std::string_view country_code=\"86\"\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>phone</code> \u624b\u673a\u53f7 </li> <li><code>auth_code</code> \u9a8c\u8bc1\u7801 </li> <li><code>country_code</code> \u5730\u533a\u524d\u7f00</li> </ul> <p>Returns:</p> <p><code>qqmusic::Task&lt;qqmusic::Result&lt; qqmusic::utils::Credential &gt;&gt;</code> \u51fa\u9519\u5c31\u4f1a\u8fd4\u56de<code>Err</code></p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code></p> <p>Warning:</p> <p>\u8be5\u51fd\u6570\u4ecd\u6709\u95ee\u9898, \u4e0d\u5e94\u4f7f\u7528 </p>"},{"location":"Documents/lyric/","title":"Lyric","text":"<p>\u6b4c\u8bcd\u76f8\u5173Api</p> <pre><code>/**\n * @struct Lyric\n *\n * @brief \u6b4c\u8bcd\n * */\nstruct Lyric {\n    std::string lyric; ///&lt; \u539f\u59cb\u6b4c\u8bcd\n    std::string trans; ///&lt; \u7ffb\u8bd1\n    std::string roma;  ///&lt; \u7f57\u9a6c\u97f3\n};\n</code></pre>"},{"location":"Documents/lyric/#function-get_lyric","title":"function get_lyric","text":"<p>\u83b7\u53d6\u6b4c\u66f2\u7684\u6b4c\u8bcd <pre><code>Task&lt; Result &lt; Lyric &gt; &gt; qqmusic::get_lyric (\n    std::string_view mid,\n    bool qrc=false,\n    bool trans=false,\n    bool roma=false\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u66f2mid </li> <li><code>qrc</code> lyric\u662f\u5426\u662fxml\u683c\u5f0f, \u9ed8\u8ba4false </li> <li><code>trans</code> \u662f\u5426\u9644\u5e26\u7ffb\u8bd1 </li> <li><code>roma</code> \u662f\u5426\u9644\u5e26\u7f57\u9a6c\u97f3</li> </ul> <p>Returns:</p> <p>\u539f\u59cb\u7684\u6b4c\u8bcd\u5b57\u7b26\u4e32, qrc\u6b4c\u8bcd\u4ec5\u7ecf\u8fc7\u89e3\u7801, \u8fd8\u662f\u539f\u59cb\u7684xml\u683c\u5f0f</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/lyric/#function-get_lyric_1","title":"function get_lyric","text":"<p>\u83b7\u53d6\u6b4c\u66f2\u7684\u6b4c\u8bcd <pre><code>Task&lt; Result &lt; Lyric &gt; &gt; qqmusic::get_lyric (\n    uint64_t id,\n    bool qrc=false,\n    bool trans=false,\n    bool roma=false\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> \u6b4c\u66f2id </li> <li><code>qrc</code> lyric\u662f\u5426\u662fxml\u683c\u5f0f, \u9ed8\u8ba4false </li> <li><code>trans</code> \u662f\u5426\u9644\u5e26\u7ffb\u8bd1 </li> <li><code>roma</code> \u662f\u5426\u9644\u5e26\u7f57\u9a6c\u97f3</li> </ul> <p>Returns:</p> <p>\u539f\u59cb\u7684\u6b4c\u8bcd\u5b57\u7b26\u4e32, qrc\u6b4c\u8bcd\u4ec5\u7ecf\u8fc7\u89e3\u7801, \u8fd8\u662f\u539f\u59cb\u7684xml\u683c\u5f0f</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/mv/","title":"Mv","text":"<p>MV\u76f8\u5173Api</p> <pre><code>/**\n * @struct MvUrl\n *\n * @brief Mv url\u5c01\u88dd\n * */\nstruct MvUrl {\n    std::string vid;                        ///&lt; Mv\u7684vid\n    std::map&lt;std::string, std::string&gt; mp4; ///&lt; mp4\u683c\u5f0furl\n    std::map&lt;std::string, std::string&gt; hls; ///&lt; hls\u683c\u5f0furl\n};\n</code></pre>"},{"location":"Documents/mv/#function-get_mv_detail","title":"function get_mv_detail","text":"<p>\u83b7\u53d6\u4e00\u7ec4MV\u7684\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_mv_detail (\n    std::span&lt; std::string &gt; vids\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>vids</code> \u5f85\u67e5\u8be2\u7684MV vid\u5217\u8868</li> </ul> <p>Returns:</p> <p>MV\u4fe1\u606fjson</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/mv/#function-get_mv_urls","title":"function get_mv_urls","text":"<p>\u83b7\u53d6mv url <pre><code>Task&lt; Result &lt; std::vector&lt; MvUrl &gt; &gt; &gt; qqmusic::get_mv_urls (\n    std::span&lt; std::string &gt; vids\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>vids</code> \u5f85\u67e5\u8be2\u7684MV vid\u5217\u8868</li> </ul> <p>Returns:</p> <p>MvUrl\u5217\u8868</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/result/","title":"Result","text":"<p>\u63d0\u4f9b\u7edf\u4e00\u7684\u8fd4\u56de\u63a5\u53e3, \u4fbf\u4e8e\u8fdb\u884c\u9519\u8bef\u5904\u7406</p> <p>\u76f8\u5173\u5934\u6587\u4ef6: <code>qqmusic/result.h</code></p>"},{"location":"Documents/result/#qqmusictaskt","title":"<code>qqmusic::Task&lt;T&gt;</code>","text":"<p>\u901a\u7528\u5f02\u6b65\u4efb\u52a1, \u6240\u6709\u7684\u5f02\u6b65Api\u90fd\u4f7f\u7528<code>qqmusic::Task&lt;T&gt;</code>\u5305\u88c5\u8fd4\u56de\u7ed3\u679c</p> <pre><code>template &lt;typename T&gt;\nusing qqmusic::Task&lt;T&gt; = boost::asio::awaitble&lt;T&gt;\n</code></pre>"},{"location":"Documents/result/#qqmusicresultt","title":"<code>qqmusic::Result&lt;T&gt;</code>","text":"<p>\u901a\u7528\u7684\u8fd4\u56de\u7ed3\u679c\u7c7b\u578b, \u6b63\u5e38\u7684\u8fd4\u56de\u7ed3\u679c\u548c\u9519\u8bef\u7ed3\u679c\u5171\u7528\u540c\u4e00\u6761\u901a\u8def\u8fd4\u56de</p> <pre><code>template&lt;typename T&gt;\nusing Result = Result&lt;T, qqmusic::utils::Exception&gt;;\n</code></pre> <p>Usage</p> <pre><code>Result&lt;double&gt; func(double n) {\n    try {\n        auto res = sqrtl(n);\n        // \u8fd4\u56de\u6b63\u786e\u7ed3\u679c\n        return Ok(res);\n    } catch (std::exception&amp; e) {\n        // \u8fd4\u56de\u9519\u8bef\u7ed3\u679c\n        return Err(utils::Exception(utils::Exception::UnknownError, \n                    std::format(\"Error occurred: {}\", e.what())));\n    }\n}\n\nint main() {\n    double n;\n    std::cin &gt;&gt; n;\n    auto res = func(n);\n    if (res.isErr()) {\n        // \u5224\u65ad\u9519\u8bef\u7ed3\u679c\n        std::cout &lt;&lt; res.unwrapErr().what() &lt;&lt; std::endl;\n        return 1;\n    }\n    // \u89e3\u5305\u51fa\u6b63\u786e\u7ed3\u679c\n    double sqrt_n = res.unwrap()\n    std::cout &lt;&lt; sqrt_n &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"Documents/search/","title":"Search","text":"<p>\u641c\u7d22\u76f8\u5173Api</p> <pre><code>/**\n * @brief \u641c\u7d22\u7c7b\u578b\u679a\u4e3e\n * */\nenum class SearchType : unsigned {\n    SONG = 0,         ///&lt; \u6b4c\u66f2\n    SINGER = 1,       ///&lt; \u6b4c\u624b\n    ALBUM = 2,        ///&lt; \u4e13\u8f91\n    SONG_LIST = 3,    ///&lt; \u6b4c\u5355\n    MV = 4,           ///&lt; MV\n    LYRIC = 7,        ///&lt; \u6b4c\u8bcd\n    USER = 8,         ///&lt; \u7528\u6237\n    AUDIO_ALBUM = 15, ///&lt; \u8282\u76ee\u4e13\u8f91\n    AUDIO = 18,       ///&lt; \u8282\u76ee\n};\n</code></pre>"},{"location":"Documents/search/#function-hotkey","title":"function hotkey","text":"<p>\u83b7\u53d6\u641c\u7d22\u70ed\u8bcd <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::hotkey () \n</code></pre></p> <p>Returns:</p> <p>Json\u683c\u5f0f\u7684\u641c\u7d22\u70ed\u8bcd</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/search/#function-keyword_complete","title":"function keyword_complete","text":"<p>\u641c\u7d22\u8bcd\u8054\u60f3\u8865\u5168 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::keyword_complete (\n    std::string_view keyword\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>keyword</code> \u5f53\u524d\u641c\u7d22\u8bcd</li> </ul> <p>Returns:</p> <p>\u5e26\u6709\u9ad8\u4eae\u7684\u8865\u5168\u7ed3\u679c</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/search/#function-quick_search","title":"function quick_search","text":"<p>\u5feb\u901f\u641c\u7d22 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::quick_search (\n    std::string_view keyword\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>keyword</code> \u641c\u7d22\u8bcd</li> </ul> <p>Returns:</p> <p>Json\u683c\u5f0f\u641c\u7d22\u7ed3\u679c</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/search/#function-general_search","title":"function general_search","text":"<p>\u7efc\u5408\u641c\u7d22 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::general_search (\n    std::string_view keyword,\n    unsigned num=15,\n    unsigned page=1,\n    bool highlight=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>keyword</code> \u641c\u7d22\u8bcd </li> <li><code>num</code> \u6bcf\u9875\u7ed3\u679c\u6570, \u9ed8\u8ba4<code>15</code> </li> <li><code>page</code> \u9875\u6570, \u9ed8\u8ba4<code>1</code> </li> <li><code>highlight</code> \u662f\u5426\u9ad8\u4eae, \u9ed8\u8ba4<code>true</code></li> </ul> <p>Returns:</p> <p>Json\u683c\u5f0f\u641c\u7d22\u7ed3\u679c</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/search/#function-search_by_type","title":"function search_by_type","text":"<p>\u6309\u7c7b\u578b\u641c\u7d22 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::search_by_type (\n    std::string_view keyword,\n    SearchType type=SearchType::SONG,\n    unsigned num_per_page=10,\n    unsigned page=1,\n    bool highlight=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>keybord</code> \u641c\u7d22\u8bcd </li> <li><code>type</code> \u641c\u7d22\u7c7b\u578b </li> <li><code>num_per_page</code> \u6bcf\u9875\u7ed3\u679c\u6570 </li> <li><code>page</code> \u9875\u6570</li> </ul> <p>Returns:</p> <p>Json\u683c\u5f0f\u641c\u7d22\u7ed3\u679c</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/singer/","title":"Singer","text":""},{"location":"Documents/singer/#singer","title":"Singer","text":"<p>\u6b4c\u624b\u76f8\u5173Api</p> <pre><code>/**\n * @brief \u533a\u57df\u7c7b\u578b\u679a\u4e3e\n */\nenum class AreaType : int {\n    ALL = -100,\n    CHINA = 200,\n    TAIWAN = 2,\n    AMERICA = 5,\n    JAPAN = 4,\n    KOREA = 3\n};\n\n/**\n * @brief \u98ce\u683c\u7c7b\u578b\u679a\u4e3e\n */\nenum class GenreType : int {\n    ALL = -100,\n    POP = 7,\n    RAP = 3,\n    CHINESE_STYLE = 19,\n    ROCK = 4,\n    ELECTRONIC = 2,\n    FOLK = 8,\n    R_AND_B = 11,\n    ETHNIC = 37,\n    LIGHT_MUSIC = 93,\n    JAZZ = 14,\n    CLASSICAL = 33,\n    COUNTRY = 13,\n    BLUES = 10\n};\n\n/**\n * @brief \u6027\u522b\u7c7b\u578b\u679a\u4e3e\n * */\nenum class GenderType : int {\n    ALL = -100,\n    MALE = 0,\n    FEMALE = 1,\n    GROUP = 2,\n};\n\n/**\n * @brief \u7d22\u5f15\u7c7b\u578b\u679a\u4e3e, \u6309\u9996\u5b57\u6bcd\u7b5b\u9009\u65f6\u9700\u8981\n * */\nenum class IndexType : int {\n    A = 1,\n    B,\n    C,\n    D,\n    E,\n    F,\n    G,\n    H,\n    I,\n    J,\n    K,\n    L,\n    M,\n    N,\n    O,\n    P,\n    Q,\n    R,\n    S,\n    T,\n    U,\n    V,\n    W,\n    X,\n    Y,\n    Z,\n    HASH,\n    ALL = -100\n};\n</code></pre>"},{"location":"Documents/singer/#class-qqmusictabtype","title":"Class qqmusic::TabType","text":"<p>ClassList &gt; qqmusic &gt; TabType</p> <p>\u6807\u7b7e\u7c7b </p> <ul> <li><code>#include &lt;singer.h&gt;</code></li> </ul>"},{"location":"Documents/singer/#public-types","title":"Public Types","text":"Type Name enum Type \u6807\u7b7e\u7c7b\u578b\u679a\u4e3e"},{"location":"Documents/singer/#public-functions","title":"Public Functions","text":"Type Name TabType () = delete\u4f7f\u7528\u679a\u4e3e\u503c\u521d\u59cb\u5316\u6807\u7b7e\u7c7b TabType (Type type)  std::string get_id () const\u83b7\u53d6tab id std::string get_name () const\u83b7\u53d6tab\u540d\u79f0"},{"location":"Documents/singer/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Documents/singer/#enum-type","title":"enum Type","text":"<p>\u6807\u7b7e\u7c7b\u578b\u679a\u4e3e <pre><code>enum qqmusic::TabType::Type {\n    WIKI,\n    ALBUM,\n    COMPOSER,\n    LYRICIST,\n    PRODUCER,\n    ARRANGER,\n    MUSICIAN,\n    SONG,\n    VIDEO\n};\n</code></pre></p>"},{"location":"Documents/singer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Documents/singer/#function-tabtype-12","title":"function TabType [1/2]","text":"<p>\u4f7f\u7528\u679a\u4e3e\u503c\u521d\u59cb\u5316\u6807\u7b7e\u7c7b <pre><code>qqmusic::TabType::TabType () = delete\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>type</code> \u6807\u7b7e\u7c7b\u578b\u679a\u4e3e</li> </ul> <p>Exception:</p> <ul> <li><code>\u82e5\u63d0\u4f9b\u7684\u679a\u4e3e\u503c\u4e0d\u5408\u6cd5</code> </li> </ul>"},{"location":"Documents/singer/#function-tabtype-22","title":"function TabType [2/2]","text":"<pre><code>inline qqmusic::TabType::TabType (\n    Type type\n) \n</code></pre>"},{"location":"Documents/singer/#function-get_id","title":"function get_id","text":"<p>\u83b7\u53d6tab id <pre><code>inline std::string qqmusic::TabType::get_id () const\n</code></pre></p> <p>Returns:</p> <p>std::string\u683c\u5f0ftab id </p>"},{"location":"Documents/singer/#function-get_name","title":"function get_name","text":"<p>\u83b7\u53d6tab\u540d\u79f0 <pre><code>inline std::string qqmusic::TabType::get_name () const\n</code></pre></p> <p>Returns:</p> <p>std::string\u683c\u5f0ftab name </p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/singer.h</code></p>"},{"location":"Documents/singer/#function-get_singer_list","title":"function get_singer_list","text":"<p>\u83b7\u53d6\u7b26\u5408\u7b5b\u9009\u6761\u4ef6\u7684\u6b4c\u624b\u4fe1\u606f\u8868\u5355 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_singer_list (\n    AreaType area=AreaType::ALL,\n    GenderType gender=GenderType::ALL,\n    GenreType genre=GenreType::ALL\n) \n</code></pre></p> <p>\u83b7\u53d6JSON\u683c\u5f0f\u7684\u6b4c\u624b\u4fe1\u606f, \u53ef\u4ee5\u4f7f\u7528area, gender\u548cgenre\u7b5b\u9009</p> <p>Parameters:</p> <ul> <li><code>area</code> \u533a\u57df\u4fe1\u606f\u7b5b\u9009, \u9ed8\u8ba4<code>AreaType::ALL</code>. </li> <li><code>gender</code> \u6027\u522b\u4fe1\u606f\u7b5b\u9009, \u9ed8\u8ba4<code>GenderType::ALL</code>. </li> <li><code>genre</code> \u98ce\u683c\u4fe1\u606f\u7b5b\u9009, \u9ed8\u8ba4<code>GenreType::ALL</code>.</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>See also: AreaType, GenderType, GenreType </p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/singer/#function-get_songs_list_all","title":"function get_songs_list_all","text":"<p>\u83b7\u53d6\u6b4c\u624b\u7684\u6240\u6709\u6b4c\u66f2 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_songs_list_all (\n    std::string_view mid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u624bmid</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/singer/#function-get_singer_list_index","title":"function get_singer_list_index","text":"<p>\u7b5b\u9009\u83b7\u5f97\u6b4c\u66f2\u6b4c\u5355\u539f\u59cb\u6570\u636e <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_singer_list_index (\n    AreaType area=AreaType::ALL,\n    GenderType gender=GenderType::ALL,\n    GenreType genre=GenreType::ALL,\n    IndexType index=IndexType::ALL,\n    unsigned sin=0,\n    unsigned cur_page=1\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>area</code> \u533a\u57df\u4fe1\u606f\u7b5b\u9009, \u9ed8\u8ba4<code>AreaType::ALL</code>. </li> <li><code>gender</code> \u6027\u522b\u4fe1\u606f\u7b5b\u9009, \u9ed8\u8ba4<code>GenderType::ALL</code>. </li> <li><code>genre</code> \u98ce\u683c\u4fe1\u606f\u7b5b\u9009, \u9ed8\u8ba4<code>GenreType::ALL</code>. </li> <li><code>sin</code> \u8df3\u8fc7\u7684\u6761\u76ee\u6570\u91cf, \u9ed8\u8ba4<code>0</code> </li> <li><code>cur_page</code> \u5f53\u524d\u9875\u9762\u7684\u7d22\u5f15, \u9ed8\u8ba4<code>1</code></li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>See also: AreaType, GenderType, GenreType, IndexType </p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/singer/#function-get_singer_list_index_all","title":"function get_singer_list_index_all","text":"<p>\u83b7\u53d6\u6240\u6709\u7b26\u5408\u6761\u4ef6\u7684\u6b4c\u5355\u539f\u59cb\u6570\u636e <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_singer_list_index_all (\n    AreaType area=AreaType::ALL,\n    GenderType gender=GenderType::ALL,\n    GenreType genre=GenreType::ALL,\n    IndexType index=IndexType::ALL\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>area</code> \u533a\u57df\u4fe1\u606f\u7b5b\u9009, \u9ed8\u8ba4<code>AreaType::ALL</code>. </li> <li><code>gender</code> \u6027\u522b\u4fe1\u606f\u7b5b\u9009, \u9ed8\u8ba4<code>GenderType::ALL</code>. </li> <li><code>genre</code> \u98ce\u683c\u4fe1\u606f\u7b5b\u9009, \u9ed8\u8ba4<code>GenreType::ALL</code>. </li> <li><code>index</code> \u7d22\u5f15\u4fe1\u606f\u7b5b\u9009, \u9ed8\u8ba4<code>IndexType::ALL</code>.</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>See also: AreaType, GenderType, GenreType, IndexType </p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/singer/#function-get_singer_info","title":"function get_singer_info","text":"<p>\u83b7\u53d6\u6b4c\u624b\u57fa\u672c\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_singer_info (\n    std::string_view mid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>\u6b4c\u624bmid</code> </li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/singer/#function-get_singer_desc","title":"function get_singer_desc","text":"<p>\u83b7\u53d6\u591a\u4e2a\u6b4c\u624b\u7684\u7b80\u4ecb <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_singer_desc (\n    std::span&lt; std::string &gt; mids,\n    unsigned number=10\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mids</code> \u6b4c\u624bmid\u5217\u8868 </li> <li><code>number</code> \u76f8\u4f3c\u6b4c\u624b\u6570\u91cf, \u9ed8\u8ba4\u4e3a<code>0</code></li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>See also: TabType </p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/singer/#function-get_tab_detail","title":"function get_tab_detail","text":"<p>\u8fd4\u56de\u6807\u7b7e\u8be6\u7ec6\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_tab_detail (\n    std::string_view mid,\n    TabType type,\n    unsigned page=1,\n    unsigned num=10\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u624bmid </li> <li><code>type</code> \u6807\u7b7e\u4fe1\u606f </li> <li><code>page</code> \u9875\u7801 </li> <li><code>num</code> \u6bcf\u9875\u8fd4\u56de\u6570\u91cf</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>See also: TabType </p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/singer/#function-get_similar_singers","title":"function get_similar_singers","text":"<p>\u83b7\u53d6\u76f8\u4f3c\u6b4c\u624b\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_similar_singers (\n    std::string_view mid,\n    unsigned number=10\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mids</code> \u6b4c\u624bmid </li> <li><code>number</code> \u76f8\u4f3c\u6b4c\u624b\u6570\u91cf, \u9ed8\u8ba4\u4e3a<code>0</code></li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>See also: TabType </p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/singer/#function-get_songs_list","title":"function get_songs_list","text":"<p>\u83b7\u53d6\u6b4c\u624b\u6b4c\u66f2\u539f\u59cb\u6570\u636e <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_songs_list (\n    std::string_view mid,\n    unsigned num=10,\n    unsigned begin=0\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u624bmid </li> <li><code>num</code> \u6bcf\u6b21\u83b7\u53d6\u7684\u6700\u5927\u6570\u91cf, \u9ed8\u8ba4<code>10</code>, \u6700\u5927<code>30</code> </li> <li><code>begin</code> \u4ece\u7b2c\u51e0\u4e2a\u5f00\u59cb</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/singer/#function-get_songs_list_all_1","title":"function get_songs_list_all","text":"<p>\u83b7\u53d6\u6b4c\u624b\u7684\u6240\u6709\u6b4c\u66f2 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_songs_list_all (\n    std::string_view mid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u624bmid</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/singer/#function-get_album_list","title":"function get_album_list","text":"<p>\u83b7\u53d6\u6b4c\u624b\u4e13\u8f91\u5217\u8868 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_album_list (\n    std::string_view mid,\n    unsigned number=10,\n    unsigned begin=0\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u624bmid </li> <li><code>number</code> \u5355\u6b21\u83b7\u53d6\u6570\u636e\u91cf, \u9ed8\u8ba4<code>10</code> </li> <li><code>begin</code> \u4ece\u7b2c\u51e0\u4e2a\u5f00\u59cb</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/singer/#function-get_album_list_all","title":"function get_album_list_all","text":"<p>\u83b7\u53d6\u6b4c\u624b\u6240\u6709\u4e13\u8f91 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_album_list_all (\n    std::string_view mid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u624bmid</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/singer/#function-get_mv_list","title":"function get_mv_list","text":"<p>\u83b7\u53d6\u6b4c\u624bMV\u5217\u8868 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_mv_list (\n    std::string_view mid,\n    unsigned number=10,\n    unsigned begin=0\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u624bmid </li> <li><code>number</code> \u5355\u6b21\u83b7\u53d6\u6570\u636e\u91cf, \u9ed8\u8ba4<code>10</code> </li> <li><code>begin</code> \u4ece\u7b2c\u51e0\u4e2a\u5f00\u59cb</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/singer/#function-get_mv_list_all","title":"function get_mv_list_all","text":"<p>\u83b7\u53d6\u6b4c\u624b\u6240\u6709MV <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_mv_list_all (\n    std::string_view mid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u624bmid</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/song/","title":"Song","text":""},{"location":"Documents/song/#song","title":"Song","text":"<p>\u6b4c\u66f2\u76f8\u5173Api</p>"},{"location":"Documents/song/#class-qqmusicbasemediafiletype","title":"Class qqmusic::BaseMediaFileType","text":"<p>ClassList &gt; qqmusic &gt; BaseMediaFileType</p> <p>\u5a92\u4f53\u6587\u4ef6\u7c7b\u578b\u57fa\u7c7b </p> <ul> <li><code>#include &lt;song.h&gt;</code></li> </ul> <p>Inherited by the following classes: qqmusic::EncryptedSongFileType,  qqmusic::SongFileType</p>"},{"location":"Documents/song/#public-functions","title":"Public Functions","text":"Type Name virtual bool encrypted () = 0\u662f\u5426\u52a0\u5bc6 virtual std::string_view expandation () = 0\u83b7\u53d6\u6269\u5c55\u540d virtual std::string_view prefix () = 0\u83b7\u53d6\u57fa\u7c7bID virtual ~BaseMediaFileType () = default"},{"location":"Documents/song/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Documents/song/#function-encrypted","title":"function encrypted","text":"<p>\u662f\u5426\u52a0\u5bc6 <pre><code>virtual bool qqmusic::BaseMediaFileType::encrypted () = 0\n</code></pre></p>"},{"location":"Documents/song/#function-expandation","title":"function expandation","text":"<p>\u83b7\u53d6\u6269\u5c55\u540d <pre><code>virtual std::string_view qqmusic::BaseMediaFileType::expandation () = 0\n</code></pre></p>"},{"location":"Documents/song/#function-prefix","title":"function prefix","text":"<p>\u83b7\u53d6\u57fa\u7c7bID <pre><code>virtual std::string_view qqmusic::BaseMediaFileType::prefix () = 0\n</code></pre></p>"},{"location":"Documents/song/#function-basemediafiletype","title":"function ~BaseMediaFileType","text":"<pre><code>virtual qqmusic::BaseMediaFileType::~BaseMediaFileType () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/song.h</code></p>"},{"location":"Documents/song/#class-qqmusicsongfiletype","title":"Class qqmusic::SongFileType","text":"<p>ClassList &gt; qqmusic &gt; SongFileType</p> <p>\u672a\u52a0\u5bc6\u7684\u6b4c\u66f2\u6587\u4ef6\u7c7b\u679a\u4e3e More...</p> <ul> <li><code>#include &lt;song.h&gt;</code></li> </ul> <p>Inherits the following classes: qqmusic::BaseMediaFileType</p>"},{"location":"Documents/song/#public-types","title":"Public Types","text":"Type Name enum Type \u672a\u52a0\u5bc6\u6b4c\u66f2\u7c7b\u578b\u679a\u4e3e"},{"location":"Documents/song/#public-functions_1","title":"Public Functions","text":"Type Name SongFileType (Type type) \u901a\u8fc7\u7c7b\u578b\u679a\u4e3e\u521d\u59cb\u5316 SongFileType () \u9ed8\u8ba4\u521d\u59cb\u5316\u51fd\u6570, \u9ed8\u8ba4\u683c\u5f0f: MP3_128\u683c\u5f0f virtual bool encrypted () override\u8be5\u683c\u5f0f\u662f\u5426\u52a0\u5bc6 virtual std::string_view expandation () override\u83b7\u53d6\u6b4c\u66f2\u7c7bID\u6269\u5c55 virtual std::string_view prefix () override\u83b7\u53d6\u6b4c\u66f2\u7c7bID\u524d\u7f00 ~SongFileType () override"},{"location":"Documents/song/#public-functions-inherited-from-qqmusicbasemediafiletype","title":"Public Functions inherited from qqmusic::BaseMediaFileType","text":"<p>See qqmusic::BaseMediaFileType</p> Type Name virtual bool encrypted () = 0\u662f\u5426\u52a0\u5bc6 virtual std::string_view expandation () = 0\u83b7\u53d6\u6269\u5c55\u540d virtual std::string_view prefix () = 0\u83b7\u53d6\u57fa\u7c7bID virtual ~BaseMediaFileType () = default"},{"location":"Documents/song/#detailed-description","title":"Detailed Description","text":"<p>See also: BaseMediaFileType </p>"},{"location":"Documents/song/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Documents/song/#enum-type","title":"enum Type","text":"<p>\u672a\u52a0\u5bc6\u6b4c\u66f2\u7c7b\u578b\u679a\u4e3e <pre><code>enum qqmusic::SongFileType::Type {\n    MASTER,\n    ATMOS_2,\n    ATMOS_51,\n    FLAC,\n    OGG_640,\n    OGG_320,\n    OGG_192,\n    OGG_96,\n    MP3_320,\n    MP3_128,\n    ACC_192,\n    ACC_96,\n    ACC_48\n};\n</code></pre></p>"},{"location":"Documents/song/#public-functions-documentation_1","title":"Public Functions Documentation","text":""},{"location":"Documents/song/#function-songfiletype-12","title":"function SongFileType [1/2]","text":"<p>\u901a\u8fc7\u7c7b\u578b\u679a\u4e3e\u521d\u59cb\u5316 <pre><code>inline qqmusic::SongFileType::SongFileType (\n    Type type\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>type</code> \u7c7b\u578b\u679a\u4e3e</li> </ul> <p>See also: SongFileType::Type</p> <p>Exception:</p> <ul> <li><code>\u82e5\u63d0\u4f9b\u7684\u679a\u4e3e\u4e0d\u5408\u6cd5</code> </li> </ul>"},{"location":"Documents/song/#function-songfiletype-22","title":"function SongFileType [2/2]","text":"<p>\u9ed8\u8ba4\u521d\u59cb\u5316\u51fd\u6570, \u9ed8\u8ba4\u683c\u5f0f: MP3_128\u683c\u5f0f <pre><code>inline qqmusic::SongFileType::SongFileType () \n</code></pre></p> <p>See also: SongFileType::Type </p>"},{"location":"Documents/song/#function-encrypted_1","title":"function encrypted","text":"<p>\u8be5\u683c\u5f0f\u662f\u5426\u52a0\u5bc6 <pre><code>inline virtual bool qqmusic::SongFileType::encrypted () override\n</code></pre></p> <p>Returns:</p> <p>\u603b\u662f\u8fd4\u56de<code>false</code> </p> <p>Implements qqmusic::BaseMediaFileType::encrypted</p>"},{"location":"Documents/song/#function-expandation_1","title":"function expandation","text":"<p>\u83b7\u53d6\u6b4c\u66f2\u7c7bID\u6269\u5c55 <pre><code>inline virtual std::string_view qqmusic::SongFileType::expandation () override\n</code></pre></p> <p>Returns:</p> <p>\u8fd4\u56de<code>std::string</code>\u683c\u5f0f\u7684\u7c7b\u578b\u6269\u5c55\u540d </p> <p>Implements qqmusic::BaseMediaFileType::expandation</p>"},{"location":"Documents/song/#function-prefix_1","title":"function prefix","text":"<p>\u83b7\u53d6\u6b4c\u66f2\u7c7bID\u524d\u7f00 <pre><code>inline virtual std::string_view qqmusic::SongFileType::prefix () override\n</code></pre></p> <p>Returns:</p> <p>\u8fd4\u56de<code>std::string</code>\u683c\u5f0f\u7684\u7c7b\u578b\u524d\u7f00 </p> <p>Implements qqmusic::BaseMediaFileType::prefix</p>"},{"location":"Documents/song/#function-songfiletype","title":"function ~SongFileType","text":"<pre><code>qqmusic::SongFileType::~SongFileType () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/song.h</code></p>"},{"location":"Documents/song/#class-qqmusicencryptedsongfiletype","title":"Class qqmusic::EncryptedSongFileType","text":"<p>ClassList &gt; qqmusic &gt; EncryptedSongFileType</p> <p>\u52a0\u5bc6\u6b4c\u66f2\u6587\u4ef6\u7c7b\u578b More...</p> <ul> <li><code>#include &lt;song.h&gt;</code></li> </ul> <p>Inherits the following classes: qqmusic::BaseMediaFileType</p>"},{"location":"Documents/song/#public-types_1","title":"Public Types","text":"Type Name enum Type \u52a0\u5bc6\u6b4c\u66f2\u7c7b\u578b\u679a\u4e3e"},{"location":"Documents/song/#public-functions_2","title":"Public Functions","text":"Type Name EncryptedSongFileType (Type type) \u901a\u8fc7\u7c7b\u578b\u679a\u4e3e\u521d\u59cb\u5316 EncryptedSongFileType () \u9ed8\u8ba4\u521d\u59cb\u5316\u51fd\u6570, \u9ed8\u8ba4\u683c\u5f0f: FLAC\u683c\u5f0f virtual bool encrypted () override\u8be5\u683c\u5f0f\u662f\u5426\u52a0\u5bc6 virtual std::string_view expandation () override\u83b7\u53d6\u6b4c\u66f2\u7c7bID\u6269\u5c55 virtual std::string_view prefix () override\u83b7\u53d6\u6b4c\u66f2\u7c7bID\u524d\u7f00 ~EncryptedSongFileType () override"},{"location":"Documents/song/#public-functions-inherited-from-qqmusicbasemediafiletype_1","title":"Public Functions inherited from qqmusic::BaseMediaFileType","text":"<p>See qqmusic::BaseMediaFileType</p> Type Name virtual bool encrypted () = 0\u662f\u5426\u52a0\u5bc6 virtual std::string_view expandation () = 0\u83b7\u53d6\u6269\u5c55\u540d virtual std::string_view prefix () = 0\u83b7\u53d6\u57fa\u7c7bID virtual ~BaseMediaFileType () = default"},{"location":"Documents/song/#detailed-description_1","title":"Detailed Description","text":"<p>See also: BaseMediaFileType </p>"},{"location":"Documents/song/#public-types-documentation_1","title":"Public Types Documentation","text":""},{"location":"Documents/song/#enum-type_1","title":"enum Type","text":"<p>\u52a0\u5bc6\u6b4c\u66f2\u7c7b\u578b\u679a\u4e3e <pre><code>enum qqmusic::EncryptedSongFileType::Type {\n    MASTER,\n    ATMOS_2,\n    ATMOS_51,\n    FLAC,\n    OGG_640,\n    OGG_320,\n    OGG_192,\n    OGG_96\n};\n</code></pre></p>"},{"location":"Documents/song/#public-functions-documentation_2","title":"Public Functions Documentation","text":""},{"location":"Documents/song/#function-encryptedsongfiletype-12","title":"function EncryptedSongFileType [1/2]","text":"<p>\u901a\u8fc7\u7c7b\u578b\u679a\u4e3e\u521d\u59cb\u5316 <pre><code>inline qqmusic::EncryptedSongFileType::EncryptedSongFileType (\n    Type type\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>type</code> \u7c7b\u578b\u679a\u4e3e</li> </ul> <p>See also: EncryptedSongFileType::Type</p> <p>Exception:</p> <ul> <li><code>\u82e5\u63d0\u4f9b\u7684\u679a\u4e3e\u4e0d\u5408\u6cd5</code> </li> </ul>"},{"location":"Documents/song/#function-encryptedsongfiletype-22","title":"function EncryptedSongFileType [2/2]","text":"<p>\u9ed8\u8ba4\u521d\u59cb\u5316\u51fd\u6570, \u9ed8\u8ba4\u683c\u5f0f: FLAC\u683c\u5f0f <pre><code>inline qqmusic::EncryptedSongFileType::EncryptedSongFileType () \n</code></pre></p> <p>See also: SongFileType::Type </p>"},{"location":"Documents/song/#function-encrypted_2","title":"function encrypted","text":"<p>\u8be5\u683c\u5f0f\u662f\u5426\u52a0\u5bc6 <pre><code>inline virtual bool qqmusic::EncryptedSongFileType::encrypted () override\n</code></pre></p> <p>Returns:</p> <p>\u603b\u662f\u8fd4\u56de<code>true</code> </p> <p>Implements qqmusic::BaseMediaFileType::encrypted</p>"},{"location":"Documents/song/#function-expandation_2","title":"function expandation","text":"<p>\u83b7\u53d6\u6b4c\u66f2\u7c7bID\u6269\u5c55 <pre><code>inline virtual std::string_view qqmusic::EncryptedSongFileType::expandation () override\n</code></pre></p> <p>Returns:</p> <p>\u8fd4\u56de<code>std::string</code>\u683c\u5f0f\u7684\u7c7b\u578b\u6269\u5c55\u540d </p> <p>Implements qqmusic::BaseMediaFileType::expandation</p>"},{"location":"Documents/song/#function-prefix_2","title":"function prefix","text":"<p>\u83b7\u53d6\u6b4c\u66f2\u7c7bID\u524d\u7f00 <pre><code>inline virtual std::string_view qqmusic::EncryptedSongFileType::prefix () override\n</code></pre></p> <p>Returns:</p> <p>\u8fd4\u56de<code>std::string</code>\u683c\u5f0f\u7684\u7c7b\u578b\u524d\u7f00 </p> <p>Implements qqmusic::BaseMediaFileType::prefix</p>"},{"location":"Documents/song/#function-encryptedsongfiletype","title":"function ~EncryptedSongFileType","text":"<pre><code>qqmusic::EncryptedSongFileType::~EncryptedSongFileType () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/song.h</code></p>"},{"location":"Documents/song/#function-query_song","title":"function query_song","text":"<p>\u6279\u91cf\u67e5\u8be2\u6b4c\u66f2\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::query_song (\n    std::span&lt; std::string &gt; mids\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mids</code> \u5f85\u67e5\u8be2\u6b4c\u66f2mid\u5217\u8868</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p> <pre><code>/**\n * @struct SongInfo\n *\n * @var SongInfo::mid \u6b4c\u66f2mid\n * @var SongInfo url \u6b4c\u66f2\u6587\u4ef6\u5730\u5740, \u5982\u679c\u6ca1\u6709\u5219\u662f`std::nullopt`\n * @var SongInfo ekey \u6b4c\u66f2\u5bc6\u94a5, \u5982\u679c\u6ca1\u6709\u5219\u662f`std::nullopt`\n * */\nstruct SongInfo {\n    std::string mid;\n    std::optional&lt;std::string&gt; url = std::nullopt;\n    std::optional&lt;std::string&gt; ekey = std::nullopt;\n};\n</code></pre>"},{"location":"Documents/song/#function-get_song_urls","title":"function get_song_urls","text":"<p>\u6279\u91cf\u83b7\u53d6\u6b4c\u66f2\u64ad\u653e\u94fe\u63a5 <pre><code>Task&lt; Result &lt; std::vector&lt; SongInfo &gt; &gt; &gt; qqmusic::get_song_urls (\n    std::span&lt; std::string &gt; mids,\n    std::unique_ptr&lt; BaseMediaFileType &gt; file_type=std::make_unique&lt; SongFileType &gt;(),\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>@params mids \u6b4c\u66f2mid\u5217\u8868 @params file_type \u6b4c\u66f2\u6587\u4ef6\u7c7b\u578b, \u9ed8\u8ba4MP3_128\u7c7b\u578b @params credential \u51ed\u8bc1\u4fe1\u606f</p> <p>\u8c03\u7528\u793a\u4f8b:  <pre><code>std::vector&lt;std::string&gt; mids{\"002n5zzy3VVGau\"};\n\n// \u672a\u52a0\u5bc6\u7c7b\u578b\nauto res = co_await get_song_urls(mids,\n    std::make_unique&lt;SongFileType&gt;(SongFileType::ACC_192));\n\n// \u52a0\u5bc6\u6587\u4ef6\u7c7b\u578b \nauto res = co_await get_song_urls(mids,\n    std::make_unique&lt;EncryptedSongFileType&gt;(EncryptedSongFileType::MASTER));\n</code></pre></p> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>See also: BaseMediaFileType, SongFileType, EncryptedSongFileType </p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/song/#function-get_try_url","title":"function get_try_url","text":"<p>\u83b7\u53d6\u8bd5\u542c\u94fe\u63a5 <pre><code>Task&lt; Result &lt; std::string &gt; &gt; qqmusic::get_try_url (\n    std::string_view mid,\n    std::string_view vs\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>area</code> \u533a\u57df\u4fe1\u606f\u7b5b\u9009, \u9ed8\u8ba4<code>AreaType::ALL</code>. </li> <li><code>gender</code> \u6027\u522b\u4fe1\u606f\u7b5b\u9009, \u9ed8\u8ba4<code>GenderType::ALL</code>. </li> <li><code>genre</code> \u98ce\u683c\u4fe1\u606f\u7b5b\u9009, \u9ed8\u8ba4<code>GenreType::ALL</code>.</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>See also: AreaType, GenderType, GenreType </p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/song/#function-get_song_detail","title":"function get_song_detail","text":"<p>\u83b7\u53d6\u6b4c\u66f2\u8be6\u7ec6\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_song_detail (\n    std::string_view mid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u66f2mid</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/song/#function-get_song_detail_1","title":"function get_song_detail","text":"<p>\u83b7\u53d6\u6b4c\u66f2\u8be6\u7ec6\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_song_detail (\n    uint64_t id\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> \u6b4c\u66f2id</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/song/#function-get_similar_songs","title":"function get_similar_songs","text":"<p>\u83b7\u53d6\u76f8\u4f3c\u6b4c\u66f2\u5217\u8868 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_similar_songs (\n    uint64_t songid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> \u6b4c\u66f2id</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/song/#function-get_labels","title":"function get_labels","text":"<p>\u83b7\u53d6\u6b4c\u66f2\u6807\u7b7e\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_labels (\n    uint64_t songid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> \u6b4c\u66f2id</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/song/#function-get_related_songlist","title":"function get_related_songlist","text":"<p>\u83b7\u53d6\u76f8\u5173\u6b4c\u5355\u5217\u8868 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_related_songlist (\n    uint64_t songid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> \u6b4c\u66f2id</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/song/#function-get_related_mv","title":"function get_related_mv","text":"<p>\u83b7\u53d6\u76f8\u5173MV <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_related_mv (\n    uint64_t songid,\n    std::optional&lt; std::string &gt; last_mvid=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> \u6b4c\u66f2id</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/song/#function-get_other_version","title":"function get_other_version","text":"<p>\u83b7\u53d6\u540c\u540d\u6b4c\u66f2\u7684\u5176\u4ed6\u7248\u672c <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_other_version (\n    std::string_view mid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u66f2mid</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/song/#function-get_other_version_1","title":"function get_other_version","text":"<p>\u83b7\u53d6\u540c\u540d\u6b4c\u66f2\u7684\u5176\u4ed6\u7248\u672c <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_other_version (\n    uint64_t id\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> \u6b4c\u66f2id</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/song/#function-get_producer_info","title":"function get_producer_info","text":"<p>\u83b7\u53d6\u6b4c\u66f2\u5236\u4f5c\u8005\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_producer_info (\n    std::string_view mid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u66f2mid</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u53ef\u80fd\u8fd4\u56deJSON\u7684<code>null</code>, \u5373\u6ca1\u6709\u5236\u4f5c\u8005\u4fe1\u606f </p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/song/#function-get_producer_info_1","title":"function get_producer_info","text":"<p>\u83b7\u53d6\u6b4c\u66f2\u5236\u4f5c\u8005\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_producer_info (\n    uint64_t id\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> \u6b4c\u66f2id</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u53ef\u80fd\u8fd4\u56deJSON\u7684<code>null</code>, \u5373\u6ca1\u6709\u5236\u4f5c\u8005\u4fe1\u606f </p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/song/#function-get_sheet","title":"function get_sheet","text":"<p>\u83b7\u53d6\u66f2\u8c31\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_sheet (\n    std::string_view mid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u66f2mid</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/song/#function-get_fav_num","title":"function get_fav_num","text":"<p>\u83b7\u53d6\u6b4c\u66f2\u7684\u6536\u85cf\u91cf <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_fav_num (\n    std::span&lt; uint64_t &gt; id_list,\n    bool readable=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id_list</code> \u6b4c\u66f2id\u5217\u8868 </li> <li><code>readable</code> \u662f\u5426\u4eba\u7c7b\u53ef\u8bfb</li> </ul> <p>\u793a\u4f8b:</p> <pre><code>readable == false \u8fd4\u56de: {'438910555': 1000001}\nreadable == true \u8fd4\u56de:  {'438910555': '550w+'}\n</code></pre> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/song_list/","title":"SongList","text":"<p>\u6b4c\u5355\u76f8\u5173Api</p>"},{"location":"Documents/song_list/#function-get_songlist_detail","title":"function get_songlist_detail","text":"<p>\u83b7\u53d6\u6b4c\u5355\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_songlist_detail (\n    uint64_t dissid,\n    unsigned dirid=0,\n    unsigned num=10,\n    unsigned page=1,\n    bool only_song=false,\n    bool tag=true,\n    bool user_info=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dissid</code> \u6b4c\u5355ID </li> <li><code>dirid</code> \u6b4c\u5355drid, \u9ed8\u8ba4\u4e3a<code>0</code> </li> <li><code>num</code> \u8fd4\u56desonglist\u5143\u7d20\u6570\u91cf, \u9ed8\u8ba4\u4e3a<code>10</code> </li> <li><code>page</code> \u7b2c\u51e0\u9875, \u9ed8\u8ba4\u4e3a<code>1</code> </li> <li><code>only_song</code> \u662f\u5426\u4ec5\u8fd4\u56de\u6b4c\u66f2\u4fe1\u606f, \u9ed8\u8ba4<code>false</code> </li> <li><code>tag</code> \u662f\u5426\u8fd4\u56de\u6b4c\u5355\u6807\u7b7e\u4fe1\u606f, \u9ed8\u8ba4<code>true</code> </li> <li><code>user_info</code> \u662f\u5426\u8fd4\u56de\u6b4c\u5355\u521b\u5efa\u8005\u7684\u7528\u6237\u4fe1\u606f, \u9ed8\u8ba4<code>true</code></li> </ul> <p>Returns:</p> <p>Json\u683c\u5f0f\u7684\u6b4c\u5355\u4fe1\u606f</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/song_list/#function-get_songlist","title":"function get_songlist","text":"<p>\u83b7\u53d6\u6b4c\u5355\u5217\u8868 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_songlist (\n    uint64_t dissid,\n    unsigned dirid=0\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dissid</code> \u6b4c\u5355ID </li> <li><code>dirid</code> \u6b4c\u5355dirid, \u9ed8\u8ba4\u4e3a0</li> </ul> <p>Returns:</p> <p>Json\u683c\u5f0f\u6b4c\u5355\u5217\u8868</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/song_list/#function-songlist_create","title":"function songlist_create","text":"<p>\u521b\u5efa\u6b4c\u5355 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::songlist_create (\n    std::string_view dirname,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dirname</code> \u65b0\u7684\u6b4c\u5355\u540d\u79f0 </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f</li> </ul> <p>Returns:</p> <p>\u521b\u5efa\u6b4c\u5355\u7684\u57fa\u672c\u4fe1\u606f</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code></p> <p>Warning:</p> <p>\u6b4c\u5355\u540d\u79f0\u4e0d\u5e94\u8be5\u542b\u6709\u9664\u4e86\u6b63\u5e38\u5b57\u7b26\u4e4b\u5916\u7684\u4e1c\u897f, \u4f8b\u5982emoji, \u8fd9\u5c06\u5bfc\u81f4\u6b4c\u5355\u867d\u7136\u88ab\u6b63\u786e\u521b\u5efa, \u4f46\u662f\u8fd4\u56de\u65f6json\u89e3\u6790\u5f02\u5e38\u62a5\u9519 </p>"},{"location":"Documents/song_list/#function-songlist_delete","title":"function songlist_delete","text":"<p>\u5220\u9664\u6b4c\u5355 <pre><code>Task&lt; Result &lt; bool &gt; &gt; qqmusic::songlist_delete (\n    uint64_t dirid,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dirid</code> \u6b4c\u5355ID </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f</li> </ul> <p>Returns:</p> <p>\u662f\u5426\u5220\u9664\u6210\u529f, \u5982\u679c\u4e0d\u5b58\u5728\u8fd9\u4e2a\u6b4c\u5355\u5219\u8fd4\u56de<code>false</code> </p>"},{"location":"Documents/song_list/#function-songlist_add_songs","title":"function songlist_add_songs","text":"<p>\u5411\u6b4c\u5355\u5185\u6dfb\u52a0\u6b4c\u66f2 <pre><code>Task&lt; Result &lt; bool &gt; &gt; qqmusic::songlist_add_songs (\n    uint64_t dirid,\n    std::span&lt; uint64_t &gt; song_ids,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dirid</code> \u6b4c\u5355ID </li> <li><code>song_ids</code> \u5f85\u6dfb\u52a0\u6b4c\u5355\u5217\u8868 </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f</li> </ul> <p>Returns:</p> <p>\u662f\u5426\u6dfb\u52a0\u6210\u529f, \u6b4c\u66f2\u5df2\u5b58\u5728\u5219\u8fd4\u56de<code>false</code> </p>"},{"location":"Documents/song_list/#function-songlist_delete_songs","title":"function songlist_delete_songs","text":"<p>\u5220\u9664\u6b4c\u5355\u5185\u6307\u5b9a\u6b4c\u66f2 <pre><code>Task&lt; Result &lt; bool &gt; &gt; qqmusic::songlist_delete_songs (\n    uint64_t dirid,\n    std::span&lt; uint64_t &gt; song_ids,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dirid</code> \u6b4c\u5355ID </li> <li><code>song_ids</code> \u5f85\u5220\u9664\u6b4c\u5355\u5217\u8868 </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f</li> </ul> <p>Returns:</p> <p>\u662f\u5426\u5220\u9664\u6210\u529f, \u6b4c\u66f2\u4e0d\u5b58\u5728\u5219\u8fd4\u56de<code>false</code> </p>"},{"location":"Documents/toplist/","title":"TopList","text":""},{"location":"Documents/toplist/#function-get_toplist_category","title":"function get_toplist_category","text":"<p>\u83b7\u53d6\u6240\u6709\u6392\u884c\u699c <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_toplist_category () \n</code></pre></p>"},{"location":"Documents/toplist/#function-get_toplist_item_detail","title":"function get_toplist_item_detail","text":"<p>\u83b7\u53d6\u6392\u884c\u699c\u6761\u76ee\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_toplist_item_detail (\n    unsigned top_id,\n    unsigned num=10,\n    unsigned page=1,\n    bool tag=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>top_id</code> \u6392\u884c\u699cID </li> <li><code>num</code> \u8fd4\u56de\u6570\u91cf, \u9ed8\u8ba4\u4e3a<code>10</code> </li> <li><code>page</code> \u9875\u7801, \u9ed8\u8ba4\u4e3a<code>0</code> </li> <li><code>tag</code> \u662f\u5426\u8fd4\u56de\u6b4c\u66f2\u6807\u7b7e, \u9ed8\u8ba4\u4e3a<code>true</code></li> </ul> <p>Returns:</p>"},{"location":"Documents/user/","title":"User","text":"<p>\u7528\u6237\u76f8\u5173Api</p>"},{"location":"Documents/user/#function-get_euin","title":"function get_euin","text":"<p>\u7531musicid\u83b7\u53d6euin <pre><code>Task&lt; Result &lt; std::string &gt; &gt; qqmusic::get_euin (\n    uint64_t musicid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>musicid</code> MusicID, \u901a\u5e38\u662fQQ\u53f7</li> </ul> <p>Returns:</p> <p>Euin </p>"},{"location":"Documents/user/#function-get_musicid","title":"function get_musicid","text":"<p>\u7531euin\u83b7\u53d6musicid <pre><code>Task&lt; Result &lt; uint64_t &gt; &gt; qqmusic::get_musicid (\n    std::string_view euin\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>euin</code> encrypt_uin</li> </ul> <p>Returns:</p> <p>musicid </p>"},{"location":"Documents/user/#function-get_homepage","title":"function get_homepage","text":"<p>\u83b7\u53d6\u7528\u6237\u4e3b\u9875\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_homepage (\n    std::string_view euin,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>euin</code> encrypt_uin </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f</li> </ul> <p>Returns:</p> <p>\u7528\u6237\u4e3b\u9875\u4fe1\u606f, \u5305\u542b\u97f3\u4e50\u57fa\u56e0, \u6b4c\u5355\u7b49 </p>"},{"location":"Documents/user/#function-get_vip_info","title":"function get_vip_info","text":"<p>\u83b7\u53d6\u5f53\u524d\u8d26\u53f7vip\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_vip_info (\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f </li> </ul>"},{"location":"Documents/user/#function-get_follow_singers","title":"function get_follow_singers","text":"<p>\u83b7\u53d6\u5173\u6ce8\u7684\u6b4c\u624b\u5217\u8868 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_follow_singers (\n    std::string_view euin,\n    unsigned page=1,\n    unsigned num=10,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>encrypt_uin</code> </li> <li><code>page</code> \u9875\u7801, \u9ed8\u8ba4<code>1</code> </li> <li><code>num</code> \u8fd4\u56de\u6570\u91cf, \u9ed8\u8ba4<code>10</code> </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f </li> </ul>"},{"location":"Documents/user/#function-get_follow_usr","title":"function get_follow_usr","text":"<p>\u83b7\u53d6\u5173\u6ce8\u7528\u6237\u5217\u8868 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_follow_usr (\n    std::string_view euin,\n    unsigned page=1,\n    unsigned num=10,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>encrypt_uin</code> </li> <li><code>page</code> \u9875\u7801, \u9ed8\u8ba4<code>1</code> </li> <li><code>num</code> \u8fd4\u56de\u6570\u91cf, \u9ed8\u8ba4<code>10</code> </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f </li> </ul>"},{"location":"Documents/user/#function-get_fans","title":"function get_fans","text":"<p>\u7c89\u4e1d\u6570\u91cf <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_fans (\n    std::string_view euin,\n    unsigned page=1,\n    unsigned num=10,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>encrypt_uin</code> </li> <li><code>page</code> \u9875\u7801, \u9ed8\u8ba4<code>1</code> </li> <li><code>num</code> \u8fd4\u56de\u6570\u91cf, \u9ed8\u8ba4<code>10</code> </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f </li> </ul>"},{"location":"Documents/user/#function-get_friend_list","title":"function get_friend_list","text":"<p>\u83b7\u53d6\u597d\u53cb\u5217\u8868 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_friend_list (\n    unsigned page=1,\n    unsigned num=10,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>page</code> \u9875\u7801, \u9ed8\u8ba4<code>1</code> </li> <li><code>num</code> \u8fd4\u56de\u6570\u91cf, \u9ed8\u8ba4<code>10</code> </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f </li> </ul>"},{"location":"Documents/user/#function-get_created_songlist","title":"function get_created_songlist","text":"<p>\u83b7\u53d6\u521b\u5efa\u7684\u6b4c\u5355\u5217\u8868 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_created_songlist (\n    uint64_t musicid,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>musicid</code> </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f </li> </ul>"},{"location":"Documents/user/#function-get_fav_song","title":"function get_fav_song","text":"<p>\u83b7\u53d6\u6536\u85cf\u6b4c\u66f2 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_fav_song (\n    std::string_view euin,\n    unsigned page=1,\n    unsigned num=10,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>encrypt_uin</code> </li> <li><code>page</code> \u9875\u7801, \u9ed8\u8ba4<code>1</code> </li> <li><code>num</code> \u8fd4\u56de\u6570\u91cf, \u9ed8\u8ba4<code>10</code> </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f </li> </ul>"},{"location":"Documents/user/#function-get_fav_album","title":"function get_fav_album","text":"<p>\u83b7\u53d6\u6536\u85cf\u4e13\u8f91 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_fav_album (\n    std::string_view euin,\n    unsigned page=1,\n    unsigned num=10,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>encrypt_uin</code> </li> <li><code>page</code> \u9875\u7801, \u9ed8\u8ba4<code>1</code> </li> <li><code>num</code> \u8fd4\u56de\u6570\u91cf, \u9ed8\u8ba4<code>10</code> </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f </li> </ul>"},{"location":"Documents/user/#function-get_fav_songlist","title":"function get_fav_songlist","text":"<p>\u83b7\u53d6\u6536\u85cf\u6b4c\u5355 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_fav_songlist (\n    std::string_view euin,\n    unsigned page=1,\n    unsigned num=10,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>encrypt_uin</code> </li> <li><code>page</code> \u9875\u7801, \u9ed8\u8ba4<code>1</code> </li> <li><code>num</code> \u8fd4\u56de\u6570\u91cf, \u9ed8\u8ba4<code>10</code> </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f </li> </ul>"},{"location":"Documents/user/#function-get_fav_mv","title":"function get_fav_mv","text":"<p>\u83b7\u53d6\u6536\u85cfMV <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_fav_mv (\n    std::string_view euin,\n    unsigned page=1,\n    unsigned num=10,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>encrypt_uin</code> </li> <li><code>page</code> \u9875\u7801, \u9ed8\u8ba4<code>1</code> </li> <li><code>num</code> \u8fd4\u56de\u6570\u91cf, \u9ed8\u8ba4<code>10</code> </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f </li> </ul>"},{"location":"Documents/user/#function-get_music_gene","title":"function get_music_gene","text":"<p>\u83b7\u53d6\u97f3\u4e50\u57fa\u56e0 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_music_gene (\n    std::string_view euin,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>euin</code> encrypt_uin </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f </li> </ul>"},{"location":"Documents/crypto/cipher/","title":"Cipher","text":"<p>\u89e3\u5bc6\u5bc6\u94a5</p>"},{"location":"Documents/crypto/cipher/#function-decrypt","title":"function decrypt","text":"<p>\u5bc6\u94a5\u89e3\u5bc6\u7b97\u6cd5 <pre><code>virtual void qqmusic::crypto::Cipher::decrypt (\n    qqmusic::utils::buffer &amp; buf,\n    size_t offset\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buf</code> \u5f85\u89e3\u5bc6\u7684\u5bc6\u94a5 </li> <li><code>offset</code> \u504f\u79fb\u91cf </li> </ul> <p>decrypt</p> <p>\u6709 RC4Cipher \u548c MapCipher \u4e24\u79cd\u5b9e\u73b0</p>"},{"location":"Documents/crypto/cipher/#function-decrypt_1","title":"function decrypt","text":"<p>tea\u89e3\u5bc6\uff0c\u6bcf\u6b21\u89e3\u5bc68\u5b57\u8282 <pre><code>void qqmusic::crypto::TeaCipher::decrypt (\n    qqmusic::utils::buffer &amp; buf,\n    size_t offset,\n    const std::vector&lt; uint8_t &gt; &amp; key\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buf</code> \u5f85\u89e3\u5bc6\u7684\u5bc6\u94a5 </li> <li><code>offset</code> \u504f\u79fb\u91cf </li> <li><code>key</code> \u89e3\u5bc6\u9700\u8981\u7528\u5230\u7684\u5bc6\u94a5\uff0c\u5728 key_derive.cc \u4e2d\u751f\u6210 </li> </ul> <p>\u5bc6\u94a5\u5148\u8fdb\u884c tea \u89e3\u5bc6\uff0c\u518d\u6839\u636e\u957f\u5ea6\u8fdb\u884c\u7b97\u6cd5\u8def\u7531\u9009\u62e9 rc4 \u6216\u8005 map \u89e3\u5bc6</p> <p>\u5177\u4f53\u8fc7\u7a0b\u89c1 qmc.cc \u4e2d\u7684 decrypt</p>"},{"location":"Documents/crypto/derive/","title":"Derive","text":"<p>\u5bc6\u94a5\u6d3e\u751f</p>"},{"location":"Documents/crypto/derive/#function-derive","title":"function derive","text":"<p>\u4e3b\u8981\u7684\u5bc6\u94a5\u6d3e\u751f\u51fd\u6570\uff0c\u5904\u7406\u6d3e\u751f\u903b\u8f91 \u5f53\u68c0\u6d4b\u5230V2\u524d\u7f00\u65f6\uff0c\u5148\u8fdb\u884cV2\u89e3\u5bc6\uff0c\u7136\u540e\u8fdb\u884cV1\u89e3\u5bc6 \u5982\u679c\u6ca1\u6709V2\u524d\u7f00\uff0c\u5219\u76f4\u63a5\u8fdb\u884cV1\u89e3\u5bc6 <pre><code>static qqmusic::utils::buffer qqmusic::crypto::KeyDerive::derive (\n    qqmusic::utils::buffer &amp;&amp; raw_key\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>raw_key</code> \u539f\u59cb\u5bc6\u94a5 </li> </ul> <p>Returns:</p> <p>qqmusic::utils::buffer \u89e3\u5bc6\u540e\u7684\u5bc6\u94a5 </p>"},{"location":"Documents/crypto/qmc/","title":"qmc","text":""},{"location":"Documents/crypto/qmc/#function-decoder","title":"function Decoder","text":"<p>\u89e3\u7801\u5668\u6784\u9020\u51fd\u6570 <pre><code>explicit qqmusic::crypto::Decoder::Decoder (\n    std::string &amp;&amp; ekey\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ekey</code> \u9700\u8981\u4f20\u5165\u52a0\u5bc6\u7684\u5bc6\u94a5 </li> </ul>"},{"location":"Documents/crypto/qmc/#function-decrypt","title":"function decrypt","text":"<p>\u5bc6\u94a5\u89e3\u5bc6\u7b97\u6cd5 <pre><code>virtual void qqmusic::crypto::Cipher::decrypt (\n    qqmusic::utils::buffer &amp; buf,\n    size_t offset\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buf</code> \u5f85\u89e3\u5bc6\u7684\u5bc6\u94a5 </li> <li><code>offset</code> \u504f\u79fb\u91cf </li> </ul>"},{"location":"Documents/crypto/qmc/#function-read2buf","title":"function read2buf","text":"<p>\u5b58\u53d6\u5f85\u89e3\u5bc6\u6570\u636e\u5230 buf_in \u4e2d <pre><code>bool qqmusic::crypto::Decoder::read2buf (\n    qqmusic::utils::buffer &amp;&amp; buf\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buf</code> \u7f13\u51b2\u533a\uff08\u5b58\u653e\u672a\u89e3\u5bc6\u7684\u6570\u636e\uff09 </li> </ul> <p>\u8c03\u7528\u793a\u4f8b\uff1a <pre><code>SongInfo song = ...;\nif (song.ekey.has_value()) {\n     qqmusic::crypto::Decoder decoder(*song.ekey);\n     if (read2buf(buf)) {\n         if (decoder.decrypt()) {\n             std::cout &lt;&lt; \"decrypt successful\" &lt;&lt; std::endl;\n         }\n     }\n} else {\n     // throw error\n}\n// then can use `buf_out`\n</code></pre></p>"},{"location":"Documents/details/api/","title":"Api","text":"<p>\u8d1f\u8d23Api\u8bf7\u6c42\u6784\u9020</p>"},{"location":"Documents/details/api/#struct-requestparam","title":"struct RequestParam","text":"<p>\u6253\u5305\u7684\u8bf7\u6c42\u53c2\u6570</p> <pre><code>struct RequestParam {\n    boost::url url;\n    http::request&lt;http::string_body&gt; req;\n};\n</code></pre>"},{"location":"Documents/details/api/#class-api","title":"class Api","text":"<p>Api\u7c7b, \u7528\u4e8e\u5feb\u901f\u6784\u9020\u8bf7\u6c42</p>"},{"location":"Documents/details/api/#fn-api","title":"fn Api","text":"<pre><code>Api(utils::Session&amp; session,\n    std::string module,\n    std::string method,\n    utils::Credential credential = {},\n    nlohmann::json common = {{}})\n    : session(session)\n    , module(std::move(module))\n    , method(std::move(method)){};\n</code></pre>"},{"location":"Documents/details/api/#fn-prepare_request","title":"fn prepare_request","text":"<p>\u6839\u636e\u8bf7\u6c42\u53c2\u6570\u6784\u9020\u8bf7\u6c42</p> <pre><code>qqmusic::Task&lt;qqmusic::Result&lt;RequestParam&gt;&gt; prepare_request(const nlohmann::json&amp; params);\n</code></pre> <p>Cookie</p> <p>\u7531<code>prepare_request</code>\u51fd\u6570\u6784\u9020\u7684\u8bf7\u6c42\u662f\u4e0d\u5e26Cookie\u7684, \u82e5\u9700\u8981, \u81ea\u884c\u6dfb\u52a0.</p>"},{"location":"Documents/details/api/#fn-parse_response","title":"fn parse_response","text":"<p>\u5c06\u56de\u590d\u62a5\u6587\u89e3\u6790\u6210Json\u5bf9\u8c61</p> <pre><code>qqmusic::Result&lt;nlohmann::json&gt; parse_response(utils::buffer&amp;&amp; response);\n</code></pre>"},{"location":"Documents/details/context/","title":"Context","text":"<p>\u4e0a\u4e0b\u6587\u7ba1\u7406</p>"},{"location":"Documents/details/context/#struct-apiconfig","title":"struct ApiConfig","text":"<ul> <li> <p>enable_sign: \u662f\u5426\u9700\u8981\u7b7e\u540d</p> </li> <li> <p>endpoint: \u672a\u52a0\u5bc6\u63a5\u53e3</p> </li> <li> <p>enc_endpoint: \u52a0\u5bc6\u63a5\u53e3</p> </li> </ul> <pre><code>struct ApiConfig {\n    std::string version = VERSION;\n    uint64_t version_code = VERSION_CODE;\n    bool enable_sign = false;\n    std::string endpoint = \"https://u.y.qq.com/cgi-bin/musicu.fcg\";\n    std::string enc_endpoint = \"https://u.y.qq.com/cgi-bin/musics.fcg\";\n};\n</code></pre>"},{"location":"Documents/details/context/#struct-networkcontext","title":"struct NetworkContext","text":""},{"location":"Documents/details/context/#attr-cookie","title":"attr cookie","text":"<p>Cookie</p> <pre><code>qqmusic::utils::CookieJar cookies;\n</code></pre>"},{"location":"Documents/details/context/#attr-credential","title":"attr credential","text":"<p>\u51ed\u8bc1</p> <pre><code>qqmusic::utils::Credential credential;\n</code></pre>"},{"location":"Documents/details/context/#attr-api_config","title":"attr api_config","text":"<p>\u5e38\u91cf\u548c\u516c\u7528\u53c2\u6570</p> <pre><code>ApiConfig api_config;\n</code></pre>"},{"location":"Documents/details/context/#attr-device","title":"attr device","text":"<p>\u8bbe\u5907\u4fe1\u606f</p> <pre><code>qqmusic::utils::Device device;\n</code></pre>"},{"location":"Documents/details/context/#attr-qimei","title":"attr qimei","text":"<p>\u8bbe\u5907\u8bc6\u522b\u7801</p> <pre><code>qqmusic::utils::QimeiResult qimei;\n</code></pre>"},{"location":"Documents/details/context/#attr-verify","title":"attr verify","text":"<p>\u662f\u5426\u9700\u8981\u8ba4\u8bc1</p> <pre><code>bool verify;\n</code></pre>"},{"location":"Documents/details/context/#attr-ignore_ssl_error","title":"attr ignore_ssl_error","text":"<p>\u662f\u5426\u5ffd\u7565SSL\u9519\u8bef</p> <pre><code>bool ignore_ssl_error;\n</code></pre>"},{"location":"Documents/details/context/#attr-timeout","title":"attr timeout","text":"<p>\u8d85\u65f6\u65f6\u9650</p> <pre><code>std::chrono::seconds timeout;\n</code></pre>"},{"location":"Documents/details/result/","title":"Result","text":"<p>\u8fd9\u662f\u4e00\u4e2a\u7b2c\u4e09\u65b9\u7684\u5934\u6587\u4ef6, \u8be5\u5934\u6587\u4ef6\u5f15\u7528\u81ea\u8fd9\u91cc</p>"},{"location":"Documents/utils/async-executor/","title":"AsyncExecutor","text":""},{"location":"Documents/utils/async-executor/#asyncexecutor","title":"AsyncExecutor","text":"<p>\u9ed8\u8ba4\u7684\u5f02\u6b65\u8c03\u5ea6\u5668, \u4e5f\u63d0\u4f9b\u4e86\u5c06\u5f02\u6b65\u4efb\u52a1\u8f6c\u6362\u6210\u540c\u6b65\u4efb\u52a1\u6267\u884c\u7684\u51fd\u6570</p> <p>Warning</p> <p>AsyncExecutor\u7c7b\u6ca1\u6709\u7981\u7528\u5f02\u5e38</p>"},{"location":"Documents/utils/async-executor/#function-sync_exec","title":"function sync_exec","text":"<p>\u540c\u6b65\u6267\u884c\u5f02\u6b65\u51fd\u6570 <pre><code>template&lt;typename T&gt;\nT qqmusic::utils::sync_exec (\n    boost::asio::io_context &amp; ioc,\n    qqmusic::Task&lt; T &gt; task\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ioc</code> \u5f53\u524dio_context\u5f15\u7528 </li> <li><code>task</code> \u5f02\u6b65\u4efb\u52a1</li> </ul> <p>Returns:</p> <p>\u8fd4\u56de\u6267\u884c\u7ed3\u679c</p> <p>Exception:</p> <ul> <li><code>std::runtime_error</code> </li> </ul>"},{"location":"Documents/utils/async-executor/#function-sync_exec_1","title":"function sync_exec","text":"<p>\u540c\u6b65\u6267\u884c\u5f02\u6b65\u51fd\u6570 <pre><code>template&lt;typename T&gt;\nT qqmusic::utils::sync_exec (\n    qqmusic::Task&lt; T &gt; task\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>task</code> \u5f02\u6b65\u4efb\u52a1</li> </ul> <p>Returns:</p> <p>\u8fd4\u56de\u6267\u884c\u7ed3\u679c </p>"},{"location":"Documents/utils/async-executor/#class-qqmusicutilsasyncexecutor","title":"Class qqmusic::utils::AsyncExecutor","text":"<p>ClassList &gt; qqmusic &gt; utils &gt; AsyncExecutor</p> <p>\u5168\u5c40\u8c03\u5ea6\u5668\u7c7b </p> <ul> <li><code>#include &lt;async-executor.h&gt;</code></li> </ul>"},{"location":"Documents/utils/async-executor/#public-functions","title":"Public Functions","text":"Type Name AsyncExecutor (const AsyncExecutor &amp;) = delete void async_exec (qqmusic::Task&lt; T &gt; task, CompletionCallback &amp;&amp; callback) \u5f02\u6b65\u6267\u884c\u4efb\u52a1, \u5e76\u5728\u4efb\u52a1\u7ed3\u675f\u540e\u89e6\u53d1\u56de\u8c03 void async_exec (qqmusic::Task&lt; void &gt; task, CompletionCallback &amp;&amp; callback) \u5f02\u6b65\u6267\u884c\u4efb\u52a1\u51fd\u6570\u7684void\u7279\u5316, \u5e76\u5728\u4efb\u52a1\u7ed3\u675f\u540e\u89e6\u53d1\u56de\u8c03 void async_exec (qqmusic::Task&lt; T &gt; task, CompletionCallback &amp;&amp; callback, std::chrono::steady_clock::duration timeout, TimeoutCallback &amp;&amp; timeout_callback) \u5f02\u6b65\u6267\u884c\u4efb\u52a1\u51fd\u6570, \u5e26\u6709\u8d85\u65f6\u9650\u5236, \u5e76\u5728\u4efb\u52a1\u7ed3\u675f\u540e\u89e6\u53d1\u56de\u8c03 void async_exec (qqmusic::Task&lt; void &gt; task, CompletionCallback &amp;&amp; callback, std::chrono::steady_clock::duration timeout, TimeoutCallback &amp;&amp; timeout_callback) \u5f02\u6b65\u6267\u884c\u4efb\u52a1\u51fd\u6570void\u7279\u5316, \u5e26\u6709\u8d85\u65f6\u9650\u5236. \u5e76\u5728\u4efb\u52a1\u7ed3\u675f\u540e\u89e6\u53d1\u56de\u8c03 AsyncExecutor &amp; operator= (const AsyncExecutor &amp;) = delete void shutdown ()  auto when_all (std::vector&lt; boost::asio::awaitable&lt; T &gt; &gt; tasks) \u7b49\u5f85\u4efb\u52a1\u5217\u8868\u4e2d\u6240\u6709\u7684\u4efb\u52a1\u6267\u884c\u5b8c\u6bd5\u4e4b\u540e\u8fd4\u56de\u7ed3\u679c\u5217\u8868"},{"location":"Documents/utils/async-executor/#public-static-functions","title":"Public Static Functions","text":"Type Name AsyncExecutor &amp; get_instance () \u83b7\u53d6\u5168\u5c40\u5355\u4f8b\u5f15\u7528"},{"location":"Documents/utils/async-executor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Documents/utils/async-executor/#function-asyncexecutor-12","title":"function AsyncExecutor [1/2]","text":"<pre><code>qqmusic::utils::AsyncExecutor::AsyncExecutor (\n    const AsyncExecutor &amp;\n) = delete\n</code></pre>"},{"location":"Documents/utils/async-executor/#function-async_exec-14","title":"function async_exec [1/4]","text":"<p>\u5f02\u6b65\u6267\u884c\u4efb\u52a1, \u5e76\u5728\u4efb\u52a1\u7ed3\u675f\u540e\u89e6\u53d1\u56de\u8c03 <pre><code>template&lt;typename T, BOOST_ASIO_COMPLETION_TOKEN_FOR(void(T &amp;&amp;)) CompletionCallback&gt;\ninline void qqmusic::utils::AsyncExecutor::async_exec (\n    qqmusic::Task&lt; T &gt; task,\n    CompletionCallback &amp;&amp; callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>task</code> \u5f02\u6b65\u4efb\u52a1 </li> <li><code>callback</code> \u56de\u8c03\u51fd\u6570, \u4f1a\u5c06<code>task</code>\u7684\u6267\u884c\u7ed3\u679c\u4f20\u9012\u7ed9\u56de\u8c03\u51fd\u6570 \u56de\u8c03\u51fd\u6570\u4e0d\u8fd4\u56de\u4efb\u4f55\u503c </li> </ul>"},{"location":"Documents/utils/async-executor/#function-async_exec-24","title":"function async_exec [2/4]","text":"<p>\u5f02\u6b65\u6267\u884c\u4efb\u52a1\u51fd\u6570\u7684void\u7279\u5316, \u5e76\u5728\u4efb\u52a1\u7ed3\u675f\u540e\u89e6\u53d1\u56de\u8c03 <pre><code>template&lt;BOOST_ASIO_COMPLETION_TOKEN_FOR(void()) CompletionCallback&gt;\ninline void qqmusic::utils::AsyncExecutor::async_exec (\n    qqmusic::Task&lt; void &gt; task,\n    CompletionCallback &amp;&amp; callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>task</code> \u5f02\u6b65\u4efb\u52a1 </li> <li><code>callback</code> \u56de\u8c03\u51fd\u6570, \u4f1a\u5c06<code>task</code>\u7684\u6267\u884c\u7ed3\u679c\u4f20\u9012\u7ed9\u56de\u8c03\u51fd\u6570 \u56de\u8c03\u51fd\u6570\u4e0d\u8fd4\u56de\u4efb\u4f55\u503c </li> </ul>"},{"location":"Documents/utils/async-executor/#function-async_exec-34","title":"function async_exec [3/4]","text":"<p>\u5f02\u6b65\u6267\u884c\u4efb\u52a1\u51fd\u6570, \u5e26\u6709\u8d85\u65f6\u9650\u5236, \u5e76\u5728\u4efb\u52a1\u7ed3\u675f\u540e\u89e6\u53d1\u56de\u8c03 <pre><code>template&lt;typename T, BOOST_ASIO_COMPLETION_TOKEN_FOR(void(T &amp;&amp;)) CompletionCallback, BOOST_ASIO_COMPLETION_TOKEN_FOR(void()) TimeoutCallback&gt;\ninline void qqmusic::utils::AsyncExecutor::async_exec (\n    qqmusic::Task&lt; T &gt; task,\n    CompletionCallback &amp;&amp; callback,\n    std::chrono::steady_clock::duration timeout,\n    TimeoutCallback &amp;&amp; timeout_callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>task</code> \u5f02\u6b65\u4efb\u52a1 </li> <li><code>callback</code> \u56de\u8c03\u51fd\u6570, \u4f1a\u5c06<code>task</code>\u7684\u6267\u884c\u7ed3\u679c\u4f20\u9012\u7ed9\u56de\u8c03\u51fd\u6570 \u56de\u8c03\u51fd\u6570\u4e0d\u8fd4\u56de\u4efb\u4f55\u503c </li> <li><code>timeout</code> \u8d85\u65f6\u65f6\u95f4\u9650\u5236 </li> <li><code>timeout_callback</code> \u8d85\u65f6\u4e4b\u540e\u9700\u8981\u6267\u884c\u7684\u56de\u8c03\u51fd\u6570 </li> </ul>"},{"location":"Documents/utils/async-executor/#function-async_exec-44","title":"function async_exec [4/4]","text":"<p>\u5f02\u6b65\u6267\u884c\u4efb\u52a1\u51fd\u6570void\u7279\u5316, \u5e26\u6709\u8d85\u65f6\u9650\u5236. \u5e76\u5728\u4efb\u52a1\u7ed3\u675f\u540e\u89e6\u53d1\u56de\u8c03 <pre><code>template&lt;BOOST_ASIO_COMPLETION_TOKEN_FOR(void()) CompletionCallback, BOOST_ASIO_COMPLETION_TOKEN_FOR(void()) TimeoutCallback&gt;\ninline void qqmusic::utils::AsyncExecutor::async_exec (\n    qqmusic::Task&lt; void &gt; task,\n    CompletionCallback &amp;&amp; callback,\n    std::chrono::steady_clock::duration timeout,\n    TimeoutCallback &amp;&amp; timeout_callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>task</code> \u5f02\u6b65\u4efb\u52a1 </li> <li><code>callback</code> \u56de\u8c03\u51fd\u6570, \u4f1a\u5c06<code>task</code>\u7684\u6267\u884c\u7ed3\u679c\u4f20\u9012\u7ed9\u56de\u8c03\u51fd\u6570 \u56de\u8c03\u51fd\u6570\u4e0d\u8fd4\u56de\u4efb\u4f55\u503c </li> <li><code>timeout</code> \u8d85\u65f6\u65f6\u95f4\u9650\u5236 </li> <li><code>timeout_callback</code> \u8d85\u65f6\u4e4b\u540e\u9700\u8981\u6267\u884c\u7684\u56de\u8c03\u51fd\u6570 </li> </ul>"},{"location":"Documents/utils/async-executor/#function-operator","title":"function operator=","text":"<pre><code>AsyncExecutor &amp; qqmusic::utils::AsyncExecutor::operator= (\n    const AsyncExecutor &amp;\n) = delete\n</code></pre>"},{"location":"Documents/utils/async-executor/#function-shutdown","title":"function shutdown","text":"<pre><code>void qqmusic::utils::AsyncExecutor::shutdown () \n</code></pre>"},{"location":"Documents/utils/async-executor/#function-when_all","title":"function when_all","text":"<p>\u7b49\u5f85\u4efb\u52a1\u5217\u8868\u4e2d\u6240\u6709\u7684\u4efb\u52a1\u6267\u884c\u5b8c\u6bd5\u4e4b\u540e\u8fd4\u56de\u7ed3\u679c\u5217\u8868 <pre><code>template&lt;typename T&gt;\ninline auto qqmusic::utils::AsyncExecutor::when_all (\n    std::vector&lt; boost::asio::awaitable&lt; T &gt; &gt; tasks\n) \n</code></pre></p> <pre><code>// \u4f7f\u7528\u793a\u4f8b:\nstd::vector&lt;Task&lt;nlohmann::json&gt;&gt; tasks{}; // \u7ed9\u5b9a\u4efb\u52a1\u5217\u8868\nauto&amp; executor = qqmusic::utils::AsyncExecutor::get_instance();\nauto results = executor.when_all(std::move(tasks));\nfor (auto&amp; result : results) {\n    // handle the result ...\n}\n</code></pre> <p>Parameters:</p> <ul> <li><code>tasks</code> \u5f02\u6b65\u4efb\u52a1\u5217\u8868</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u7ed3\u679c\u5217\u8868\u7684\u4efb\u52a1<code>boost::asio::awaitable&lt;std::vector&lt;T&gt;&gt;</code></p> <p>@warn \u539f\u672c\u4efb\u52a1\u7684\u987a\u5e8f\u548c\u7ed3\u679c\u987a\u5e8f\u4e0d\u4e00\u5b9a\u4e00\u81f4 </p>"},{"location":"Documents/utils/async-executor/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Documents/utils/async-executor/#function-get_instance","title":"function get_instance","text":"<p>\u83b7\u53d6\u5168\u5c40\u5355\u4f8b\u5f15\u7528 <pre><code>static AsyncExecutor &amp; qqmusic::utils::AsyncExecutor::get_instance () \n</code></pre></p> <p>Returns:</p> <p>\u5168\u5c40\u8c03\u5ea6\u5668\u5b9e\u4f8b\u5f15\u7528 </p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/async-executor.h</code></p>"},{"location":"Documents/utils/buffer/","title":"Class qqmusic::utils::buffer","text":"<p>ClassList &gt; qqmusic &gt; utils &gt; buffer</p> <p>\u4e8c\u8fdb\u5236\u7f13\u51b2\u533a\u7684\u7edf\u4e00\u8868\u793a </p> <ul> <li><code>#include &lt;buffer.h&gt;</code></li> </ul> <p>Inherits the following classes: std::vector&lt; uint8_t &gt;</p>"},{"location":"Documents/utils/buffer/#public-functions","title":"Public Functions","text":"Type Name void append (const void * src_data_buf, size_t data_buf_size) \u5c06\u4e00\u6bb5\u5185\u5b58\u63d2\u5230\u8fd9\u6bb5buffer\u540e\u9762 buffer () = default\u9ed8\u8ba4\u521d\u59cb\u5316 buffer (size_t size) \u9884\u5148\u5206\u914d\u5f02\u4e01\u9187\u957f\u5ea6 buffer (const uint8_t * src_head, size_t src_size) \u76f4\u63a5\u4ece\u5185\u5b58\u533a\u57df\u8fdb\u884c\u6784\u9020 buffer (std::vector&lt; uint8_t &gt; &amp;&amp; other) noexcept\u4ecestd::vector&lt;uint8_t&gt;\u79fb\u52a8\u6784\u9020 buffer (buffer &amp;&amp; other) noexcept\u79fb\u52a8\u6784\u9020 buffer (size_t size, char c) \u521d\u59cb\u5316\u4e3a\u7279\u5b9a\u5b57\u7b26 buffer (const buffer &amp; other) = default\u62f7\u8d1d\u6784\u9020\u51fd\u6570 buffer operator+ (const buffer &amp; a) \u4e24\u6bb5buffer\u62fc\u63a5, \u5e76\u8fd4\u56de\u6784\u9020\u65b0\u7684buffer buffer operator+= (const buffer &amp; a) \u5c06\u4e00\u6bb5buffer\u63d2\u5165\u672c\u6bb5buffer\u672b\u5c3e buffer &amp; operator= (const buffer &amp; other) = default\u62f7\u8d1d\u6784\u9020\u51fd\u6570, \u91cd\u8f7d <code>=</code> __ ~buffer () = default"},{"location":"Documents/utils/buffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Documents/utils/buffer/#function-append","title":"function append","text":"<p>\u5c06\u4e00\u6bb5\u5185\u5b58\u63d2\u5230\u8fd9\u6bb5buffer\u540e\u9762 <pre><code>inline void qqmusic::utils::buffer::append (\n    const void * src_data_buf,\n    size_t data_buf_size\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>src_data_buf</code> \u5f85\u63d2\u5165\u6570\u636e\u7684\u9996\u5730\u5740 </li> <li><code>data_buf_size</code> \u5f85\u63d2\u5165\u6570\u636e\u7684\u957f\u5ea6 </li> </ul>"},{"location":"Documents/utils/buffer/#function-buffer-17","title":"function buffer [1/7]","text":"<p>\u9ed8\u8ba4\u521d\u59cb\u5316 <pre><code>qqmusic::utils::buffer::buffer () = default\n</code></pre></p>"},{"location":"Documents/utils/buffer/#function-buffer-27","title":"function buffer [2/7]","text":"<p>\u9884\u5148\u5206\u914d\u5f02\u4e01\u9187\u957f\u5ea6 <pre><code>inline qqmusic::utils::buffer::buffer (\n    size_t size\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>size</code> \u9884\u5148\u5206\u914d\u957f\u5ea6 </li> </ul>"},{"location":"Documents/utils/buffer/#function-buffer-37","title":"function buffer [3/7]","text":"<p>\u76f4\u63a5\u4ece\u5185\u5b58\u533a\u57df\u8fdb\u884c\u6784\u9020 <pre><code>inline qqmusic::utils::buffer::buffer (\n    const uint8_t * src_head,\n    size_t src_size\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>src_head</code> \u5185\u5b58\u533a\u57df\u7684\u9996\u5730\u5740 </li> <li><code>src_size</code> \u5185\u5b58\u533a\u57df\u957f\u5ea6</li> </ul> <p>Note:</p> <p>\u662f\u62f7\u8d1d\u521d\u59cb\u5316 </p>"},{"location":"Documents/utils/buffer/#function-buffer-47","title":"function buffer [4/7]","text":"<p>\u4ecestd::vector&lt;uint8_t&gt;\u79fb\u52a8\u6784\u9020 <pre><code>inline qqmusic::utils::buffer::buffer (\n    std::vector&lt; uint8_t &gt; &amp;&amp; other\n) noexcept\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>other</code> </li> </ul>"},{"location":"Documents/utils/buffer/#function-buffer-57","title":"function buffer [5/7]","text":"<p>\u79fb\u52a8\u6784\u9020 <pre><code>inline qqmusic::utils::buffer::buffer (\n    buffer &amp;&amp; other\n) noexcept\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>other</code> </li> </ul>"},{"location":"Documents/utils/buffer/#function-buffer-67","title":"function buffer [6/7]","text":"<p>\u521d\u59cb\u5316\u4e3a\u7279\u5b9a\u5b57\u7b26 <pre><code>inline qqmusic::utils::buffer::buffer (\n    size_t size,\n    char c\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>size</code> \u9884\u5148\u521d\u59cb\u5316\u957f\u5ea6 </li> <li><code>c</code> \u9700\u8981\u586b\u5145\u7684\u5b57\u7b26 </li> </ul>"},{"location":"Documents/utils/buffer/#function-buffer-77","title":"function buffer [7/7]","text":"<p>\u62f7\u8d1d\u6784\u9020\u51fd\u6570 <pre><code>qqmusic::utils::buffer::buffer (\n    const buffer &amp; other\n) = default\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>other</code> </li> </ul>"},{"location":"Documents/utils/buffer/#function-operator","title":"function operator+","text":"<p>\u4e24\u6bb5buffer\u62fc\u63a5, \u5e76\u8fd4\u56de\u6784\u9020\u65b0\u7684buffer <pre><code>inline buffer qqmusic::utils::buffer::operator+ (\n    const buffer &amp; a\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>a</code> </li> </ul>"},{"location":"Documents/utils/buffer/#function-operator_1","title":"function operator+=","text":"<p>\u5c06\u4e00\u6bb5buffer\u63d2\u5165\u672c\u6bb5buffer\u672b\u5c3e <pre><code>inline buffer qqmusic::utils::buffer::operator+= (\n    const buffer &amp; a\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>a</code> </li> </ul>"},{"location":"Documents/utils/buffer/#function-operator_2","title":"function operator=","text":"<p>\u62f7\u8d1d\u6784\u9020\u51fd\u6570, \u91cd\u8f7d <code>=</code> __ <pre><code>buffer &amp; qqmusic::utils::buffer::operator= (\n    const buffer &amp; other\n) = default\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>other</code> </li> </ul>"},{"location":"Documents/utils/buffer/#function-buffer","title":"function ~buffer","text":"<pre><code>qqmusic::utils::buffer::~buffer () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/buffer.h</code></p>"},{"location":"Documents/utils/common/","title":"Common","text":"<p>\u4e00\u7ec4\u5de5\u5177\u51fd\u6570</p>"},{"location":"Documents/utils/common/#function-resp2buf","title":"function resp2buf","text":"<p>\u5c06\u8bf7\u6c42\u56de\u590d\u62a5\u6587\u4f53\u8f6c\u6362\u6210\u4e8c\u8fdb\u5236buffer <pre><code>buffer qqmusic::utils::resp2buf (\n    http::response&lt; http::dynamic_body &gt; &amp;&amp; resp\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>resp</code> \u56de\u590d\u62a5\u6587</li> </ul> <p>Returns:</p> <p>qqmusic::utils::buffer\u7c7b\u578bbuffer </p>"},{"location":"Documents/utils/common/#function-sign","title":"function sign","text":"<p>QQ\u97f3\u4e50\u8bf7\u6c42\u7b7e\u540d <pre><code>std::string qqmusic::utils::sign (\n    const nlohmann::json &amp; params\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>params</code> \u8bf7\u6c42\u6570\u636e\u8868\u5355</li> </ul> <p>Returns:</p> <p>\u7b7e\u540d\u7ed3\u679c </p>"},{"location":"Documents/utils/common/#function-hex2buf","title":"function hex2buf","text":"<p>\u5341\u516d\u8fdb\u5236\u5b57\u7b26\u4e32\u8f6c\u6210buffer <pre><code>buffer qqmusic::utils::hex2buf (\n    std::string_view hex\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>hex</code> \u5341\u516d\u8fdb\u5236\u7f16\u7801\u5b57\u7b26\u4e32</li> </ul> <p>Returns:</p> <p>qqmusic::utils::buffer\u7c7b\u578bbuffer </p>"},{"location":"Documents/utils/common/#enum-qrc_type","title":"enum qrc_type","text":"<ul> <li> <p><code>cloud</code></p> </li> <li> <p><code>local</code></p> </li> </ul>"},{"location":"Documents/utils/common/#function-qrc_decode","title":"function qrc_decode","text":"<p>\u89e3\u7801\u52a0\u5bc6\u7684QRC\u6b4c\u8bcd <pre><code>qqmusic::Result&lt; std::string &gt; qqmusic::utils::qrc_decode (\n    const qqmusic::utils::buffer &amp; src,\n    qqmusic::utils::qrc_type type\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>src</code> \u88ab\u52a0\u5bc6\u7684\u6b4c\u8bcd </li> <li><code>type</code> \u6b4c\u8bcd\u7c7b\u578b</li> </ul> <p>Returns:</p> <p>\u89e3\u7801\u540e\u7684\u5b57\u7b26\u4e32, \u5982\u679c\u51fa\u9519\u4f1a\u8fd4\u56de<code>Exception</code> </p> <p>Note</p> <p><code>cloud</code>\u548c<code>local</code>\u7684\u533a\u522b: <code>cloud</code>\u76f4\u63a5\u5904\u7406, \u800c<code>local</code>\u9700\u8981\u8fdb\u884cqmc1_decryt\u4e4b\u540e \u53bb\u6389\u524d11\u5b57\u8282\u518d\u5904\u7406</p>"},{"location":"Documents/utils/common/#function-hash33","title":"function hash33","text":"<p>\u8ba1\u7b97utf-8\u5b57\u7b26\u4e32\u7684\u54c8\u5e0c\u503c <pre><code>uint64_t qqmusic::utils::hash33 (\n    std::string_view str,\n    uint64_t prev=0\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>str</code> \u5f85\u6c42\u503c\u5b57\u7b26\u4e32 </li> <li><code>prev</code> \u591a\u6b21\u6c42\u503c\u65f6\u4f20\u5165\u4e0a\u6b21\u6c42\u51fa\u7684\u7ed3\u679c, \u9ed8\u8ba4\u4e3a<code>0</code></li> </ul> <p>Returns:</p> <p>64\u4f4d\u6574\u6570\u683c\u5f0f\u7684\u54c8\u5e0c </p>"},{"location":"Documents/utils/common/#function-get_search_id","title":"function get_search_id","text":"<p>\u8fd4\u56de\u968f\u673a\u641c\u7d22ID <pre><code>std::string qqmusic::utils::get_search_id () \n</code></pre></p>"},{"location":"Documents/utils/cookie/","title":"Cookie","text":""},{"location":"Documents/utils/cookie/#function-parse_cookie","title":"function parse_cookie","text":"<p>\u5c06Cookie\u5b57\u7b26\u4e32\u89e3\u6790\u6210Json\u5bf9\u8c61 <pre><code>qqmusic::Result&lt; nlohmann::json &gt; qqmusic::utils::parse_cookie (\n    std::string_view cookie_str\n) \n</code></pre></p> <pre><code>key1=value1; key2=value2; key3=value3; key4=value4\n     |\n     v\n{\n    \"key1\": \"value1\",\n    \"key2\": \"value2\",\n    \"key3\": \"value3\",\n    \"key4\": \"value4\",\n}\n</code></pre>"},{"location":"Documents/utils/cookie/#struct-cookie","title":"Struct Cookie","text":"<pre><code>/**\n * @brief \u4ee3\u8868\u4e00\u6761Cookie\n * */\nstruct Cookie {\n    /**\n     * @brief \u57df\u540d\n     * */\n    std::string domain;\n\n    /**\n     * @brief \u8def\u5f84\n     * */\n    std::string path = \"/\"; /*for each site use '/' as default path*/\n\n    /**\n     * @brief \u952e\n     * */\n    std::string key;\n\n    /**\n     * @brief \u503c\n     * */\n    std::string value;\n};\n</code></pre>"},{"location":"Documents/utils/cookie/#class-qqmusicutilscookiejar","title":"Class qqmusic::utils::CookieJar","text":"<p>ClassList &gt; qqmusic &gt; utils &gt; CookieJar</p> <p>\u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027More...</p> <ul> <li><code>#include &lt;cookie.h&gt;</code></li> </ul>"},{"location":"Documents/utils/cookie/#public-functions","title":"Public Functions","text":"Type Name CookieJar () \u7a7a\u521d\u59cb\u5316 CookieJar (std::string_view cache) \u7f13\u5b58\u53cd\u5e8f\u5217\u5316, \u4ece <code>dump</code> \u51fd\u6570\u4ea7\u751f\u7684\u7f13\u5b58\u6784\u9020 CookieJar (std::string_view cookie_str, std::string_view domain, std::string_view path=\"/\") \u4ece\u539f\u59cbcookie\u5b57\u7b26\u4e32\u89e3\u6790 qqmusic::Result&lt; void &gt; clear (std::optional&lt; std::string &gt; domain=std::nullopt, std::optional&lt; std::string &gt; path=std::nullopt, std::optional&lt; std::string &gt; key=std::nullopt) \u5220\u9664\u5bf9\u5e94\u533a\u57df\u7684cookie qqmusic::Result&lt; void &gt; del (std::string_view key, std::optional&lt; std::string &gt; domain=std::nullopt, std::optional&lt; std::string &gt; path=std::nullopt) \u5220\u9664\u5bf9\u5e94\u952e\u7684Cookie\u5b57\u6bb5\u548c\u4ed6\u7684\u503c qqmusic::Result&lt; std::string &gt; dump () \u5e8f\u5217\u5316Cookie qqmusic::Result&lt; std::string &gt; get (std::string_view key, std::optional&lt; std::string &gt; domain=std::nullopt, std::optional&lt; std::string &gt; path=std::nullopt) \u67e5\u8be2\u5bf9\u5e94\u952e\u7684Cookie\u5b57\u6bb5\u7684\u503c qqmusic::Result&lt; void &gt; merge (const CookieJar &amp; cookies) \u5408\u5e76CookieJar\u5185\u5bb9 qqmusic::Result&lt; std::string &gt; serialize (std::string_view domain, std::string_view path=\"/\") \u5c06\u5bf9\u5e94\u57df\u540d\u548c\u8def\u5f84\u7684Cookie\u5e8f\u5217\u5316\u6210\u8bf7\u6c42\u62a5\u6587 qqmusic::Result&lt; void &gt; set (const Cookie &amp; cookie) \u63d2\u5165\u4e00\u6761Cookie qqmusic::Result&lt; void &gt; update (const CookieJar &amp; cookies) \u66ff\u6362CookieJar\u7684\u5185\u5bb9"},{"location":"Documents/utils/cookie/#detailed-description","title":"Detailed Description","text":"<p>\u4f7f\u7528Json\u6570\u636e\u7ed3\u6784\u6765\u50a8\u5b58Cookie  <pre><code>{\n    \"domain1\" : {\n        \"path1\": {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\"\n        },\n        \"path2\": {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\"\n        }\n    },\n    \"domain2\" : {\n        \"path1\": {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\"\n        },\n        \"path2\": {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\"\n        }\n    }\n}\n</code></pre></p> <p>Warning:</p> <p>\u4e0d\u652f\u6301path\u7684\u5d4c\u5957, <code>example.com/menu</code> \u548c <code>example.com/menu/usr</code> \u88ab\u8ba4\u4e3a\u662f\u57df\u540d<code>example.com</code>\u4e0b\u4e24\u4e2a\u5b8c\u5168\u4e0d\u540c\u7684\u8def\u5f84.</p> <p>\u4e0d\u652f\u6301\u89e3\u6790<code>HttpOnly</code>, <code>Expires</code>\u8fd9\u6837\u7684\u5b57\u6bb5, \u4e0d\u662f\u952e\u503c\u5bf9\u5f62\u5f0f\u7684 Cookie\u6761\u76ee\u4f1a\u88ab\u4e22\u5f03.</p> <p>\u5f85\u529e\u4e8b\u9879</p> <p>\u9700\u8981\u652f\u6301\u5d4c\u5957\u7684\u8def\u5f84, \u652f\u6301\u975e\u952e\u503c\u5bf9\u5f62\u5f0f\u7684Cookie </p>"},{"location":"Documents/utils/cookie/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Documents/utils/cookie/#function-cookiejar-13","title":"function CookieJar [1/3]","text":"<p>\u7a7a\u521d\u59cb\u5316 <pre><code>inline qqmusic::utils::CookieJar::CookieJar () \n</code></pre></p>"},{"location":"Documents/utils/cookie/#function-cookiejar-23","title":"function CookieJar [2/3]","text":"<p>\u7f13\u5b58\u53cd\u5e8f\u5217\u5316, \u4ece <code>dump</code> \u51fd\u6570\u4ea7\u751f\u7684\u7f13\u5b58\u6784\u9020 <pre><code>inline qqmusic::utils::CookieJar::CookieJar (\n    std::string_view cache\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cache</code> \u7f13\u5b58 </li> </ul>"},{"location":"Documents/utils/cookie/#function-cookiejar-33","title":"function CookieJar [3/3]","text":"<p>\u4ece\u539f\u59cbcookie\u5b57\u7b26\u4e32\u89e3\u6790 <pre><code>qqmusic::utils::CookieJar::CookieJar (\n    std::string_view cookie_str,\n    std::string_view domain,\n    std::string_view path=\"/\"\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cookie_str</code> \u8bf7\u6c42\u62a5\u6587\u4e2dcookie\u5b57\u7b26\u4e32, \u4e00\u822c\u5b58\u5728\u4e8e<code>Set-Cookie</code>\u5b57\u6bb5 </li> <li><code>domain</code> \u57df\u540d </li> <li><code>path</code> \u8def\u5f84, \u9ed8\u8ba4\u662f<code>/</code> </li> </ul>"},{"location":"Documents/utils/cookie/#function-clear","title":"function clear","text":"<p>\u5220\u9664\u5bf9\u5e94\u533a\u57df\u7684cookie <pre><code>qqmusic::Result&lt; void &gt; qqmusic::utils::CookieJar::clear (\n    std::optional&lt; std::string &gt; domain=std::nullopt,\n    std::optional&lt; std::string &gt; path=std::nullopt,\n    std::optional&lt; std::string &gt; key=std::nullopt\n) \n</code></pre></p>"},{"location":"Documents/utils/cookie/#function-del","title":"function del","text":"<p>\u5220\u9664\u5bf9\u5e94\u952e\u7684Cookie\u5b57\u6bb5\u548c\u4ed6\u7684\u503c <pre><code>qqmusic::Result&lt; void &gt; qqmusic::utils::CookieJar::del (\n    std::string_view key,\n    std::optional&lt; std::string &gt; domain=std::nullopt,\n    std::optional&lt; std::string &gt; path=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>key</code> \u952e </li> <li><code>domain</code> \u57df\u540d, \u9ed8\u8ba4<code>std::nullopt</code>, \u82e5\u4e0d\u7ed9\u51fa\u5219\u5168\u5c40\u5bfb\u627e </li> <li><code>path</code> \u8def\u5f84, \u9ed8\u8ba4<code>std::nullopt</code>, \u82e5\u4e0d\u7ed9\u51fa\u5219\u5728\u57df\u540d\u4e0b\u5bfb\u627e</li> </ul> <p>Returns:</p> <p><code>Result &lt;void&gt;</code>, \u5982\u679c\u6ca1\u6709\u5bf9\u5e94\u7684\u952e, \u4f1a\u8fd4\u56de<code>JsonError</code></p> <p>Note:</p> <p>\u7f3a\u7701\u53c2\u6570\u65f6\u603b\u662f\u5220\u9664\u7b2c\u4e00\u4e2a\u627e\u5230\u7b26\u5408\u7684\u952e\u503c\u5bf9 </p>"},{"location":"Documents/utils/cookie/#function-dump","title":"function dump","text":"<p>\u5e8f\u5217\u5316Cookie <pre><code>qqmusic::Result&lt; std::string &gt; qqmusic::utils::CookieJar::dump () \n</code></pre></p> <p>Returns:</p> <p>\u5df2\u7ecf\u5e8f\u5217\u5316\u7684json\u5b57\u7b26\u4e32, \u5982\u679c\u51fa\u9519\u4f1a\u8fd4\u56de<code>JsonError</code> </p>"},{"location":"Documents/utils/cookie/#function-get","title":"function get","text":"<p>\u67e5\u8be2\u5bf9\u5e94\u952e\u7684Cookie\u5b57\u6bb5\u7684\u503c <pre><code>qqmusic::Result&lt; std::string &gt; qqmusic::utils::CookieJar::get (\n    std::string_view key,\n    std::optional&lt; std::string &gt; domain=std::nullopt,\n    std::optional&lt; std::string &gt; path=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>key</code> \u952e </li> <li><code>domain</code> \u57df\u540d, \u9ed8\u8ba4<code>std::nullopt</code>, \u82e5\u4e0d\u7ed9\u51fa\u5219\u5168\u5c40\u5bfb\u627e </li> <li><code>path</code> \u8def\u5f84, \u9ed8\u8ba4<code>std::nullopt</code>, \u82e5\u4e0d\u7ed9\u51fa\u5219\u5728\u57df\u540d\u4e0b\u5bfb\u627e</li> </ul> <p>Returns:</p> <p><code>Result &lt;std::string&gt;</code>, \u952e\u503c\u5bf9\u7684\u503c\u662f\u5b57\u7b26\u4e32\u5f62\u5f0f\u7684 \u627e\u4e0d\u5230\u4f1a\u8fd4\u56de<code>JsonError</code></p> <p>Note:</p> <p>\u53c2\u6570\u7f3a\u7701\u65f6\u603b\u662f\u8fd4\u56de\u7b2c\u4e00\u4e2a\u627e\u5230\u7684\u952e\u503c\u5bf9\u7684\u503c </p>"},{"location":"Documents/utils/cookie/#function-merge","title":"function merge","text":"<p>\u5408\u5e76CookieJar\u5185\u5bb9 <pre><code>qqmusic::Result&lt; void &gt; qqmusic::utils::CookieJar::merge (\n    const CookieJar &amp; cookies\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cookies</code> \u5f85\u5408\u5e76cookie</li> </ul> <p>Note:</p> <p>\u539f\u672cCookie\u4e0d\u5b58\u5728\u7684\u5b57\u6bb5\u88ab\u521b\u5efa, \u91cd\u5408\u7684\u5b57\u6bb5\u88ab\u65b0\u503c\u8986\u76d6 </p>"},{"location":"Documents/utils/cookie/#function-serialize","title":"function serialize","text":"<p>\u5c06\u5bf9\u5e94\u57df\u540d\u548c\u8def\u5f84\u7684Cookie\u5e8f\u5217\u5316\u6210\u8bf7\u6c42\u62a5\u6587 <pre><code>qqmusic::Result&lt; std::string &gt; qqmusic::utils::CookieJar::serialize (\n    std::string_view domain,\n    std::string_view path=\"/\"\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>domain</code> \u57df\u540d </li> <li><code>path</code> \u8def\u5f84, \u9ed8\u8ba4<code>/</code> </li> </ul>"},{"location":"Documents/utils/cookie/#function-set","title":"function set","text":"<p>\u63d2\u5165\u4e00\u6761Cookie <pre><code>qqmusic::Result&lt; void &gt; qqmusic::utils::CookieJar::set (\n    const Cookie &amp; cookie\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cookie</code> \u4e00\u4e2aCookie\u6761\u76ee</li> </ul> <p>Note:</p> <p>\u5982\u679c\u5bf9\u5e94\u57df\u540d\u548c\u8def\u5f84\u7684\u8fd9\u4e2aCookie\u7684\u952e\u5df2\u7ecf\u5b58\u5728, \u90a3\u4e48\u4f1a\u8986\u76d6\u8001\u7684\u503c </p>"},{"location":"Documents/utils/cookie/#function-update","title":"function update","text":"<p>\u66ff\u6362CookieJar\u7684\u5185\u5bb9 <pre><code>qqmusic::Result&lt; void &gt; qqmusic::utils::CookieJar::update (\n    const CookieJar &amp; cookies\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cookies</code> \u65b0\u7684Cookies </li> </ul> <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/cookie.h</code></p>"},{"location":"Documents/utils/credential/","title":"Class qqmusic::utils::Credential","text":"<p>ClassList &gt; qqmusic &gt; utils &gt; Credential</p> <p>\u51ed\u636e\u4fe1\u606f\u7c7b </p> <ul> <li><code>#include &lt;credential.h&gt;</code></li> </ul>"},{"location":"Documents/utils/credential/#public-attributes","title":"Public Attributes","text":"Type Name std::string access_token AccessToken std::string encryptUin \u52a0\u5bc6\u7684euin, euin\u548c\u8d26\u53f7ID\u4e00\u4e00\u5bf9\u5e94 uint64_t expired_at   = <code>0</code>\u5230\u671f\u65f6\u95f4, \u79d2\u7ea7\u65f6\u95f4\u6233 nlohmann::json extra_fields \u6ca1\u6709\u6536\u5f55\u5728\u4e0a\u9762\u7684\u5b57\u6bb5 int loginType   = <code>2</code>\u767b\u5f55\u6a21\u5f0f <code>1</code> : \u5fae\u4fe1\u767b\u9646<code>2</code> : QQ\u767b\u9646 uint64_t musicid   = <code>0</code>\u8d26\u53f7MusicID, \u4e00\u822c\u662fQQ\u53f7 std::string musickey \u8d26\u53f7MusicKey std::string openid OpenID std::string refresh_key RefreshKey std::string refresh_token RefreshToken std::string str_musicid std::string\u683c\u5f0f\u7684\u8d26\u53f7MusicID, \u4e00\u822c\u662fQQ\u53f7 std::string unionid UnionID"},{"location":"Documents/utils/credential/#public-functions","title":"Public Functions","text":"Type Name Credential () = default\u9ed8\u8ba4\u7a7a\u521d\u59cb\u5316 Credential (std::string_view cookie) \u4ecelogin api\u83b7\u53d6\u7684\u8fd4\u56de\u7ed3\u679c\u6784\u9020Credential Credential (nlohmann::json &amp; cookie) \u4ecelogin api\u8fd4\u56de\u7684\u7ed3\u679c\u6784\u9020Credential NLOHMANN_DEFINE_TYPE_INTRUSIVE (Credential, openid, refresh_token, access_token, expired_at, musicid, unionid, str_musicid, musickey, refresh_key, encryptUin, loginType)  bool from_cache (std::string_view cache) \u4ece\u5e8f\u5217\u5316\u51fa\u7684cache\u751f\u6210Credential bool from_cache (nlohmann::json &amp; cache) \u4ece\u5e8f\u5217\u5316\u51fa\u7684cache\u751f\u6210Credential qqmusic::Task&lt; qqmusic::Result&lt; bool &gt; &gt; is_expired () \u5224\u65adCredential\u662f\u5426\u8fc7\u671f bool is_valid () const\u5224\u65adCredential\u662f\u5426\u5408\u6cd5, \u5373\u6709\u6ca1\u6709 <code>musicid</code> \u548c<code>musickey</code> \u5b57\u6bb5 qqmusic::Task&lt; qqmusic::Result&lt; void &gt; &gt; refresh () \u5237\u65b0Credential qqmusic::Result&lt; nlohmann::json &gt; to_json () \u5c06Credential\u5e8f\u5217\u5316\u4e3aJson\u5bf9\u8c61 qqmusic::Result&lt; std::string &gt; to_string () \u5c06Credential\u5e8f\u5217\u5316\u4e3aJson\u5b57\u7b26\u4e32"},{"location":"Documents/utils/credential/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Documents/utils/credential/#variable-access_token","title":"variable access_token","text":"<p>AccessToken <pre><code>std::string qqmusic::utils::Credential::access_token;\n</code></pre></p>"},{"location":"Documents/utils/credential/#variable-encryptuin","title":"variable encryptUin","text":"<p>\u52a0\u5bc6\u7684euin, euin\u548c\u8d26\u53f7ID\u4e00\u4e00\u5bf9\u5e94 <pre><code>std::string qqmusic::utils::Credential::encryptUin;\n</code></pre></p>"},{"location":"Documents/utils/credential/#variable-expired_at","title":"variable expired_at","text":"<p>\u5230\u671f\u65f6\u95f4, \u79d2\u7ea7\u65f6\u95f4\u6233 <pre><code>uint64_t qqmusic::utils::Credential::expired_at;\n</code></pre></p>"},{"location":"Documents/utils/credential/#variable-extra_fields","title":"variable extra_fields","text":"<p>\u6ca1\u6709\u6536\u5f55\u5728\u4e0a\u9762\u7684\u5b57\u6bb5 <pre><code>nlohmann::json qqmusic::utils::Credential::extra_fields;\n</code></pre></p>"},{"location":"Documents/utils/credential/#variable-logintype","title":"variable loginType","text":"<p>\u767b\u5f55\u6a21\u5f0f <code>1</code> : \u5fae\u4fe1\u767b\u9646<code>2</code> : QQ\u767b\u9646 <pre><code>int qqmusic::utils::Credential::loginType;\n</code></pre></p>"},{"location":"Documents/utils/credential/#variable-musicid","title":"variable musicid","text":"<p>\u8d26\u53f7MusicID, \u4e00\u822c\u662fQQ\u53f7 <pre><code>uint64_t qqmusic::utils::Credential::musicid;\n</code></pre></p> <p>Note:</p> <p>\u5e38\u7528\u5b57\u6bb5 </p>"},{"location":"Documents/utils/credential/#variable-musickey","title":"variable musickey","text":"<p>\u8d26\u53f7MusicKey <pre><code>std::string qqmusic::utils::Credential::musickey;\n</code></pre></p> <p>Note:</p> <p>\u5e38\u7528 </p>"},{"location":"Documents/utils/credential/#variable-openid","title":"variable openid","text":"<p>OpenID <pre><code>std::string qqmusic::utils::Credential::openid;\n</code></pre></p>"},{"location":"Documents/utils/credential/#variable-refresh_key","title":"variable refresh_key","text":"<p>RefreshKey <pre><code>std::string qqmusic::utils::Credential::refresh_key;\n</code></pre></p>"},{"location":"Documents/utils/credential/#variable-refresh_token","title":"variable refresh_token","text":"<p>RefreshToken <pre><code>std::string qqmusic::utils::Credential::refresh_token;\n</code></pre></p>"},{"location":"Documents/utils/credential/#variable-str_musicid","title":"variable str_musicid","text":"<p>std::string\u683c\u5f0f\u7684\u8d26\u53f7MusicID, \u4e00\u822c\u662fQQ\u53f7 <pre><code>std::string qqmusic::utils::Credential::str_musicid;\n</code></pre></p> <p>Note:</p> <p>\u5e38\u7528\u5b57\u6bb5 </p>"},{"location":"Documents/utils/credential/#variable-unionid","title":"variable unionid","text":"<p>UnionID <pre><code>std::string qqmusic::utils::Credential::unionid;\n</code></pre></p>"},{"location":"Documents/utils/credential/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Documents/utils/credential/#function-credential-13","title":"function Credential [1/3]","text":"<p>\u9ed8\u8ba4\u7a7a\u521d\u59cb\u5316 <pre><code>qqmusic::utils::Credential::Credential () = default\n</code></pre></p>"},{"location":"Documents/utils/credential/#function-credential-23","title":"function Credential [2/3]","text":"<p>\u4ecelogin api\u83b7\u53d6\u7684\u8fd4\u56de\u7ed3\u679c\u6784\u9020Credential <pre><code>explicit qqmusic::utils::Credential::Credential (\n    std::string_view cookie\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cookie</code> Json\u5b57\u7b26\u4e32 </li> </ul>"},{"location":"Documents/utils/credential/#function-credential-33","title":"function Credential [3/3]","text":"<p>\u4ecelogin api\u8fd4\u56de\u7684\u7ed3\u679c\u6784\u9020Credential <pre><code>explicit qqmusic::utils::Credential::Credential (\n    nlohmann::json &amp; cookie\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cookie</code> Json\u5bf9\u8c61 </li> </ul>"},{"location":"Documents/utils/credential/#function-nlohmann_define_type_intrusive","title":"function NLOHMANN_DEFINE_TYPE_INTRUSIVE","text":"<pre><code>qqmusic::utils::Credential::NLOHMANN_DEFINE_TYPE_INTRUSIVE (\n    Credential,\n    openid,\n    refresh_token,\n    access_token,\n    expired_at,\n    musicid,\n    unionid,\n    str_musicid,\n    musickey,\n    refresh_key,\n    encryptUin,\n    loginType\n) \n</code></pre>"},{"location":"Documents/utils/credential/#function-from_cache-12","title":"function from_cache [1/2]","text":"<p>\u4ece\u5e8f\u5217\u5316\u51fa\u7684cache\u751f\u6210Credential <pre><code>bool qqmusic::utils::Credential::from_cache (\n    std::string_view cache\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cache</code> \u7531<code>Credential::to_string()</code>\u548c<code>Credential::to_json()</code> \u751f\u6210\u7684\u5e8f\u5217\u5316\u7ed3\u679c\u5bfc\u5165Credential</li> </ul> <p>Returns:</p> <p><code>true</code>, \u5982\u679c\u5904\u7406\u8fc7\u7a0b\u51fa\u73b0\u95ee\u9898 <code>false</code>, \u5982\u679c\u6b63\u5e38\u5904\u7406\u5b8c\u6bd5 </p>"},{"location":"Documents/utils/credential/#function-from_cache-22","title":"function from_cache [2/2]","text":"<p>\u4ece\u5e8f\u5217\u5316\u51fa\u7684cache\u751f\u6210Credential <pre><code>bool qqmusic::utils::Credential::from_cache (\n    nlohmann::json &amp; cache\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cache</code> \u7531<code>Credential::to_string()</code>\u548c<code>Credential::to_json()</code> \u751f\u6210\u7684\u5e8f\u5217\u5316\u7ed3\u679c\u5bfc\u5165Credential</li> </ul> <p>Returns:</p> <p><code>true</code>, \u5982\u679c\u5904\u7406\u8fc7\u7a0b\u51fa\u73b0\u95ee\u9898 <code>false</code>, \u5982\u679c\u6b63\u5e38\u5904\u7406\u5b8c\u6bd5 </p>"},{"location":"Documents/utils/credential/#function-is_expired","title":"function is_expired","text":"<p>\u5224\u65adCredential\u662f\u5426\u8fc7\u671f <pre><code>qqmusic::Task&lt; qqmusic::Result&lt; bool &gt; &gt; qqmusic::utils::Credential::is_expired () \n</code></pre></p> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;bool&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e \u8fd4\u56de<code>true</code>\u8bf4\u660e\u672a\u8fc7\u671f, <code>false</code>\u8bf4\u660e\u8fc7\u671f, \u9700\u8981\u5237\u65b0</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/utils/credential/#function-is_valid","title":"function is_valid","text":"<p>\u5224\u65adCredential\u662f\u5426\u5408\u6cd5, \u5373\u6709\u6ca1\u6709 <code>musicid</code> \u548c<code>musickey</code> \u5b57\u6bb5 <pre><code>bool qqmusic::utils::Credential::is_valid () const\n</code></pre></p> <p>Returns:</p> <p><code>true</code>, \u5408\u6cd5 <code>false</code>, \u4e0d\u5408\u6cd5 </p>"},{"location":"Documents/utils/credential/#function-refresh","title":"function refresh","text":"<p>\u5237\u65b0Credential <pre><code>qqmusic::Task&lt; qqmusic::Result&lt; void &gt; &gt; qqmusic::utils::Credential::refresh () \n</code></pre></p> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;void&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"Documents/utils/credential/#function-to_json","title":"function to_json","text":"<p>\u5c06Credential\u5e8f\u5217\u5316\u4e3aJson\u5bf9\u8c61 <pre><code>qqmusic::Result&lt; nlohmann::json &gt; qqmusic::utils::Credential::to_json () \n</code></pre></p> <p>Returns:</p> <p>\u5305\u542b\u7ed3\u679c\u6216\u9519\u8bef\u7684<code>Result &lt;nlohmann::json&gt;</code> </p>"},{"location":"Documents/utils/credential/#function-to_string","title":"function to_string","text":"<p>\u5c06Credential\u5e8f\u5217\u5316\u4e3aJson\u5b57\u7b26\u4e32 <pre><code>qqmusic::Result&lt; std::string &gt; qqmusic::utils::Credential::to_string () \n</code></pre></p> <p>Returns:</p> <p>\u5305\u542b\u7ed3\u679c\u6216\u9519\u8bef\u7684<code>Result &lt;std::string&gt;</code> </p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/credential.h</code></p>"},{"location":"Documents/utils/device/","title":"Device","text":"<p>\u8bbe\u5907\u4fe1\u606f</p>"},{"location":"Documents/utils/device/#struct-osversion","title":"struct OSVersion","text":"<p>\u64cd\u4f5c\u7cfb\u7edf\u4fe1\u606f</p> <pre><code>struct OSVersion {\n    OSVersion();\n\n    std::string incremental;\n    std::string release;\n    std::string codename;\n    int sdk;\n\n    NLOHMANN_DEFINE_TYPE_INTRUSIVE(OSVersion, incremental, release, codename, sdk);\n};\n</code></pre>"},{"location":"Documents/utils/device/#struct-device","title":"struct Device","text":"<p>\u8bbe\u5907\u4fe1\u606f</p> <pre><code>struct Device {\n    Device();\n\n    std::string display;\n    std::string product;\n    std::string device;\n    std::string board;\n    std::string model;\n    std::string fingerprint;\n    std::string boot_id;\n    std::string proc_version;\n    std::string imei;\n    std::string brand;\n    std::string bootloader;\n    std::string base_band;\n    struct OSVersion version;\n    std::string sim_info;\n    std::string os_type;\n    std::string mac_address;\n    std::vector&lt;int&gt; ip_address;\n    std::string wifi_bssid;\n    std::string wifi_ssid;\n    std::vector&lt;int&gt; imsi_md5;\n    std::string android_id;\n    std::string apn;\n    std::string vendor_name;\n    std::string vendor_os_name;\n    std::string qimei;\n\n    NLOHMANN_DEFINE_TYPE_INTRUSIVE(Device,\n                                   display,\n                                   product,\n                                   device,\n                                   board,\n                                   model,\n                                   fingerprint,\n                                   boot_id,\n                                   proc_version,\n                                   imei,\n                                   brand,\n                                   bootloader,\n                                   base_band,\n                                   version,\n                                   sim_info,\n                                   os_type,\n                                   mac_address,\n                                   wifi_bssid,\n                                   wifi_ssid,\n                                   imsi_md5,\n                                   android_id,\n                                   apn,\n                                   vendor_name,\n                                   vendor_os_name,\n                                   qimei);\n};\n</code></pre>"},{"location":"Documents/utils/device/#fn-get_device_info","title":"fn get_device_info","text":"<p>\u83b7\u53d6\u8bbe\u5907\u4fe1\u606f, \u4f18\u5148\u4ece\u7f13\u5b58\u4e2d\u8bfb\u53d6, \u5982\u679c\u6ca1\u6709\u7f13\u5b58\u5c31\u751f\u6210\u968f\u673a\u8bbe\u5907\u4fe1\u606f\u5e76\u7f13\u5b58</p> <pre><code>qqmusic::Result&lt;Device&gt; get_device_info();\n</code></pre>"},{"location":"Documents/utils/device/#fn-cache_device","title":"fn cache_device","text":"<p>\u7f13\u5b58\u8bbe\u5907\u4fe1\u606f</p> <pre><code>qqmusic::Result&lt;void&gt; cache_device(const Device&amp; device);\n</code></pre>"},{"location":"Documents/utils/exception/","title":"Exception","text":"<p>\u6536\u96c6Api\u53ef\u80fd\u4ea7\u751f\u7684\u5f02\u5e38</p>"},{"location":"Documents/utils/exception/#class-exception","title":"class Exception","text":""},{"location":"Documents/utils/exception/#enum-kind","title":"enum Kind","text":"<ul> <li> <p>ResponseCodeError  </p> <p>\u56de\u590d\u7684\u72b6\u6001\u7801\u5f02\u5e38</p> </li> <li> <p>CredendialExpiredError</p> <p>\u51ed\u8bc1\u8fc7\u671f</p> </li> <li> <p>CredentialInvalidError</p> <p>\u51ed\u8bc1\u4e0d\u5408\u6cd5</p> </li> <li> <p>LoginError</p> <p>\u767b\u9646\u9519\u8bef</p> </li> <li> <p>SignInvalidError</p> <p>\u8bf7\u6c42\u7b7e\u540d\u9519\u8bef</p> </li> <li> <p>DataDestroy</p> <p>\u52a0\u5bc6, \u89e3\u7801, \u5e8f\u5217\u5316, \u53cd\u5e8f\u5217\u5316\u8fc7\u7a0b\u4e2d\u6570\u636e\u635f\u6bc1, \u6216\u5f97\u5230\u672a\u9884\u671f\u7684\u6570\u636e</p> </li> <li> <p>RuntimeError</p> <p>\u8fd0\u884c\u65f6\u5f02\u5e38(\u5305\u62ec\u62e6\u622a\u7b2c\u4e09\u65b9\u5e93\u7684\u4e00\u822c\u5f02\u5e38)</p> </li> <li> <p>NetworkError</p> <p>\u4e00\u822c\u7f51\u7edc\u5f02\u5e38</p> </li> <li> <p>JsonError</p> <p>Json\u7684\u751f\u6210\u548c\u89e3\u6790\u65f6\u51fa\u73b0\u9519\u8bef</p> </li> <li> <p>OperationOutOfTime</p> <p>\u64cd\u4f5c\u8d85\u65f6</p> </li> <li> <p>SslError</p> <p>SSL/TLS\u64cd\u4f5c\u5f02\u5e38</p> </li> <li> <p>UnknownError</p> <p>\u672a\u77e5\u9519\u8bef</p> </li> </ul>"},{"location":"Documents/utils/exception/#fn-exception","title":"fn Exception","text":"<ul> <li>\u4ece\u679a\u4e3e\u6784\u9020</li> </ul> <pre><code>Exception(Kind kind)\n    : kind_code(kind)\n    , reason(ReasonKindMap[kind]) {}\n</code></pre> <ul> <li>\u4ece\u679a\u4e3e\u6784\u9020, \u5e76\u9644\u4e0a\u539f\u56e0</li> </ul> <pre><code>Exception(Kind kind, std::string_view reason)\n    : kind_code(kind)\n    , reason(reason) {}\n</code></pre> <ul> <li>\u4ecehttp\u8fd4\u56de\u7684\u72b6\u6001\u7801\u6784\u9020</li> </ul> <pre><code>Exception(unsigned int http_rc)\n    : kind_code(ResponseCodeError) {\n    if (HttpResponseCodeMap.contains(http_rc)) {\n        reason = HttpResponseCodeMap[http_rc];\n    } else {\n        reason = ReasonKindMap[Kind::ResponseCodeError];\n    }\n}\n</code></pre>"},{"location":"Documents/utils/exception/#fn-get_error_enum","title":"fn get_error_enum","text":"<p>\u83b7\u53d6\u679a\u4e3e\u503c</p> <pre><code>[[nodiscard]] unsigned int get_error_enum() const { return kind_code; }\n</code></pre>"},{"location":"Documents/utils/exception/#fn-kind","title":"fn kind","text":"<p>\u83b7\u53d6\u5b57\u7b26\u4e32\u5f62\u5f0f\u7684\u9519\u8bef\u7c7b\u578b</p> <pre><code>[[nodiscard]] std::string kind() const { return ReasonKindMap[kind_code]; }\n</code></pre>"},{"location":"Documents/utils/exception/#fn-what","title":"fn what","text":"<p>\u83b7\u53d6\u9519\u8bef\u539f\u56e0</p> <pre><code>[[nodiscard]] std::string what() const { return reason; }\n</code></pre>"},{"location":"Documents/utils/paths/","title":"Paths","text":"<p>\u5168\u5c40\u5355\u4f8b, \u7ba1\u7406Api\u5e93\u7684\u4e0b\u8f7d, \u65e5\u5fd7\u548c\u7f13\u5b58\u5e93</p>"},{"location":"Documents/utils/paths/#class-pathmanager","title":"class PathManager","text":"<p>\u5404\u4e2a\u5e73\u53f0\u4e0b\u7684\u9ed8\u8ba4\u8def\u5f84:</p> <ul> <li> <p>Linux:</p> <ul> <li> <p>cache: <code>$XDG_CACHE_HOME/qqmusic-api-cxx/cache</code>           OR <code>$HOME/.cache/qqmusic-api-cxx/cache</code></p> </li> <li> <p>log: <code>$XDG_CACHE_HOME/qqmusic-api-cxx/log</code>         OR <code>$HOME/.cache/qqmusic-api-cxx/log</code></p> </li> <li> <p>download: <code>$HOME/Download/qqmusic-api-cxx</code></p> </li> </ul> </li> <li> <p>Windows:</p> <ul> <li> <p>cache: <code>%LOCALAPPDATA%\\cache</code>           OR <code>%USERPROFILE%\\cahce</code></p> </li> <li> <p>log: <code>%LOCALAPPDATA%\\log</code>         OR <code>%USERPROFILE%\\log</code></p> </li> <li> <p>download: <code>%USERPROFILE%\\Download\\qqmusic-api-cxx</code></p> </li> </ul> </li> <li> <p>MacOS:</p> <ul> <li> <p>cache: <code>$HOME/Library/Caches/qqmusic-api-cxx/cache</code></p> </li> <li> <p>log: <code>$HOME/Library/Caches/qqmusic-api-cxx/log</code></p> </li> <li> <p>download: <code>$HOME/Downloads/qqmusic-api-cxx</code></p> </li> </ul> </li> </ul>"},{"location":"Documents/utils/paths/#fn-get_instance","title":"fn get_instance","text":"<p>\u83b7\u5f97PathManager\u5168\u5c40\u5355\u4f8b\u7684\u5f15\u7528</p> <pre><code>static PathManager&amp; get_instance();\n</code></pre>"},{"location":"Documents/utils/paths/#fn-set_download_path","title":"fn set_download_path","text":"<p>\u4fee\u6539\u9ed8\u8ba4\u4e0b\u8f7d\u8def\u5f84</p> <pre><code>void set_download_path(std::string_view path);\n</code></pre>"},{"location":"Documents/utils/paths/#fn-set_cache_path","title":"fn set_cache_path","text":"<p>\u4fee\u6539\u9ed8\u8ba4\u7f13\u5b58\u8def\u5f84</p> <pre><code>void set_cache_path(std::string_view path);\n</code></pre>"},{"location":"Documents/utils/paths/#fn-set_log_path","title":"fn set_log_path","text":"<p>\u4fee\u6539\u9ed8\u8ba4\u65e5\u5fd7\u8def\u5f84</p> <pre><code>void set_log_path(std::string_view path);\n</code></pre>"},{"location":"Documents/utils/paths/#fn-get_cache_path","title":"fn  get_cache_path","text":"<p>\u83b7\u53d6\u9ed8\u8ba4\u7f13\u5b58\u8def\u5f84</p> <pre><code>[[nodiscard]] fs::path get_cache_path() const;\n</code></pre>"},{"location":"Documents/utils/paths/#fn-get_download_path","title":"fn get_download_path","text":"<p>\u83b7\u53d6\u9ed8\u8ba4\u4e0b\u8f7d\u8def\u5f84</p> <pre><code>[[nodiscard]] fs::path get_download_path() const;\n</code></pre>"},{"location":"Documents/utils/paths/#fn-get_log_path","title":"fn get_log_path","text":"<p>\u83b7\u53d6\u9ed8\u8ba4\u65e5\u5fd7\u8def\u5f84</p> <pre><code>[[nodiscard]] fs::path get_log_path() const;\n</code></pre>"},{"location":"Documents/utils/qimei/","title":"Qimei","text":"<p>Q-IMEI\u662f\u7528\u4e8eQQ\u97f3\u4e50\u548cTX\u5176\u4ed6\u670d\u52a1\u4e2d\u7528\u4e8e\u6807\u8bc6\u8bbe\u5907\u7684\u552f\u4e00\u8bc6\u522b\u7801.</p>"},{"location":"Documents/utils/qimei/#struct-qimeiresult","title":"struct QimeiResult","text":"<p>\u5305\u542b16\u4f4d\u8bc6\u522b\u7801\u548c36\u4f4d\u8bc6\u522b\u7801</p> <pre><code>struct QimeiResult {\n    std::string q16;\n    std::string q36;\n\n    NLOHMANN_DEFINE_TYPE_INTRUSIVE(QimeiResult, q16, q36);\n};\n</code></pre>"},{"location":"Documents/utils/qimei/#fn-get_qimei","title":"fn get_qimei","text":"<p>\u4ece\u8bbe\u5907\u4fe1\u606f\u548c\u7248\u672c\u4fe1\u606f\u83b7\u53d6Q-IMEI</p> <pre><code>qqmusic::Result&lt;QimeiResult&gt; get_qimei(qqmusic::utils::Device&amp; device,\n                                       std::string_view version);\n</code></pre>"},{"location":"Documents/utils/session/","title":"Session","text":"<p>\u7f51\u7edc\u8bf7\u6c42\u548c\u4e0a\u4e0b\u6587\u76f8\u5173\u7684Api</p>"},{"location":"Documents/utils/session/#class-session","title":"class Session","text":"<p>Session\u7c7b\u8d1f\u8d23\u7ba1\u7406\u4e00\u90e8\u5206\u4e0a\u4e0b\u6587, \u5e76\u8d1f\u8d23\u5904\u7406\u8bf7\u6c42</p>"},{"location":"Documents/utils/session/#fn-session","title":"fn Session","text":"<ul> <li> <p>nc: \u4e0a\u4e0b\u6587\u4fe1\u606f</p> </li> <li> <p>ioc_ptr: io_context, \u7528\u4e8e\u5904\u7406HTTP\u8bf7\u6c42</p> </li> <li> <p>ssl_ctx_ptr: SSL\u4e0a\u4e0b\u6587, \u7528\u4e8e\u5904\u7406HTTPS\u8bf7\u6c42</p> </li> </ul> <pre><code>Session(qqmusic::details::NetworkContext&amp; nc,\n        std::shared_ptr&lt;asio::io_context&gt; ioc_ptr,\n        std::shared_ptr&lt;asio::ssl::context&gt; ssl_ctx_ptr,\n        std::mutex&amp; lock)\n    : global_ctx(nc)\n    , local_ctx(nc)\n    , ioc(std::move(ioc_ptr))\n    , ssl_ctx(std::move(ssl_ctx_ptr))\n    , lock(lock){};\n</code></pre>"},{"location":"Documents/utils/session/#fn-get_context_ref","title":"fn get_context_ref","text":"<p>\u83b7\u53d6\u672c\u5b9e\u4f8b\u7684\u4e0a\u4e0b\u6587\u5f15\u7528</p> <pre><code>qqmusic::details::NetworkContext&amp; get_context_ref();\n</code></pre>"},{"location":"Documents/utils/session/#fn-sync_global","title":"fn sync_global","text":"<p>\u7ebf\u7a0b\u5b89\u5168\u7684\u5c06\u672c\u5730\u7684context\u66f4\u6539\u540c\u6b65\u5230\u5168\u5c40</p> <pre><code>void sync_global();\n</code></pre>"},{"location":"Documents/utils/session/#fn-update_local","title":"fn update_local","text":"<p>\u7ebf\u7a0b\u5b89\u5168\u7684\u4f7f\u7528\u5168\u5c40\u4e0a\u4e0b\u6587\u66f4\u65b0\u672c\u5730\u62f7\u8d1d</p> <pre><code>void update_local();\n</code></pre>"},{"location":"Documents/utils/session/#fn-perform_request","title":"fn perform_request","text":"<p>\u53d1\u9001\u8bf7\u6c42, \u83b7\u5f97\u54cd\u5e94</p> <ul> <li> <p>url: \u8bf7\u6c42\u7684url</p> </li> <li> <p>req: \u8bf7\u6c42\u7c7b</p> </li> <li> <p>auto_redirecting: \u662f\u5426\u81ea\u52a8\u5904\u7406\u91cd\u5b9a\u5411(\u9ed8\u8ba4\u4e3atrue)</p> </li> </ul> <pre><code>qqmusic::Task&lt;qqmusic::Result&lt;HttpResponse&gt;&gt; \nperform_request(boost::url_view url,\n                http::request&lt;http::string_body&gt;&amp; req,\n                bool auto_redirecting = true);\n</code></pre>"},{"location":"Documents/utils/session/#class-sessionmanager","title":"class SessionManager","text":"<p>SessionManager\u662f\u5168\u5c40\u5355\u4f8b, \u6240\u6709\u7684Session\u5e94\u8be5\u4f7f\u7528SessionManager\u751f\u6210, \u5176\u7ef4\u62a4\u4e86\u4e00\u4e2a\u4e0a\u4e0b\u6587\u6808, \u4fbf\u4e8e\u5207\u6362\u4e0a\u4e0b\u6587.</p>"},{"location":"Documents/utils/session/#fn-get_instance","title":"fn get_instance","text":"<p>\u83b7\u53d6SessionManager\u5168\u5c40\u5355\u4f8b\u5f15\u7528</p> <pre><code>static SessionManager&amp; get_instance();\n</code></pre>"},{"location":"Documents/utils/session/#fn-get_session","title":"fn get_session()","text":"<p>\u83b7\u53d6\u4e00\u4e2aSession\u5b9e\u4f8b</p> <pre><code>Session get_session();\n</code></pre>"},{"location":"Documents/utils/session/#fn-set_context","title":"fn set_context","text":"<p>\u8bbe\u7f6e\u4e0a\u4e0b\u6587\u6808\u6808\u9876\u7684\u4e0a\u4e0b\u6587</p> <pre><code>void set_context(const qqmusic::details::NetworkContext&amp; context);\n</code></pre>"},{"location":"Documents/utils/session/#fn-push_context","title":"fn push_context","text":"<p>\u5411\u4e0a\u4e0b\u6587\u6808\u4e2d\u538b\u5165\u4e0a\u4e0b\u6587</p> <pre><code>void push_context(qqmusic::details::NetworkContext&amp;&amp; context);\n</code></pre>"},{"location":"Documents/utils/session/#fn-pop_context","title":"fn pop_context","text":"<p>\u4ece\u4e0a\u4e0b\u6587\u6808\u4e2d\u5f39\u51fa\u6808\u9876\u7684\u4e0a\u4e0b\u6587</p> <pre><code>void pop_context();\n</code></pre>"},{"location":"Documents/utils/session/#class-sessionguard","title":"class SessionGuard","text":"<p>RAII\u98ce\u683c\u7684\u4e0a\u4e0b\u6587\u5207\u6362\u5668</p>"},{"location":"Documents/utils/session/#fn-sessionguard","title":"fn SessionGuard","text":"<ul> <li>\u4eceSession\u6784\u9020</li> </ul> <pre><code>SessionGuard(SessionManager&amp; sm, Session s)\n    : session_manager(sm) {\n    session_manager.push_context(std::move(s.local_ctx));\n};\n</code></pre> <ul> <li>\u4eceNetworkContext\u6784\u9020</li> </ul> <pre><code>SessionGuard(SessionManager&amp; sm, details::NetworkContext ctx)\n    : session_manager(sm) {\n    session_manager.push_context(std::move(ctx));\n};\n</code></pre> <p>Usage</p> <pre><code>int main(int argc, char** argv) {\n    auto sm = qqmusic::utils::SessionManager::get_instance().get_session();\n    auto session = sm.get_session();\n    boost::url url{\"https://example.com\"};\n    auto req = boost::beast::request&lt;boost::beast::string_body&gt;{boost::beast::http::verb,\n                                                                url,\n                                                                11};\n    // \u51c6\u5907\u8bf7\u6c42...\n\n    // \u8fd9\u91cc\u4f7f\u7528\u7684\u662f\u9ed8\u8ba4\u7684\u4e0a\u4e0b\u6587(\u672a\u52a0\u5bc6\u63a5\u53e3)\n    auto resp = qqmusic::utils::sync_exec(session.perform_request(url, req));\n\n    {\n        NetworkContext ctx{};\n        ctx.verify = true;\n        // \u8fd9\u91cc\u662f\u72ec\u7acb\u7684\u4f5c\u7528\u57df, \u53ef\u4ee5\u4f7f\u7528SessionGuard\u5728\u5f53\u524d\u4f5c\u7528\u57df\u4e2d\u4f7f\u7528\u8fd9\u4e2a\u4f7f\u7528\u52a0\u5bc6\u63a5\u53e3\u7684\u4e0a\u4e0b\u6587\n        qqmusic::utils::SessionGuard sg(sm, ctx);\n        // \u8fd9\u91cc\u7684\u8bf7\u6c42\u4f7f\u7528\u7684\u662f\u65b0\u7684\u4e0a\u4e0b\u6587(\u52a0\u5bc6\u63a5\u53e3)\n        auto resp1 = qqmusic::utils::sync_exec(session.perform_request(url, req));\n        //\u79bb\u5f00\u4f5c\u7528\u57df, \u91ca\u653eSessionGuard, \u6062\u590d\u539f\u6765\u7684\u4e0a\u4e0b\u6587\n    }\n\n    // \u8fd9\u91cc\u4f7f\u7528\u7684\u8fd8\u662f\u9ed8\u8ba4\u7684\u4e0a\u4e0b\u6587(\u672a\u52a0\u5bc6\u63a5\u53e3)\n    auto resp2 = qqmusic::utils::sync_exec(session.perform_request(url, req));\n    return 0;\n}\n</code></pre>"},{"location":"QuickStart/","title":"Quick Start","text":""},{"location":"dictionary/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>struct PhoneLoginEvent \u624b\u673a\u53f7\u767b\u9646\u4e8b\u4ef6\u5305\u88c5\u5668 </li> <li>struct Result </li> <li>namespace concepts <ul> <li>struct EqualityComparable </li> <li>struct EqualityComparable&lt; T, typename std::enable_if&lt; true, typename details::void_t&lt; decltype(std::declval&lt; T &gt;()==std::declval&lt; T &gt;())&gt;::type &gt;::type &gt; </li> </ul> </li> <li>namespace details <ul> <li>namespace And <ul> <li>struct Then </li> <li>struct Then&lt; Ret(*)(Args...)&gt; </li> <li>struct Then&lt; Ret(Cls::*)(Args...) const &gt; </li> <li>struct Then&lt; Ret(Cls::*)(Args...)&gt; </li> <li>namespace impl <ul> <li>struct Then </li> <li>struct Then&lt; Ret(*)(Args...)&gt; </li> <li>struct Then&lt; Ret(Arg)&gt; </li> <li>struct Then&lt; Ret(Cls::*)(Args...) const &gt; </li> <li>struct Then&lt; Ret(Cls::*)(Args...)&gt; </li> <li>struct Then&lt; Ret(void)&gt; </li> </ul> </li> </ul> </li> <li>struct Constructor </li> <li>struct Constructor&lt; void, E &gt; </li> <li>struct IsResult </li> <li>struct IsResult&lt; Result&lt; T, E &gt; &gt; </li> <li>namespace Or <ul> <li>struct Else </li> <li>struct Else&lt; Ret(*)(Args...)&gt; </li> <li>struct Else&lt; Ret(Cls::*)(Args...) const &gt; </li> <li>struct Else&lt; Ret(Cls::*)(Args...)&gt; </li> <li>namespace impl <ul> <li>struct Else </li> <li>struct Else&lt; Result&lt; T, F &gt;(Arg)&gt; </li> <li>struct Else&lt; Result&lt; T, F &gt;(void)&gt; </li> <li>struct Else&lt; Ret(*)(Args...)&gt; </li> <li>struct Else&lt; Ret(Cls::*)(Args...) const &gt; </li> <li>struct Else&lt; Ret(Cls::*)(Args...)&gt; </li> </ul> </li> </ul> </li> <li>namespace Other <ul> <li>struct Wise </li> <li>struct Wise&lt; Ret(*)(Args...)&gt; </li> <li>struct Wise&lt; Ret(Cls::*)(Args...) const &gt; </li> <li>struct Wise&lt; Ret(Cls::*)(Args...)&gt; </li> <li>namespace impl <ul> <li>struct Wise </li> <li>struct Wise&lt; Ret(*)(Args...)&gt; </li> <li>struct Wise&lt; Ret(Arg)&gt; </li> <li>struct Wise&lt; Ret(Cls::*)(Args...) const &gt; </li> <li>struct Wise&lt; Ret(Cls::*)(Args...)&gt; </li> </ul> </li> </ul> </li> <li>struct ResultErrType </li> <li>struct ResultErrType&lt; Result&lt; T, E &gt; &gt; </li> <li>struct ResultOkType </li> <li>struct ResultOkType&lt; Result&lt; T, E &gt; &gt; </li> <li>struct Storage </li> <li>struct Storage&lt; void, E &gt; </li> <li>namespace err <ul> <li>struct Map </li> <li>namespace impl <ul> <li>struct Map </li> <li>struct Map&lt; Ret(Cls::*)(Arg) const &gt; </li> </ul> </li> </ul> </li> <li>struct err_tag </li> <li>namespace impl <ul> <li>struct result_of </li> <li>struct result_of&lt; Ret(Args...)&gt; </li> <li>struct result_of&lt; Ret(Cls::*)(Args...)&gt; </li> </ul> </li> <li>namespace ok <ul> <li>struct Map </li> <li>struct Map&lt; Ret(*)(Args...)&gt; </li> <li>struct Map&lt; Ret(Cls::*)(Args...) const &gt; </li> <li>struct Map&lt; Ret(Cls::*)(Args...)&gt; </li> <li>struct Map&lt; std::function&lt; Ret(Args...)&gt; &gt; </li> <li>namespace impl <ul> <li>struct Map </li> <li>struct Map&lt; Result&lt; U, E &gt;(Arg)&gt; </li> <li>struct Map&lt; Result&lt; U, E &gt;(void)&gt; </li> <li>struct Map&lt; Ret(Arg)&gt; </li> <li>struct Map&lt; Ret(Cls::*)(Arg) const &gt; </li> <li>struct Map&lt; Ret(Cls::*)(Arg)&gt; </li> <li>struct Map&lt; Ret(void)&gt; </li> <li>struct Map&lt; void(Arg)&gt; </li> <li>struct Map&lt; void(void)&gt; </li> </ul> </li> </ul> </li> <li>struct ok_tag </li> <li>struct result_of </li> <li>struct result_of&lt; Ret(*)(Args...)&gt; </li> <li>struct result_of&lt; Ret(Cls::*)(Args...) const &gt; </li> <li>struct void_t </li> </ul> </li> <li>namespace qqmusic <ul> <li>class BaseMediaFileType \u5a92\u4f53\u6587\u4ef6\u7c7b\u578b\u57fa\u7c7b </li> <li>class EncryptedSongFileType \u52a0\u5bc6\u6b4c\u66f2\u6587\u4ef6\u7c7b\u578b </li> <li>struct Lyric \u6b4c\u8bcd </li> <li>struct MvUrl Mv url\u5c01\u88dd </li> <li>struct PhoneLoginResult </li> <li>struct QRCode \u4e8c\u7ef4\u7801\u4fe1\u606f </li> <li>class QRCodeLoginEvent \u4e8c\u7ef4\u7801\u767b\u9646\u4e8b\u4ef6 </li> <li>struct QRCodeLoginResult \u4e8c\u7ef4\u7801\u767b\u9646\u7ed3\u679c\u5c01\u88c5 </li> <li>class SongFileType \u672a\u52a0\u5bc6\u7684\u6b4c\u66f2\u6587\u4ef6\u7c7b\u679a\u4e3e </li> <li>struct SongInfo </li> <li>class TabType \u6807\u7b7e\u7c7b </li> <li>namespace crypto <ul> <li>class Cipher </li> <li>class Decoder </li> <li>class KeyDerive </li> <li>class MapCipher </li> <li>class RC4Cipher </li> <li>namespace TeaCipher </li> </ul> </li> <li>namespace details <ul> <li>class Api Api\u7c7b, \u7b80\u5316\u8bf7\u6c42\u62a5\u6587\u7ec4\u88c5\u548c\u8fd4\u56de\u62a5\u6587\u89e3\u6790\u8fc7\u7a0b </li> <li>struct ApiConfig Api\u76f8\u5173\u5e38\u91cf </li> <li>struct NetworkContext \u6253\u5305\u7684\u4e0a\u4e0b\u6587 </li> <li>struct RequestParam \u5305\u88c5\u8bf7\u6c42\u6240\u9700\u7684\u53c2\u6570 </li> </ul> </li> <li>namespace utils \u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027 <ul> <li>class AsyncExecutor \u5168\u5c40\u8c03\u5ea6\u5668\u7c7b </li> <li>struct Cookie \u4ee3\u8868\u4e00\u6761Cookie </li> <li>class CookieJar \u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027 </li> <li>class Credential \u51ed\u636e\u4fe1\u606f\u7c7b </li> <li>struct Device \u8bbe\u5907\u4fe1\u606f </li> <li>class Exception \u5168\u5c40\u5f02\u5e38\u7c7b </li> <li>struct OSVersion </li> <li>class PathManager \u8fd4\u56de\u9ed8\u8ba4\u8def\u5f84 </li> <li>struct QimeiResult </li> <li>class Session \u4e0a\u4e0b\u6587 </li> <li>class SessionGuard \u4e00\u4e2a <code>RAII</code> \u98ce\u683c\u7684Session\u5207\u6362\u5668 </li> <li>class SessionManager \u5168\u5c40\u5355\u4f8b\u7684Session\u7ba1\u7406\u5668, \u8d1f\u8d23\u7ef4\u62a4\u5168\u5c40\u4e0a\u4e0b\u6587\u6808, \u5e76\u8d1f\u8d23 <code>session</code> \u5b9e\u4f8b\u7684\u751f\u6210 </li> <li>class buffer \u4e8c\u8fdb\u5236\u7f13\u51b2\u533a\u7684\u7edf\u4e00\u8868\u793a </li> </ul> </li> </ul> </li> <li>struct CoreData </li> <li>struct CoreData </li> <li>struct Tab \u6807\u7b7e\u4fe1\u606f\u7ed3\u6784 </li> <li>namespace std </li> <li>namespace types <ul> <li>struct Err </li> <li>struct Ok </li> <li>struct Ok&lt; void &gt; </li> </ul> </li> </ul>"},{"location":"dictionary/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir include <ul> <li>dir qqmusic <ul> <li>file album.h \u4e13\u8f91\u76f8\u5173Api </li> <li>dir crypto <ul> <li>file cipher.h cipher \u7684\u57fa\u7c7b </li> <li>file cipher_map.h cipher_map </li> <li>file cipher_rc4.h cipher_rc4 </li> <li>file cipher_tea.h TEA\u7b97\u6cd5\u89e3\u5bc6\u5b9e\u73b0 </li> <li>file key_derive.h QQ\u97f3\u4e50\u5bc6\u94a5\u89e3\u5bc6\u7b97\u6cd5\u5b9e\u73b0 </li> <li>file qmc.h QQ\u97f3\u4e50\u52a0\u5bc6\u6587\u4ef6\u89e3\u7801\u5668\u6838\u5fc3\u6a21\u5757 </li> </ul> </li> <li>dir details <ul> <li>file api.h Api\u7c7b, \u7b80\u5316\u8bf7\u6c42\u548c\u8fd4\u56de\u62a5\u6587\u89e3\u6790\u8fc7\u7a0b </li> <li>file context.h Api\u4e0a\u4e0b\u6587\u5b9a\u4e49 </li> <li>file result.h </li> <li>file tripledes.h </li> </ul> </li> <li>file login.h \u767b\u9646\u76f8\u5173Api, \u5305\u542b\u4e09\u79cd\u767b\u9646\u65b9\u5f0f QQ\u626b\u7801, \u5fae\u4fe1\u626b\u7801, \u624b\u673a\u53f7\u767b\u9646 </li> <li>file lyric.h </li> <li>file mv.h \u5173\u4e8eMV\u7684Api </li> <li>file result.h \u63d0\u4f9b\u8fd4\u56de\u503c\u7c7b\u578b\u7684\u5c01\u88c5 </li> <li>file search.h \u641c\u7d22\u76f8\u5173Api </li> <li>file singer.h \u6b4c\u624b\u76f8\u5173API </li> <li>file song.h \u6b4c\u66f2\u76f8\u5173API </li> <li>file songlist.h </li> <li>file toplist.h </li> <li>file user.h \u7528\u6237\u76f8\u5173Api </li> <li>dir utils <ul> <li>file async-executor.h \u63d0\u4f9b\u4e86\u4e00\u4e2a\u9ed8\u8ba4\u7684\u7b80\u5355\u534f\u7a0b\u8c03\u5ea6\u5668, \u4ee5\u53ca\u540c\u6b65\u6267\u884c\u5f02\u6b65\u51fd\u6570\u7684\u65b9\u6cd5. </li> <li>file buffer.h \u4e8c\u8fdb\u5236\u7f13\u51b2\u533a\u7c7b </li> <li>file common.h </li> <li>file cookie.h </li> <li>file credential.h </li> <li>file device.h </li> <li>file exception.h </li> <li>file paths.h </li> <li>file qimei.h </li> <li>file session.h </li> </ul> </li> </ul> </li> </ul> </li> <li>dir src <ul> <li>file album.cc </li> <li>dir crypto <ul> <li>file cipher_map.cc </li> <li>file cipher_rc4.cc </li> <li>file cipher_tea.cc </li> <li>file key_derive.cc </li> <li>file qmc.cc </li> </ul> </li> <li>dir details <ul> <li>file api.cc </li> <li>file tripledes.cc </li> </ul> </li> <li>file login.cc </li> <li>file lyric.cc </li> <li>file mv.cc </li> <li>file search.cc </li> <li>file singer.cc </li> <li>file song.cc </li> <li>file songlist.cc </li> <li>file toplist.cc </li> <li>file user.cc </li> <li>dir utils <ul> <li>file async-executor.cc </li> <li>file common.cc </li> <li>file cookie.cc </li> <li>file credential.cc </li> <li>file device.cc </li> <li>file paths.cc </li> <li>file qimei.cc </li> <li>file session.cc </li> </ul> </li> </ul> </li> </ul>"},{"location":"dictionary/structPhoneLoginEvent/","title":"Struct PhoneLoginEvent","text":"<p>ClassList &gt; PhoneLoginEvent</p> <p>\u624b\u673a\u53f7\u767b\u9646\u4e8b\u4ef6\u5305\u88c5\u5668 </p> <ul> <li><code>#include &lt;login.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>include/qqmusic/login.h</code></p>"},{"location":"dictionary/structResult/","title":"Struct Result","text":"<p>template &lt;typename T, typename E&gt;</p> <p>ClassList &gt; Result</p>"},{"location":"dictionary/structResult/#public-types","title":"Public Types","text":"Type Name typedef details::Storage&lt; T, E &gt; storage_type"},{"location":"dictionary/structResult/#public-functions","title":"Public Functions","text":"Type Name Result (types::Ok&lt; T &gt; ok)  Result (types::Err&lt; E &gt; err)  Result (Result &amp;&amp; other)  Result (const Result &amp; other)  T expect (const char * str) const bool isErr () const bool isOk () const Ret map (Func func) const Ret mapError (Func func) const Ret orElse (Func func) const Result&lt; T, E &gt; otherwise (Func func) const storage_type &amp; storage ()  const storage_type &amp; storage () const Result&lt; T, E &gt; then (Func func) const std::enable_if&lt;!std::is_same&lt; U, void &gt;::value, U &gt;::type unwrap () const E unwrapErr () const std::enable_if&lt;!std::is_same&lt; U, void &gt;::value, U &gt;::type unwrapOr (const U &amp; defaultValue) const ~Result ()"},{"location":"dictionary/structResult/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"dictionary/structResult/#typedef-storage_type","title":"typedef storage_type","text":"<pre><code>typedef details::Storage&lt;T, E&gt; Result&lt; T, E &gt;::storage_type;\n</code></pre>"},{"location":"dictionary/structResult/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/structResult/#function-result-14","title":"function Result [1/4]","text":"<pre><code>inline Result::Result (\n    types::Ok &lt; T &gt; ok\n) \n</code></pre>"},{"location":"dictionary/structResult/#function-result-24","title":"function Result [2/4]","text":"<pre><code>inline Result::Result (\n    types::Err &lt; E &gt; err\n) \n</code></pre>"},{"location":"dictionary/structResult/#function-result-34","title":"function Result [3/4]","text":"<pre><code>inline Result::Result (\n    Result &amp;&amp; other\n) \n</code></pre>"},{"location":"dictionary/structResult/#function-result-44","title":"function Result [4/4]","text":"<pre><code>inline Result::Result (\n    const Result &amp; other\n) \n</code></pre>"},{"location":"dictionary/structResult/#function-expect","title":"function expect","text":"<pre><code>inline T Result::expect (\n    const char * str\n) const\n</code></pre>"},{"location":"dictionary/structResult/#function-iserr","title":"function isErr","text":"<pre><code>inline bool Result::isErr () const\n</code></pre>"},{"location":"dictionary/structResult/#function-isok","title":"function isOk","text":"<pre><code>inline bool Result::isOk () const\n</code></pre>"},{"location":"dictionary/structResult/#function-map","title":"function map","text":"<pre><code>template&lt;typename Func, typename Ret&gt;\ninline Ret Result::map (\n    Func func\n) const\n</code></pre>"},{"location":"dictionary/structResult/#function-maperror","title":"function mapError","text":"<pre><code>template&lt;typename Func, typename Ret&gt;\ninline Ret Result::mapError (\n    Func func\n) const\n</code></pre>"},{"location":"dictionary/structResult/#function-orelse","title":"function orElse","text":"<pre><code>template&lt;typename Func, typename Ret&gt;\ninline Ret Result::orElse (\n    Func func\n) const\n</code></pre>"},{"location":"dictionary/structResult/#function-otherwise","title":"function otherwise","text":"<pre><code>template&lt;typename Func&gt;\ninline Result &lt; T, E &gt; Result::otherwise (\n    Func func\n) const\n</code></pre>"},{"location":"dictionary/structResult/#function-storage-12","title":"function storage [1/2]","text":"<pre><code>inline storage_type &amp; Result::storage () \n</code></pre>"},{"location":"dictionary/structResult/#function-storage-22","title":"function storage [2/2]","text":"<pre><code>inline const storage_type &amp; Result::storage () const\n</code></pre>"},{"location":"dictionary/structResult/#function-then","title":"function then","text":"<pre><code>template&lt;typename Func&gt;\ninline Result &lt; T, E &gt; Result::then (\n    Func func\n) const\n</code></pre>"},{"location":"dictionary/structResult/#function-unwrap","title":"function unwrap","text":"<pre><code>template&lt;typename U&gt;\ninline std::enable_if&lt;!std::is_same&lt; U, void &gt;::value, U &gt;::type Result::unwrap () const\n</code></pre>"},{"location":"dictionary/structResult/#function-unwraperr","title":"function unwrapErr","text":"<pre><code>inline E Result::unwrapErr () const\n</code></pre>"},{"location":"dictionary/structResult/#function-unwrapor","title":"function unwrapOr","text":"<pre><code>template&lt;typename U&gt;\ninline std::enable_if&lt;!std::is_same&lt; U, void &gt;::value, U &gt;::type Result::unwrapOr (\n    const U &amp; defaultValue\n) const\n</code></pre>"},{"location":"dictionary/structResult/#function-result","title":"function ~Result","text":"<pre><code>inline Result::~Result () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/namespaceconcepts/","title":"Namespace concepts","text":"<p>Namespace List &gt; concepts</p>"},{"location":"dictionary/namespaceconcepts/#classes","title":"Classes","text":"Type Name struct EqualityComparable &lt;typename T, typename&gt; struct EqualityComparable&lt; T, typename std::enable_if&lt; true, typename details::void_t&lt; decltype(std::declval&lt; T &gt;()==std::declval&lt; T &gt;())&gt;::type &gt;::type &gt; &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structconcepts_1_1EqualityComparable/","title":"Struct concepts::EqualityComparable","text":"<p>template &lt;typename T, typename&gt;</p> <p>ClassList &gt; concepts &gt; EqualityComparable</p> <p>Inherits the following classes: std::false_type</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structconcepts_1_1EqualityComparable_3_01T_00_01typename_01std_1_1enable__if_3_01true_00_01typenb4b0200ec94bdc3bb35c4a1595f66806/","title":"Struct concepts::EqualityComparable&lt; T, typename std::enable_if&lt; true, typename details::void_t&lt; decltype(std::declval&lt; T &gt;()==std::declval&lt; T &gt;())&gt;::type &gt;::type &gt;","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; concepts &gt; EqualityComparable&lt; T, typename std::enable_if&lt; true, typename details::void_t&lt; decltype(std::declval&lt; T &gt;()==std::declval&lt; T &gt;())&gt;::type &gt;::type &gt;</p> <p>Inherits the following classes: std::true_type</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/namespacedetails/","title":"Namespace details","text":"<p>Namespace List &gt; details</p>"},{"location":"dictionary/namespacedetails/#namespaces","title":"Namespaces","text":"Type Name namespace And namespace Or namespace Other namespace err namespace impl namespace ok"},{"location":"dictionary/namespacedetails/#classes","title":"Classes","text":"Type Name struct Constructor &lt;typename T, typename E&gt; struct Constructor&lt; void, E &gt; &lt;typename E&gt; struct IsResult &lt;typename R&gt; struct IsResult&lt; Result&lt; T, E &gt; &gt; &lt;typename T, typename E&gt; struct ResultErrType &lt;typename R&gt; struct ResultErrType&lt; Result&lt; T, E &gt; &gt; &lt;typename T, typename E&gt; struct ResultOkType &lt;typename R&gt; struct ResultOkType&lt; Result&lt; T, E &gt; &gt; &lt;typename T, typename E&gt; struct Storage &lt;typename T, typename E&gt; struct Storage&lt; void, E &gt; &lt;typename E&gt; struct err_tag struct ok_tag struct result_of &lt;typename Func&gt; struct result_of&lt; Ret(*)(Args...)&gt; &lt;typename Ret, Args&gt; struct result_of&lt; Ret(Cls::*)(Args...) const &gt; &lt;typename Ret, typename Cls, Args&gt; struct void_t &lt;typename...&gt;"},{"location":"dictionary/namespacedetails/#public-functions","title":"Public Functions","text":"Type Name Ret map (const Result&lt; T, E &gt; &amp; result, Func func)  Ret mapError (const Result&lt; T, E &gt; &amp; result, Func func)  Ret orElse (const Result&lt; T, E &gt; &amp; result, Func func)  Result&lt; T, E &gt; otherwise (const Result&lt; T, E &gt; &amp; result, Func func)  Result&lt; T, E &gt; then (const Result&lt; T, E &gt; &amp; result, Func func)"},{"location":"dictionary/namespacedetails/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/namespacedetails/#function-map","title":"function map","text":"<pre><code>template&lt;typename T, typename E, typename Func, typename Ret&gt;\nRet details::map (\n    const Result &lt; T, E &gt; &amp; result,\n    Func func\n) \n</code></pre>"},{"location":"dictionary/namespacedetails/#function-maperror","title":"function mapError","text":"<pre><code>template&lt;typename T, typename E, typename Func, typename Ret&gt;\nRet details::mapError (\n    const Result &lt; T, E &gt; &amp; result,\n    Func func\n) \n</code></pre>"},{"location":"dictionary/namespacedetails/#function-orelse","title":"function orElse","text":"<pre><code>template&lt;typename T, typename E, typename Func, typename Ret&gt;\nRet details::orElse (\n    const Result &lt; T, E &gt; &amp; result,\n    Func func\n) \n</code></pre>"},{"location":"dictionary/namespacedetails/#function-otherwise","title":"function otherwise","text":"<pre><code>template&lt;typename T, typename E, typename Func&gt;\nResult &lt; T, E &gt; details::otherwise (\n    const Result &lt; T, E &gt; &amp; result,\n    Func func\n) \n</code></pre>"},{"location":"dictionary/namespacedetails/#function-then","title":"function then","text":"<pre><code>template&lt;typename T, typename E, typename Func&gt;\nResult &lt; T, E &gt; details::then (\n    const Result &lt; T, E &gt; &amp; result,\n    Func func\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/namespacedetails_1_1And/","title":"Namespace details::And","text":"<p>Namespace List &gt; details &gt; And</p>"},{"location":"dictionary/namespacedetails_1_1And/#namespaces","title":"Namespaces","text":"Type Name namespace impl"},{"location":"dictionary/namespacedetails_1_1And/#classes","title":"Classes","text":"Type Name struct Then &lt;typename Func&gt; struct Then&lt; Ret(*)(Args...)&gt; &lt;typename Ret, Args&gt; struct Then&lt; Ret(Cls::*)(Args...) const &gt; &lt;typename Ret, typename Cls, Args&gt; struct Then&lt; Ret(Cls::*)(Args...)&gt; &lt;typename Ret, typename Cls, Args&gt; <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1And_1_1Then/","title":"Struct details::And::Then","text":"<p>template &lt;typename Func&gt;</p> <p>ClassList &gt; details &gt; And &gt; Then</p> <p>Inherits the following classes: details::And::impl::Then</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1And_1_1Then_3_01Ret_07_5_08_07Args_8_8_8_08_4/","title":"Struct details::And::Then&lt; Ret(*)(Args...)&gt;","text":"<p>template &lt;typename Ret, typename... Args&gt;</p> <p>ClassList &gt; details &gt; And &gt; Then&lt; Ret(*)(Args...)&gt;</p> <p>Inherits the following classes: details::And::impl::Then</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1And_1_1Then_3_01Ret_07Cls_1_1_5_08_07Args_8_8_8_08_01const_01_4/","title":"Struct details::And::Then&lt; Ret(Cls::*)(Args...) const &gt;","text":"<p>template &lt;typename Ret, typename Cls, typename... Args&gt;</p> <p>ClassList &gt; details &gt; And &gt; Then&lt; Ret(Cls::*)(Args...) const &gt;</p> <p>Inherits the following classes: details::And::impl::Then</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1And_1_1Then_3_01Ret_07Cls_1_1_5_08_07Args_8_8_8_08_4/","title":"Struct details::And::Then&lt; Ret(Cls::*)(Args...)&gt;","text":"<p>template &lt;typename Ret, typename Cls, typename... Args&gt;</p> <p>ClassList &gt; details &gt; And &gt; Then&lt; Ret(Cls::*)(Args...)&gt;</p> <p>Inherits the following classes: details::And::impl::Then</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/namespacedetails_1_1And_1_1impl/","title":"Namespace details::And::impl","text":"<p>Namespace List &gt; details &gt; And &gt; impl</p>"},{"location":"dictionary/namespacedetails_1_1And_1_1impl/#classes","title":"Classes","text":"Type Name struct Then &lt;typename Func&gt; struct Then&lt; Ret(*)(Args...)&gt; &lt;typename Ret, Args&gt; struct Then&lt; Ret(Arg)&gt; &lt;typename Ret, typename Arg&gt; struct Then&lt; Ret(Cls::*)(Args...) const &gt; &lt;typename Ret, typename Cls, Args&gt; struct Then&lt; Ret(Cls::*)(Args...)&gt; &lt;typename Ret, typename Cls, Args&gt; struct Then&lt; Ret(void)&gt; &lt;typename Ret&gt; <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1And_1_1impl_1_1Then/","title":"Struct details::And::impl::Then","text":"<p>template &lt;typename Func&gt;</p> <p>ClassList &gt; details &gt; And &gt; impl &gt; Then</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1And_1_1impl_1_1Then_3_01Ret_07_5_08_07Args_8_8_8_08_4/","title":"Struct details::And::impl::Then&lt; Ret(*)(Args...)&gt;","text":"<p>template &lt;typename Ret, typename... Args&gt;</p> <p>ClassList &gt; details &gt; And &gt; impl &gt; Then&lt; Ret(*)(Args...)&gt;</p> <p>Inherits the following classes: details::And::impl::Then</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1And_1_1impl_1_1Then_3_01Ret_07Arg_08_4/","title":"Struct details::And::impl::Then&lt; Ret(Arg)&gt;","text":"<p>template &lt;typename Ret, typename Arg&gt;</p> <p>ClassList &gt; details &gt; And &gt; impl &gt; Then&lt; Ret(Arg)&gt;</p>"},{"location":"dictionary/structdetails_1_1And_1_1impl_1_1Then_3_01Ret_07Arg_08_4/#public-static-functions","title":"Public Static Functions","text":"Type Name Result&lt; T, E &gt; then (const Result&lt; T, E &gt; &amp; result, Func func)"},{"location":"dictionary/structdetails_1_1And_1_1impl_1_1Then_3_01Ret_07Arg_08_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"dictionary/structdetails_1_1And_1_1impl_1_1Then_3_01Ret_07Arg_08_4/#function-then","title":"function then","text":"<pre><code>template&lt;typename T, typename E, typename Func&gt;\nstatic inline Result &lt; T, E &gt; details::And::impl::Then&lt; Ret(Arg)&gt;::then (\n    const Result &lt; T, E &gt; &amp; result,\n    Func func\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1And_1_1impl_1_1Then_3_01Ret_07Cls_1_1_5_08_07Args_8_8_8_08_01const_01_4/","title":"Struct details::And::impl::Then&lt; Ret(Cls::*)(Args...) const &gt;","text":"<p>template &lt;typename Ret, typename Cls, typename... Args&gt;</p> <p>ClassList &gt; details &gt; And &gt; impl &gt; Then&lt; Ret(Cls::*)(Args...) const &gt;</p> <p>Inherits the following classes: details::And::impl::Then</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1And_1_1impl_1_1Then_3_01Ret_07Cls_1_1_5_08_07Args_8_8_8_08_4/","title":"Struct details::And::impl::Then&lt; Ret(Cls::*)(Args...)&gt;","text":"<p>template &lt;typename Ret, typename Cls, typename... Args&gt;</p> <p>ClassList &gt; details &gt; And &gt; impl &gt; Then&lt; Ret(Cls::*)(Args...)&gt;</p> <p>Inherits the following classes: details::And::impl::Then</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1And_1_1impl_1_1Then_3_01Ret_07void_08_4/","title":"Struct details::And::impl::Then&lt; Ret(void)&gt;","text":"<p>template &lt;typename Ret&gt;</p> <p>ClassList &gt; details &gt; And &gt; impl &gt; Then&lt; Ret(void)&gt;</p>"},{"location":"dictionary/structdetails_1_1And_1_1impl_1_1Then_3_01Ret_07void_08_4/#public-static-functions","title":"Public Static Functions","text":"Type Name Result&lt; T, E &gt; then (const Result&lt; T, E &gt; &amp; result, Func func)"},{"location":"dictionary/structdetails_1_1And_1_1impl_1_1Then_3_01Ret_07void_08_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"dictionary/structdetails_1_1And_1_1impl_1_1Then_3_01Ret_07void_08_4/#function-then","title":"function then","text":"<pre><code>template&lt;typename T, typename E, typename Func&gt;\nstatic inline Result &lt; T, E &gt; details::And::impl::Then&lt; Ret(void)&gt;::then (\n    const Result &lt; T, E &gt; &amp; result,\n    Func func\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1Constructor/","title":"Struct details::Constructor","text":"<p>template &lt;typename T, typename E&gt;</p> <p>ClassList &gt; details &gt; Constructor</p>"},{"location":"dictionary/structdetails_1_1Constructor/#public-static-functions","title":"Public Static Functions","text":"Type Name void copy (const Storage&lt; T, E &gt; &amp; src, Storage&lt; T, E &gt; &amp; dst, ok_tag)  void copy (const Storage&lt; T, E &gt; &amp; src, Storage&lt; T, E &gt; &amp; dst, err_tag)  void move (Storage&lt; T, E &gt; &amp;&amp; src, Storage&lt; T, E &gt; &amp; dst, ok_tag)  void move (Storage&lt; T, E &gt; &amp;&amp; src, Storage&lt; T, E &gt; &amp; dst, err_tag)"},{"location":"dictionary/structdetails_1_1Constructor/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"dictionary/structdetails_1_1Constructor/#function-copy-12","title":"function copy [1/2]","text":"<pre><code>static inline void details::Constructor::copy (\n    const Storage &lt; T, E &gt; &amp; src,\n    Storage &lt; T, E &gt; &amp; dst,\n    ok_tag\n) \n</code></pre>"},{"location":"dictionary/structdetails_1_1Constructor/#function-copy-22","title":"function copy [2/2]","text":"<pre><code>static inline void details::Constructor::copy (\n    const Storage &lt; T, E &gt; &amp; src,\n    Storage &lt; T, E &gt; &amp; dst,\n    err_tag\n) \n</code></pre>"},{"location":"dictionary/structdetails_1_1Constructor/#function-move-12","title":"function move [1/2]","text":"<pre><code>static inline void details::Constructor::move (\n    Storage &lt; T, E &gt; &amp;&amp; src,\n    Storage &lt; T, E &gt; &amp; dst,\n    ok_tag\n) \n</code></pre>"},{"location":"dictionary/structdetails_1_1Constructor/#function-move-22","title":"function move [2/2]","text":"<pre><code>static inline void details::Constructor::move (\n    Storage &lt; T, E &gt; &amp;&amp; src,\n    Storage &lt; T, E &gt; &amp; dst,\n    err_tag\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1Constructor_3_01void_00_01E_01_4/","title":"Struct details::Constructor&lt; void, E &gt;","text":"<p>template &lt;typename E&gt;</p> <p>ClassList &gt; details &gt; Constructor&lt; void, E &gt;</p>"},{"location":"dictionary/structdetails_1_1Constructor_3_01void_00_01E_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name void copy (const Storage&lt; void, E &gt; &amp; src, Storage&lt; void, E &gt; &amp; dst, ok_tag)  void copy (const Storage&lt; void, E &gt; &amp; src, Storage&lt; void, E &gt; &amp; dst, err_tag)  void move (Storage&lt; void, E &gt; &amp;&amp; src, Storage&lt; void, E &gt; &amp; dst, ok_tag)  void move (Storage&lt; void, E &gt; &amp;&amp; src, Storage&lt; void, E &gt; &amp; dst, err_tag)"},{"location":"dictionary/structdetails_1_1Constructor_3_01void_00_01E_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"dictionary/structdetails_1_1Constructor_3_01void_00_01E_01_4/#function-copy-12","title":"function copy [1/2]","text":"<pre><code>static inline void details::Constructor&lt; void, E &gt;::copy (\n    const Storage &lt; void, E &gt; &amp; src,\n    Storage &lt; void, E &gt; &amp; dst,\n    ok_tag\n) \n</code></pre>"},{"location":"dictionary/structdetails_1_1Constructor_3_01void_00_01E_01_4/#function-copy-22","title":"function copy [2/2]","text":"<pre><code>static inline void details::Constructor&lt; void, E &gt;::copy (\n    const Storage &lt; void, E &gt; &amp; src,\n    Storage &lt; void, E &gt; &amp; dst,\n    err_tag\n) \n</code></pre>"},{"location":"dictionary/structdetails_1_1Constructor_3_01void_00_01E_01_4/#function-move-12","title":"function move [1/2]","text":"<pre><code>static inline void details::Constructor&lt; void, E &gt;::move (\n    Storage &lt; void, E &gt; &amp;&amp; src,\n    Storage &lt; void, E &gt; &amp; dst,\n    ok_tag\n) \n</code></pre>"},{"location":"dictionary/structdetails_1_1Constructor_3_01void_00_01E_01_4/#function-move-22","title":"function move [2/2]","text":"<pre><code>static inline void details::Constructor&lt; void, E &gt;::move (\n    Storage &lt; void, E &gt; &amp;&amp; src,\n    Storage &lt; void, E &gt; &amp; dst,\n    err_tag\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1IsResult/","title":"Struct details::IsResult","text":"<p>template &lt;typename R&gt;</p> <p>ClassList &gt; details &gt; IsResult</p> <p>Inherits the following classes: std::false_type</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1IsResult_3_01Result_3_01T_00_01E_01_4_01_4/","title":"Struct details::IsResult&lt; Result&lt; T, E &gt; &gt;","text":"<p>template &lt;typename T, typename E&gt;</p> <p>ClassList &gt; details &gt; IsResult&lt; Result&lt; T, E &gt; &gt;</p> <p>Inherits the following classes: std::true_type</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/namespacedetails_1_1Or/","title":"Namespace details::Or","text":"<p>Namespace List &gt; details &gt; Or</p>"},{"location":"dictionary/namespacedetails_1_1Or/#namespaces","title":"Namespaces","text":"Type Name namespace impl"},{"location":"dictionary/namespacedetails_1_1Or/#classes","title":"Classes","text":"Type Name struct Else &lt;typename Func&gt; struct Else&lt; Ret(*)(Args...)&gt; &lt;typename Ret, Args&gt; struct Else&lt; Ret(Cls::*)(Args...) const &gt; &lt;typename Ret, typename Cls, Args&gt; struct Else&lt; Ret(Cls::*)(Args...)&gt; &lt;typename Ret, typename Cls, Args&gt; <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1Or_1_1Else/","title":"Struct details::Or::Else","text":"<p>template &lt;typename Func&gt;</p> <p>ClassList &gt; details &gt; Or &gt; Else</p> <p>Inherits the following classes: details::Or::impl::Else</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1Or_1_1Else_3_01Ret_07_5_08_07Args_8_8_8_08_4/","title":"Struct details::Or::Else&lt; Ret(*)(Args...)&gt;","text":"<p>template &lt;typename Ret, typename... Args&gt;</p> <p>ClassList &gt; details &gt; Or &gt; Else&lt; Ret(*)(Args...)&gt;</p> <p>Inherits the following classes: details::Or::impl::Else</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1Or_1_1Else_3_01Ret_07Cls_1_1_5_08_07Args_8_8_8_08_01const_01_4/","title":"Struct details::Or::Else&lt; Ret(Cls::*)(Args...) const &gt;","text":"<p>template &lt;typename Ret, typename Cls, typename... Args&gt;</p> <p>ClassList &gt; details &gt; Or &gt; Else&lt; Ret(Cls::*)(Args...) const &gt;</p> <p>Inherits the following classes: details::Or::impl::Else</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1Or_1_1Else_3_01Ret_07Cls_1_1_5_08_07Args_8_8_8_08_4/","title":"Struct details::Or::Else&lt; Ret(Cls::*)(Args...)&gt;","text":"<p>template &lt;typename Ret, typename Cls, typename... Args&gt;</p> <p>ClassList &gt; details &gt; Or &gt; Else&lt; Ret(Cls::*)(Args...)&gt;</p> <p>Inherits the following classes: details::Or::impl::Else</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/namespacedetails_1_1Or_1_1impl/","title":"Namespace details::Or::impl","text":"<p>Namespace List &gt; details &gt; Or &gt; impl</p>"},{"location":"dictionary/namespacedetails_1_1Or_1_1impl/#classes","title":"Classes","text":"Type Name struct Else &lt;typename Func&gt; struct Else&lt; Result&lt; T, F &gt;(Arg)&gt; &lt;typename T, typename F, typename Arg&gt; struct Else&lt; Result&lt; T, F &gt;(void)&gt; &lt;typename T, typename F&gt; struct Else&lt; Ret(*)(Args...)&gt; &lt;typename Ret, Args&gt; struct Else&lt; Ret(Cls::*)(Args...) const &gt; &lt;typename Ret, typename Cls, Args&gt; struct Else&lt; Ret(Cls::*)(Args...)&gt; &lt;typename Ret, typename Cls, Args&gt; <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1Or_1_1impl_1_1Else/","title":"Struct details::Or::impl::Else","text":"<p>template &lt;typename Func&gt;</p> <p>ClassList &gt; details &gt; Or &gt; impl &gt; Else</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1Or_1_1impl_1_1Else_3_01Result_3_01T_00_01F_01_4_07Arg_08_4/","title":"Struct details::Or::impl::Else&lt; Result&lt; T, F &gt;(Arg)&gt;","text":"<p>template &lt;typename T, typename F, typename Arg&gt;</p> <p>ClassList &gt; details &gt; Or &gt; impl &gt; Else&lt; Result&lt; T, F &gt;(Arg)&gt;</p>"},{"location":"dictionary/structdetails_1_1Or_1_1impl_1_1Else_3_01Result_3_01T_00_01F_01_4_07Arg_08_4/#public-static-functions","title":"Public Static Functions","text":"Type Name Result&lt; T, F &gt; orElse (const Result&lt; T, E &gt; &amp; result, Func func)  Result&lt; void, F &gt; orElse (const Result&lt; void, E &gt; &amp; result, Func func)"},{"location":"dictionary/structdetails_1_1Or_1_1impl_1_1Else_3_01Result_3_01T_00_01F_01_4_07Arg_08_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"dictionary/structdetails_1_1Or_1_1impl_1_1Else_3_01Result_3_01T_00_01F_01_4_07Arg_08_4/#function-orelse-12","title":"function orElse [1/2]","text":"<pre><code>template&lt;typename E, typename Func&gt;\nstatic inline Result &lt; T, F &gt; details::Or::impl::Else&lt; Result&lt; T, F &gt;(Arg)&gt;::orElse (\n    const Result &lt; T, E &gt; &amp; result,\n    Func func\n) \n</code></pre>"},{"location":"dictionary/structdetails_1_1Or_1_1impl_1_1Else_3_01Result_3_01T_00_01F_01_4_07Arg_08_4/#function-orelse-22","title":"function orElse [2/2]","text":"<pre><code>template&lt;typename E, typename Func&gt;\nstatic inline Result &lt; void, F &gt; details::Or::impl::Else&lt; Result&lt; T, F &gt;(Arg)&gt;::orElse (\n    const Result &lt; void, E &gt; &amp; result,\n    Func func\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1Or_1_1impl_1_1Else_3_01Result_3_01T_00_01F_01_4_07void_08_4/","title":"Struct details::Or::impl::Else&lt; Result&lt; T, F &gt;(void)&gt;","text":"<p>template &lt;typename T, typename F&gt;</p> <p>ClassList &gt; details &gt; Or &gt; impl &gt; Else&lt; Result&lt; T, F &gt;(void)&gt;</p>"},{"location":"dictionary/structdetails_1_1Or_1_1impl_1_1Else_3_01Result_3_01T_00_01F_01_4_07void_08_4/#public-static-functions","title":"Public Static Functions","text":"Type Name Result&lt; T, F &gt; orElse (const Result&lt; T, E &gt; &amp; result, Func func)  Result&lt; void, F &gt; orElse (const Result&lt; void, E &gt; &amp; result, Func func)"},{"location":"dictionary/structdetails_1_1Or_1_1impl_1_1Else_3_01Result_3_01T_00_01F_01_4_07void_08_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"dictionary/structdetails_1_1Or_1_1impl_1_1Else_3_01Result_3_01T_00_01F_01_4_07void_08_4/#function-orelse-12","title":"function orElse [1/2]","text":"<pre><code>template&lt;typename E, typename Func&gt;\nstatic inline Result &lt; T, F &gt; details::Or::impl::Else&lt; Result&lt; T, F &gt;(void)&gt;::orElse (\n    const Result &lt; T, E &gt; &amp; result,\n    Func func\n) \n</code></pre>"},{"location":"dictionary/structdetails_1_1Or_1_1impl_1_1Else_3_01Result_3_01T_00_01F_01_4_07void_08_4/#function-orelse-22","title":"function orElse [2/2]","text":"<pre><code>template&lt;typename E, typename Func&gt;\nstatic inline Result &lt; void, F &gt; details::Or::impl::Else&lt; Result&lt; T, F &gt;(void)&gt;::orElse (\n    const Result &lt; void, E &gt; &amp; result,\n    Func func\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1Or_1_1impl_1_1Else_3_01Ret_07_5_08_07Args_8_8_8_08_4/","title":"Struct details::Or::impl::Else&lt; Ret(*)(Args...)&gt;","text":"<p>template &lt;typename Ret, typename... Args&gt;</p> <p>ClassList &gt; details &gt; Or &gt; impl &gt; Else&lt; Ret(*)(Args...)&gt;</p> <p>Inherits the following classes: details::Or::impl::Else</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1Or_1_1impl_1_1Else_3_01Ret_07Cls_1_1_5_08_07Args_8_8_8_08_01const_01_4/","title":"Struct details::Or::impl::Else&lt; Ret(Cls::*)(Args...) const &gt;","text":"<p>template &lt;typename Ret, typename Cls, typename... Args&gt;</p> <p>ClassList &gt; details &gt; Or &gt; impl &gt; Else&lt; Ret(Cls::*)(Args...) const &gt;</p> <p>Inherits the following classes: details::Or::impl::Else</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1Or_1_1impl_1_1Else_3_01Ret_07Cls_1_1_5_08_07Args_8_8_8_08_4/","title":"Struct details::Or::impl::Else&lt; Ret(Cls::*)(Args...)&gt;","text":"<p>template &lt;typename Ret, typename Cls, typename... Args&gt;</p> <p>ClassList &gt; details &gt; Or &gt; impl &gt; Else&lt; Ret(Cls::*)(Args...)&gt;</p> <p>Inherits the following classes: details::Or::impl::Else</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/namespacedetails_1_1Other/","title":"Namespace details::Other","text":"<p>Namespace List &gt; details &gt; Other</p>"},{"location":"dictionary/namespacedetails_1_1Other/#namespaces","title":"Namespaces","text":"Type Name namespace impl"},{"location":"dictionary/namespacedetails_1_1Other/#classes","title":"Classes","text":"Type Name struct Wise &lt;typename Func&gt; struct Wise&lt; Ret(*)(Args...)&gt; &lt;typename Ret, Args&gt; struct Wise&lt; Ret(Cls::*)(Args...) const &gt; &lt;typename Ret, typename Cls, Args&gt; struct Wise&lt; Ret(Cls::*)(Args...)&gt; &lt;typename Ret, typename Cls, Args&gt; <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1Other_1_1Wise/","title":"Struct details::Other::Wise","text":"<p>template &lt;typename Func&gt;</p> <p>ClassList &gt; details &gt; Other &gt; Wise</p> <p>Inherits the following classes: details::Other::impl::Wise</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1Other_1_1Wise_3_01Ret_07_5_08_07Args_8_8_8_08_4/","title":"Struct details::Other::Wise&lt; Ret(*)(Args...)&gt;","text":"<p>template &lt;typename Ret, typename... Args&gt;</p> <p>ClassList &gt; details &gt; Other &gt; Wise&lt; Ret(*)(Args...)&gt;</p> <p>Inherits the following classes: details::Other::impl::Wise</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1Other_1_1Wise_3_01Ret_07Cls_1_1_5_08_07Args_8_8_8_08_01const_01_4/","title":"Struct details::Other::Wise&lt; Ret(Cls::*)(Args...) const &gt;","text":"<p>template &lt;typename Ret, typename Cls, typename... Args&gt;</p> <p>ClassList &gt; details &gt; Other &gt; Wise&lt; Ret(Cls::*)(Args...) const &gt;</p> <p>Inherits the following classes: details::Other::impl::Wise</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1Other_1_1Wise_3_01Ret_07Cls_1_1_5_08_07Args_8_8_8_08_4/","title":"Struct details::Other::Wise&lt; Ret(Cls::*)(Args...)&gt;","text":"<p>template &lt;typename Ret, typename Cls, typename... Args&gt;</p> <p>ClassList &gt; details &gt; Other &gt; Wise&lt; Ret(Cls::*)(Args...)&gt;</p> <p>Inherits the following classes: details::Other::impl::Wise</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/namespacedetails_1_1Other_1_1impl/","title":"Namespace details::Other::impl","text":"<p>Namespace List &gt; details &gt; Other &gt; impl</p>"},{"location":"dictionary/namespacedetails_1_1Other_1_1impl/#classes","title":"Classes","text":"Type Name struct Wise &lt;typename Func&gt; struct Wise&lt; Ret(*)(Args...)&gt; &lt;typename Ret, Args&gt; struct Wise&lt; Ret(Arg)&gt; &lt;typename Ret, typename Arg&gt; struct Wise&lt; Ret(Cls::*)(Args...) const &gt; &lt;typename Ret, typename Cls, Args&gt; struct Wise&lt; Ret(Cls::*)(Args...)&gt; &lt;typename Ret, typename Cls, Args&gt; <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1Other_1_1impl_1_1Wise/","title":"Struct details::Other::impl::Wise","text":"<p>template &lt;typename Func&gt;</p> <p>ClassList &gt; details &gt; Other &gt; impl &gt; Wise</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1Other_1_1impl_1_1Wise_3_01Ret_07_5_08_07Args_8_8_8_08_4/","title":"Struct details::Other::impl::Wise&lt; Ret(*)(Args...)&gt;","text":"<p>template &lt;typename Ret, typename... Args&gt;</p> <p>ClassList &gt; details &gt; Other &gt; impl &gt; Wise&lt; Ret(*)(Args...)&gt;</p> <p>Inherits the following classes: details::Other::impl::Wise</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1Other_1_1impl_1_1Wise_3_01Ret_07Arg_08_4/","title":"Struct details::Other::impl::Wise&lt; Ret(Arg)&gt;","text":"<p>template &lt;typename Ret, typename Arg&gt;</p> <p>ClassList &gt; details &gt; Other &gt; impl &gt; Wise&lt; Ret(Arg)&gt;</p>"},{"location":"dictionary/structdetails_1_1Other_1_1impl_1_1Wise_3_01Ret_07Arg_08_4/#public-static-functions","title":"Public Static Functions","text":"Type Name Result&lt; T, E &gt; otherwise (const Result&lt; T, E &gt; &amp; result, Func func)"},{"location":"dictionary/structdetails_1_1Other_1_1impl_1_1Wise_3_01Ret_07Arg_08_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"dictionary/structdetails_1_1Other_1_1impl_1_1Wise_3_01Ret_07Arg_08_4/#function-otherwise","title":"function otherwise","text":"<pre><code>template&lt;typename T, typename E, typename Func&gt;\nstatic inline Result &lt; T, E &gt; details::Other::impl::Wise&lt; Ret(Arg)&gt;::otherwise (\n    const Result &lt; T, E &gt; &amp; result,\n    Func func\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1Other_1_1impl_1_1Wise_3_01Ret_07Cls_1_1_5_08_07Args_8_8_8_08_01const_01_4/","title":"Struct details::Other::impl::Wise&lt; Ret(Cls::*)(Args...) const &gt;","text":"<p>template &lt;typename Ret, typename Cls, typename... Args&gt;</p> <p>ClassList &gt; details &gt; Other &gt; impl &gt; Wise&lt; Ret(Cls::*)(Args...) const &gt;</p> <p>Inherits the following classes: details::Other::impl::Wise</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1Other_1_1impl_1_1Wise_3_01Ret_07Cls_1_1_5_08_07Args_8_8_8_08_4/","title":"Struct details::Other::impl::Wise&lt; Ret(Cls::*)(Args...)&gt;","text":"<p>template &lt;typename Ret, typename Cls, typename... Args&gt;</p> <p>ClassList &gt; details &gt; Other &gt; impl &gt; Wise&lt; Ret(Cls::*)(Args...)&gt;</p> <p>Inherits the following classes: details::Other::impl::Wise</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1ResultErrType/","title":"Struct details::ResultErrType","text":"<p>template &lt;typename R&gt;</p> <p>ClassList &gt; details &gt; ResultErrType</p>"},{"location":"dictionary/structdetails_1_1ResultErrType/#public-types","title":"Public Types","text":"Type Name typedef R type"},{"location":"dictionary/structdetails_1_1ResultErrType/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"dictionary/structdetails_1_1ResultErrType/#typedef-type","title":"typedef type","text":"<pre><code>typedef R details::ResultErrType&lt; R &gt;::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1ResultErrType_3_01Result_3_01T_00_01E_01_4_01_4/","title":"Struct details::ResultErrType&lt; Result&lt; T, E &gt; &gt;","text":"<p>template &lt;typename T, typename E&gt;</p> <p>ClassList &gt; details &gt; ResultErrType&lt; Result&lt; T, E &gt; &gt;</p>"},{"location":"dictionary/structdetails_1_1ResultErrType_3_01Result_3_01T_00_01E_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef std::remove_reference&lt; E &gt;::type type"},{"location":"dictionary/structdetails_1_1ResultErrType_3_01Result_3_01T_00_01E_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"dictionary/structdetails_1_1ResultErrType_3_01Result_3_01T_00_01E_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>typedef std::remove_reference&lt;E&gt;::type details::ResultErrType&lt; Result&lt; T, E &gt; &gt;::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1ResultOkType/","title":"Struct details::ResultOkType","text":"<p>template &lt;typename R&gt;</p> <p>ClassList &gt; details &gt; ResultOkType</p>"},{"location":"dictionary/structdetails_1_1ResultOkType/#public-types","title":"Public Types","text":"Type Name typedef std::decay&lt; R &gt;::type type"},{"location":"dictionary/structdetails_1_1ResultOkType/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"dictionary/structdetails_1_1ResultOkType/#typedef-type","title":"typedef type","text":"<pre><code>typedef std::decay&lt;R&gt;::type details::ResultOkType&lt; R &gt;::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1ResultOkType_3_01Result_3_01T_00_01E_01_4_01_4/","title":"Struct details::ResultOkType&lt; Result&lt; T, E &gt; &gt;","text":"<p>template &lt;typename T, typename E&gt;</p> <p>ClassList &gt; details &gt; ResultOkType&lt; Result&lt; T, E &gt; &gt;</p>"},{"location":"dictionary/structdetails_1_1ResultOkType_3_01Result_3_01T_00_01E_01_4_01_4/#public-types","title":"Public Types","text":"Type Name typedef T type"},{"location":"dictionary/structdetails_1_1ResultOkType_3_01Result_3_01T_00_01E_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"dictionary/structdetails_1_1ResultOkType_3_01Result_3_01T_00_01E_01_4_01_4/#typedef-type","title":"typedef type","text":"<pre><code>typedef T details::ResultOkType&lt; Result&lt; T, E &gt; &gt;::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1Storage/","title":"Struct details::Storage","text":"<p>template &lt;typename T, typename E&gt;</p> <p>ClassList &gt; details &gt; Storage</p>"},{"location":"dictionary/structdetails_1_1Storage/#public-types","title":"Public Types","text":"Type Name typedef std::aligned_storage&lt; Size, Align &gt;::type type"},{"location":"dictionary/structdetails_1_1Storage/#public-attributes","title":"Public Attributes","text":"Type Name bool initialized_ type storage_"},{"location":"dictionary/structdetails_1_1Storage/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr size_t Align   = <code>sizeof(T) &amp;gt; sizeof(E) ? alignof(T) : alignof(E)</code> constexpr size_t Size   = <code>sizeof(T) &amp;gt; sizeof(E) ? sizeof(T) : sizeof(E)</code>"},{"location":"dictionary/structdetails_1_1Storage/#public-functions","title":"Public Functions","text":"Type Name Storage ()  void construct (types::Ok&lt; T &gt; ok)  void construct (types::Err&lt; E &gt; err)  void destroy (ok_tag)  void destroy (err_tag)  const U &amp; get () const U &amp; get ()  void rawConstruct (U &amp;&amp; val)"},{"location":"dictionary/structdetails_1_1Storage/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"dictionary/structdetails_1_1Storage/#typedef-type","title":"typedef type","text":"<pre><code>typedef std::aligned_storage&lt;Size,Align&gt;::type details::Storage&lt; T, E &gt;::type;\n</code></pre>"},{"location":"dictionary/structdetails_1_1Storage/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"dictionary/structdetails_1_1Storage/#variable-initialized_","title":"variable initialized_","text":"<pre><code>bool details::Storage&lt; T, E &gt;::initialized_;\n</code></pre>"},{"location":"dictionary/structdetails_1_1Storage/#variable-storage_","title":"variable storage_","text":"<pre><code>type details::Storage&lt; T, E &gt;::storage_;\n</code></pre>"},{"location":"dictionary/structdetails_1_1Storage/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"dictionary/structdetails_1_1Storage/#variable-align","title":"variable Align","text":"<pre><code>constexpr size_t details::Storage&lt; T, E &gt;::Align;\n</code></pre>"},{"location":"dictionary/structdetails_1_1Storage/#variable-size","title":"variable Size","text":"<pre><code>constexpr size_t details::Storage&lt; T, E &gt;::Size;\n</code></pre>"},{"location":"dictionary/structdetails_1_1Storage/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/structdetails_1_1Storage/#function-storage","title":"function Storage","text":"<pre><code>inline details::Storage::Storage () \n</code></pre>"},{"location":"dictionary/structdetails_1_1Storage/#function-construct-12","title":"function construct [1/2]","text":"<pre><code>inline void details::Storage::construct (\n    types::Ok &lt; T &gt; ok\n) \n</code></pre>"},{"location":"dictionary/structdetails_1_1Storage/#function-construct-22","title":"function construct [2/2]","text":"<pre><code>inline void details::Storage::construct (\n    types::Err &lt; E &gt; err\n) \n</code></pre>"},{"location":"dictionary/structdetails_1_1Storage/#function-destroy-12","title":"function destroy [1/2]","text":"<pre><code>inline void details::Storage::destroy (\n    ok_tag\n) \n</code></pre>"},{"location":"dictionary/structdetails_1_1Storage/#function-destroy-22","title":"function destroy [2/2]","text":"<pre><code>inline void details::Storage::destroy (\n    err_tag\n) \n</code></pre>"},{"location":"dictionary/structdetails_1_1Storage/#function-get-12","title":"function get [1/2]","text":"<pre><code>template&lt;typename U&gt;\ninline const U &amp; details::Storage::get () const\n</code></pre>"},{"location":"dictionary/structdetails_1_1Storage/#function-get-22","title":"function get [2/2]","text":"<pre><code>template&lt;typename U&gt;\ninline U &amp; details::Storage::get () \n</code></pre>"},{"location":"dictionary/structdetails_1_1Storage/#function-rawconstruct","title":"function rawConstruct","text":"<pre><code>template&lt;typename U&gt;\ninline void details::Storage::rawConstruct (\n    U &amp;&amp; val\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1Storage_3_01void_00_01E_01_4/","title":"Struct details::Storage&lt; void, E &gt;","text":"<p>template &lt;typename E&gt;</p> <p>ClassList &gt; details &gt; Storage&lt; void, E &gt;</p>"},{"location":"dictionary/structdetails_1_1Storage_3_01void_00_01E_01_4/#public-types","title":"Public Types","text":"Type Name typedef std::aligned_storage&lt; sizeof(E), alignof(E)&gt;::type type"},{"location":"dictionary/structdetails_1_1Storage_3_01void_00_01E_01_4/#public-attributes","title":"Public Attributes","text":"Type Name bool initialized_ type storage_"},{"location":"dictionary/structdetails_1_1Storage_3_01void_00_01E_01_4/#public-functions","title":"Public Functions","text":"Type Name void construct (types::Ok&lt; void &gt;)  void construct (types::Err&lt; E &gt; err)  void destroy (ok_tag)  void destroy (err_tag)  const U &amp; get () const U &amp; get ()  void rawConstruct (U &amp;&amp; val)"},{"location":"dictionary/structdetails_1_1Storage_3_01void_00_01E_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"dictionary/structdetails_1_1Storage_3_01void_00_01E_01_4/#typedef-type","title":"typedef type","text":"<pre><code>typedef std::aligned_storage&lt;sizeof(E),alignof(E)&gt;::type details::Storage&lt; void, E &gt;::type;\n</code></pre>"},{"location":"dictionary/structdetails_1_1Storage_3_01void_00_01E_01_4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"dictionary/structdetails_1_1Storage_3_01void_00_01E_01_4/#variable-initialized_","title":"variable initialized_","text":"<pre><code>bool details::Storage&lt; void, E &gt;::initialized_;\n</code></pre>"},{"location":"dictionary/structdetails_1_1Storage_3_01void_00_01E_01_4/#variable-storage_","title":"variable storage_","text":"<pre><code>type details::Storage&lt; void, E &gt;::storage_;\n</code></pre>"},{"location":"dictionary/structdetails_1_1Storage_3_01void_00_01E_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/structdetails_1_1Storage_3_01void_00_01E_01_4/#function-construct-12","title":"function construct [1/2]","text":"<pre><code>inline void details::Storage&lt; void, E &gt;::construct (\n    types::Ok &lt; void &gt;\n) \n</code></pre>"},{"location":"dictionary/structdetails_1_1Storage_3_01void_00_01E_01_4/#function-construct-22","title":"function construct [2/2]","text":"<pre><code>inline void details::Storage&lt; void, E &gt;::construct (\n    types::Err &lt; E &gt; err\n) \n</code></pre>"},{"location":"dictionary/structdetails_1_1Storage_3_01void_00_01E_01_4/#function-destroy-12","title":"function destroy [1/2]","text":"<pre><code>inline void details::Storage&lt; void, E &gt;::destroy (\n    ok_tag\n) \n</code></pre>"},{"location":"dictionary/structdetails_1_1Storage_3_01void_00_01E_01_4/#function-destroy-22","title":"function destroy [2/2]","text":"<pre><code>inline void details::Storage&lt; void, E &gt;::destroy (\n    err_tag\n) \n</code></pre>"},{"location":"dictionary/structdetails_1_1Storage_3_01void_00_01E_01_4/#function-get-12","title":"function get [1/2]","text":"<pre><code>template&lt;typename U&gt;\ninline const U &amp; details::Storage&lt; void, E &gt;::get () const\n</code></pre>"},{"location":"dictionary/structdetails_1_1Storage_3_01void_00_01E_01_4/#function-get-22","title":"function get [2/2]","text":"<pre><code>template&lt;typename U&gt;\ninline U &amp; details::Storage&lt; void, E &gt;::get () \n</code></pre>"},{"location":"dictionary/structdetails_1_1Storage_3_01void_00_01E_01_4/#function-rawconstruct","title":"function rawConstruct","text":"<pre><code>template&lt;typename U&gt;\ninline void details::Storage&lt; void, E &gt;::rawConstruct (\n    U &amp;&amp; val\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/namespacedetails_1_1err/","title":"Namespace details::err","text":"<p>Namespace List &gt; details &gt; err</p>"},{"location":"dictionary/namespacedetails_1_1err/#namespaces","title":"Namespaces","text":"Type Name namespace impl"},{"location":"dictionary/namespacedetails_1_1err/#classes","title":"Classes","text":"Type Name struct Map &lt;typename Func&gt; <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1err_1_1Map/","title":"Struct details::err::Map","text":"<p>template &lt;typename Func&gt;</p> <p>ClassList &gt; details &gt; err &gt; Map</p> <p>Inherits the following classes: details::err::impl::Map</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/namespacedetails_1_1err_1_1impl/","title":"Namespace details::err::impl","text":"<p>Namespace List &gt; details &gt; err &gt; impl</p>"},{"location":"dictionary/namespacedetails_1_1err_1_1impl/#classes","title":"Classes","text":"Type Name struct Map &lt;typename T&gt; struct Map&lt; Ret(Cls::*)(Arg) const &gt; &lt;typename Ret, typename Cls, typename Arg&gt; <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1err_1_1impl_1_1Map/","title":"Struct details::err::impl::Map","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; details &gt; err &gt; impl &gt; Map</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1err_1_1impl_1_1Map_3_01Ret_07Cls_1_1_5_08_07Arg_08_01const_01_4/","title":"Struct details::err::impl::Map&lt; Ret(Cls::*)(Arg) const &gt;","text":"<p>template &lt;typename Ret, typename Cls, typename Arg&gt;</p> <p>ClassList &gt; details &gt; err &gt; impl &gt; Map&lt; Ret(Cls::*)(Arg) const &gt;</p>"},{"location":"dictionary/structdetails_1_1err_1_1impl_1_1Map_3_01Ret_07Cls_1_1_5_08_07Arg_08_01const_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name Result&lt; T, Ret &gt; map (const Result&lt; T, E &gt; &amp; result, Func func)  Result&lt; void, Ret &gt; map (const Result&lt; void, E &gt; &amp; result, Func func)"},{"location":"dictionary/structdetails_1_1err_1_1impl_1_1Map_3_01Ret_07Cls_1_1_5_08_07Arg_08_01const_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"dictionary/structdetails_1_1err_1_1impl_1_1Map_3_01Ret_07Cls_1_1_5_08_07Arg_08_01const_01_4/#function-map-12","title":"function map [1/2]","text":"<pre><code>template&lt;typename T, typename E, typename Func&gt;\nstatic inline Result &lt; T, Ret &gt; details::err::impl::Map&lt; Ret(Cls::*)(Arg) const &gt;::map (\n    const Result &lt; T, E &gt; &amp; result,\n    Func func\n) \n</code></pre>"},{"location":"dictionary/structdetails_1_1err_1_1impl_1_1Map_3_01Ret_07Cls_1_1_5_08_07Arg_08_01const_01_4/#function-map-22","title":"function map [2/2]","text":"<pre><code>template&lt;typename E, typename Func&gt;\nstatic inline Result &lt; void, Ret &gt; details::err::impl::Map&lt; Ret(Cls::*)(Arg) const &gt;::map (\n    const Result &lt; void, E &gt; &amp; result,\n    Func func\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1err__tag/","title":"Struct details::err_tag","text":"<p>ClassList &gt; details &gt; err_tag</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/namespacedetails_1_1impl/","title":"Namespace details::impl","text":"<p>Namespace List &gt; details &gt; impl</p>"},{"location":"dictionary/namespacedetails_1_1impl/#classes","title":"Classes","text":"Type Name struct result_of &lt;typename Func&gt; struct result_of&lt; Ret(Args...)&gt; &lt;typename Ret, Args&gt; struct result_of&lt; Ret(Cls::*)(Args...)&gt; &lt;typename Ret, typename Cls, Args&gt; <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1impl_1_1result__of/","title":"Struct details::impl::result_of","text":"<p>template &lt;typename Func&gt;</p> <p>ClassList &gt; details &gt; impl &gt; result_of</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1impl_1_1result__of_3_01Ret_07Args_8_8_8_08_4/","title":"Struct details::impl::result_of&lt; Ret(Args...)&gt;","text":"<p>template &lt;typename Ret, typename... Args&gt;</p> <p>ClassList &gt; details &gt; impl &gt; result_of&lt; Ret(Args...)&gt;</p> <p>Inherited by the following classes: details::impl::result_of&lt; Ret(Cls::*)(Args...)&gt;</p>"},{"location":"dictionary/structdetails_1_1impl_1_1result__of_3_01Ret_07Args_8_8_8_08_4/#public-types","title":"Public Types","text":"Type Name typedef Ret type"},{"location":"dictionary/structdetails_1_1impl_1_1result__of_3_01Ret_07Args_8_8_8_08_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"dictionary/structdetails_1_1impl_1_1result__of_3_01Ret_07Args_8_8_8_08_4/#typedef-type","title":"typedef type","text":"<pre><code>typedef Ret details::impl::result_of&lt; Ret(Args...)&gt;::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1impl_1_1result__of_3_01Ret_07Cls_1_1_5_08_07Args_8_8_8_08_4/","title":"Struct details::impl::result_of&lt; Ret(Cls::*)(Args...)&gt;","text":"<p>template &lt;typename Ret, typename Cls, typename... Args&gt;</p> <p>ClassList &gt; details &gt; impl &gt; result_of&lt; Ret(Cls::*)(Args...)&gt;</p> <p>Inherits the following classes: details::impl::result_of&lt; Ret(Args...)&gt;</p>"},{"location":"dictionary/structdetails_1_1impl_1_1result__of_3_01Ret_07Cls_1_1_5_08_07Args_8_8_8_08_4/#public-types-inherited-from-detailsimplresult_of-retargs","title":"Public Types inherited from details::impl::result_of&lt; Ret(Args...)&gt;","text":"<p>See details::impl::result_of&lt; Ret(Args...)&gt;</p> Type Name typedef Ret type <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/namespacedetails_1_1ok/","title":"Namespace details::ok","text":"<p>Namespace List &gt; details &gt; ok</p>"},{"location":"dictionary/namespacedetails_1_1ok/#namespaces","title":"Namespaces","text":"Type Name namespace impl"},{"location":"dictionary/namespacedetails_1_1ok/#classes","title":"Classes","text":"Type Name struct Map &lt;typename Func&gt; struct Map&lt; Ret(*)(Args...)&gt; &lt;typename Ret, Args&gt; struct Map&lt; Ret(Cls::*)(Args...) const &gt; &lt;typename Ret, typename Cls, Args&gt; struct Map&lt; Ret(Cls::*)(Args...)&gt; &lt;typename Ret, typename Cls, Args&gt; struct Map&lt; std::function&lt; Ret(Args...)&gt; &gt; &lt;typename Ret, Args&gt; <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1ok_1_1Map/","title":"Struct details::ok::Map","text":"<p>template &lt;typename Func&gt;</p> <p>ClassList &gt; details &gt; ok &gt; Map</p> <p>Inherits the following classes: details::ok::impl::Map</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1ok_1_1Map_3_01Ret_07_5_08_07Args_8_8_8_08_4/","title":"Struct details::ok::Map&lt; Ret(*)(Args...)&gt;","text":"<p>template &lt;typename Ret, typename... Args&gt;</p> <p>ClassList &gt; details &gt; ok &gt; Map&lt; Ret(*)(Args...)&gt;</p> <p>Inherits the following classes: details::ok::impl::Map</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1ok_1_1Map_3_01Ret_07Cls_1_1_5_08_07Args_8_8_8_08_01const_01_4/","title":"Struct details::ok::Map&lt; Ret(Cls::*)(Args...) const &gt;","text":"<p>template &lt;typename Ret, typename Cls, typename... Args&gt;</p> <p>ClassList &gt; details &gt; ok &gt; Map&lt; Ret(Cls::*)(Args...) const &gt;</p> <p>Inherits the following classes: details::ok::impl::Map</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1ok_1_1Map_3_01Ret_07Cls_1_1_5_08_07Args_8_8_8_08_4/","title":"Struct details::ok::Map&lt; Ret(Cls::*)(Args...)&gt;","text":"<p>template &lt;typename Ret, typename Cls, typename... Args&gt;</p> <p>ClassList &gt; details &gt; ok &gt; Map&lt; Ret(Cls::*)(Args...)&gt;</p> <p>Inherits the following classes: details::ok::impl::Map</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1ok_1_1Map_3_01std_1_1function_3_01Ret_07Args_8_8_8_08_4_01_4/","title":"Struct details::ok::Map&lt; std::function&lt; Ret(Args...)&gt; &gt;","text":"<p>template &lt;typename Ret, typename... Args&gt;</p> <p>ClassList &gt; details &gt; ok &gt; Map&lt; std::function&lt; Ret(Args...)&gt; &gt;</p> <p>Inherits the following classes: details::ok::impl::Map</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/namespacedetails_1_1ok_1_1impl/","title":"Namespace details::ok::impl","text":"<p>Namespace List &gt; details &gt; ok &gt; impl</p>"},{"location":"dictionary/namespacedetails_1_1ok_1_1impl/#classes","title":"Classes","text":"Type Name struct Map &lt;typename T&gt; struct Map&lt; Result&lt; U, E &gt;(Arg)&gt; &lt;typename U, typename E, typename Arg&gt; struct Map&lt; Result&lt; U, E &gt;(void)&gt; &lt;typename U, typename E&gt; struct Map&lt; Ret(Arg)&gt; &lt;typename Ret, typename Arg&gt; struct Map&lt; Ret(Cls::*)(Arg) const &gt; &lt;typename Ret, typename Cls, typename Arg&gt; struct Map&lt; Ret(Cls::*)(Arg)&gt; &lt;typename Ret, typename Cls, typename Arg&gt; struct Map&lt; Ret(void)&gt; &lt;typename Ret&gt; struct Map&lt; void(Arg)&gt; &lt;typename Arg&gt; struct Map&lt; void(void)&gt; &lt;&gt; <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map/","title":"Struct details::ok::impl::Map","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; details &gt; ok &gt; impl &gt; Map</p> <p>Inherited by the following classes: details::ok::Map</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01Result_3_01U_00_01E_01_4_07Arg_08_4/","title":"Struct details::ok::impl::Map&lt; Result&lt; U, E &gt;(Arg)&gt;","text":"<p>template &lt;typename U, typename E, typename Arg&gt;</p> <p>ClassList &gt; details &gt; ok &gt; impl &gt; Map&lt; Result&lt; U, E &gt;(Arg)&gt;</p>"},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01Result_3_01U_00_01E_01_4_07Arg_08_4/#public-static-functions","title":"Public Static Functions","text":"Type Name Result&lt; U, E &gt; map (const Result&lt; T, E &gt; &amp; result, Func func)"},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01Result_3_01U_00_01E_01_4_07Arg_08_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01Result_3_01U_00_01E_01_4_07Arg_08_4/#function-map","title":"function map","text":"<pre><code>template&lt;typename T, typename Func&gt;\nstatic inline Result &lt; U, E &gt; details::ok::impl::Map&lt; Result&lt; U, E &gt;(Arg)&gt;::map (\n    const Result &lt; T, E &gt; &amp; result,\n    Func func\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01Result_3_01U_00_01E_01_4_07void_08_4/","title":"Struct details::ok::impl::Map&lt; Result&lt; U, E &gt;(void)&gt;","text":"<p>template &lt;typename U, typename E&gt;</p> <p>ClassList &gt; details &gt; ok &gt; impl &gt; Map&lt; Result&lt; U, E &gt;(void)&gt;</p>"},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01Result_3_01U_00_01E_01_4_07void_08_4/#public-static-functions","title":"Public Static Functions","text":"Type Name Result&lt; U, E &gt; map (const Result&lt; T, E &gt; &amp; result, Func func)"},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01Result_3_01U_00_01E_01_4_07void_08_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01Result_3_01U_00_01E_01_4_07void_08_4/#function-map","title":"function map","text":"<pre><code>template&lt;typename T, typename Func&gt;\nstatic inline Result &lt; U, E &gt; details::ok::impl::Map&lt; Result&lt; U, E &gt;(void)&gt;::map (\n    const Result &lt; T, E &gt; &amp; result,\n    Func func\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01Ret_07Arg_08_4/","title":"Struct details::ok::impl::Map&lt; Ret(Arg)&gt;","text":"<p>template &lt;typename Ret, typename Arg&gt;</p> <p>ClassList &gt; details &gt; ok &gt; impl &gt; Map&lt; Ret(Arg)&gt;</p> <p>Inherited by the following classes: details::ok::impl::Map&lt; Ret(Cls::*)(Arg) const &gt;,  details::ok::impl::Map&lt; Ret(Cls::*)(Arg)&gt;</p>"},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01Ret_07Arg_08_4/#public-static-functions","title":"Public Static Functions","text":"Type Name Result&lt; Ret, E &gt; map (const Result&lt; T, E &gt; &amp; result, Func func)"},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01Ret_07Arg_08_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01Ret_07Arg_08_4/#function-map","title":"function map","text":"<pre><code>template&lt;typename T, typename E, typename Func&gt;\nstatic inline Result &lt; Ret, E &gt; details::ok::impl::Map&lt; Ret(Arg)&gt;::map (\n    const Result &lt; T, E &gt; &amp; result,\n    Func func\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01Ret_07Cls_1_1_5_08_07Arg_08_01const_01_4/","title":"Struct details::ok::impl::Map&lt; Ret(Cls::*)(Arg) const &gt;","text":"<p>template &lt;typename Ret, typename Cls, typename Arg&gt;</p> <p>ClassList &gt; details &gt; ok &gt; impl &gt; Map&lt; Ret(Cls::*)(Arg) const &gt;</p> <p>Inherits the following classes: details::ok::impl::Map&lt; Ret(Arg)&gt;</p>"},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01Ret_07Cls_1_1_5_08_07Arg_08_01const_01_4/#public-static-functions-inherited-from-detailsokimplmap-retarg","title":"Public Static Functions inherited from details::ok::impl::Map&lt; Ret(Arg)&gt;","text":"<p>See details::ok::impl::Map&lt; Ret(Arg)&gt;</p> Type Name Result&lt; Ret, E &gt; map (const Result&lt; T, E &gt; &amp; result, Func func)  <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01Ret_07Cls_1_1_5_08_07Arg_08_4/","title":"Struct details::ok::impl::Map&lt; Ret(Cls::*)(Arg)&gt;","text":"<p>template &lt;typename Ret, typename Cls, typename Arg&gt;</p> <p>ClassList &gt; details &gt; ok &gt; impl &gt; Map&lt; Ret(Cls::*)(Arg)&gt;</p> <p>Inherits the following classes: details::ok::impl::Map&lt; Ret(Arg)&gt;</p>"},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01Ret_07Cls_1_1_5_08_07Arg_08_4/#public-static-functions-inherited-from-detailsokimplmap-retarg","title":"Public Static Functions inherited from details::ok::impl::Map&lt; Ret(Arg)&gt;","text":"<p>See details::ok::impl::Map&lt; Ret(Arg)&gt;</p> Type Name Result&lt; Ret, E &gt; map (const Result&lt; T, E &gt; &amp; result, Func func)  <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01Ret_07void_08_4/","title":"Struct details::ok::impl::Map&lt; Ret(void)&gt;","text":"<p>template &lt;typename Ret&gt;</p> <p>ClassList &gt; details &gt; ok &gt; impl &gt; Map&lt; Ret(void)&gt;</p>"},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01Ret_07void_08_4/#public-static-functions","title":"Public Static Functions","text":"Type Name Result&lt; Ret, E &gt; map (const Result&lt; T, E &gt; &amp; result, Func func)"},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01Ret_07void_08_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01Ret_07void_08_4/#function-map","title":"function map","text":"<pre><code>template&lt;typename T, typename E, typename Func&gt;\nstatic inline Result &lt; Ret, E &gt; details::ok::impl::Map&lt; Ret(void)&gt;::map (\n    const Result &lt; T, E &gt; &amp; result,\n    Func func\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01void_07Arg_08_4/","title":"Struct details::ok::impl::Map&lt; void(Arg)&gt;","text":"<p>template &lt;typename Arg&gt;</p> <p>ClassList &gt; details &gt; ok &gt; impl &gt; Map&lt; void(Arg)&gt;</p>"},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01void_07Arg_08_4/#public-static-functions","title":"Public Static Functions","text":"Type Name Result&lt; void, E &gt; map (const Result&lt; T, E &gt; &amp; result, Func func)"},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01void_07Arg_08_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01void_07Arg_08_4/#function-map","title":"function map","text":"<pre><code>template&lt;typename T, typename E, typename Func&gt;\nstatic inline Result &lt; void, E &gt; details::ok::impl::Map&lt; void(Arg)&gt;::map (\n    const Result &lt; T, E &gt; &amp; result,\n    Func func\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01void_07void_08_4/","title":"Struct details::ok::impl::Map&lt; void(void)&gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; details &gt; ok &gt; impl &gt; Map&lt; void(void)&gt;</p>"},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01void_07void_08_4/#public-static-functions","title":"Public Static Functions","text":"Type Name Result&lt; void, E &gt; map (const Result&lt; T, E &gt; &amp; result, Func func)"},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01void_07void_08_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"dictionary/structdetails_1_1ok_1_1impl_1_1Map_3_01void_07void_08_4/#function-map","title":"function map","text":"<pre><code>template&lt;typename T, typename E, typename Func&gt;\nstatic inline Result &lt; void, E &gt; details::ok::impl::Map&lt; void(void)&gt;::map (\n    const Result &lt; T, E &gt; &amp; result,\n    Func func\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1ok__tag/","title":"Struct details::ok_tag","text":"<p>ClassList &gt; details &gt; ok_tag</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1result__of/","title":"Struct details::result_of","text":"<p>template &lt;typename Func&gt;</p> <p>ClassList &gt; details &gt; result_of</p> <p>Inherits the following classes: details::impl::result_of</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1result__of_3_01Ret_07_5_08_07Args_8_8_8_08_4/","title":"Struct details::result_of&lt; Ret(*)(Args...)&gt;","text":"<p>template &lt;typename Ret, typename... Args&gt;</p> <p>ClassList &gt; details &gt; result_of&lt; Ret(*)(Args...)&gt;</p>"},{"location":"dictionary/structdetails_1_1result__of_3_01Ret_07_5_08_07Args_8_8_8_08_4/#public-types","title":"Public Types","text":"Type Name typedef Ret type"},{"location":"dictionary/structdetails_1_1result__of_3_01Ret_07_5_08_07Args_8_8_8_08_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"dictionary/structdetails_1_1result__of_3_01Ret_07_5_08_07Args_8_8_8_08_4/#typedef-type","title":"typedef type","text":"<pre><code>typedef Ret details::result_of&lt; Ret(*)(Args...)&gt;::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1result__of_3_01Ret_07Cls_1_1_5_08_07Args_8_8_8_08_01const_01_4/","title":"Struct details::result_of&lt; Ret(Cls::*)(Args...) const &gt;","text":"<p>template &lt;typename Ret, typename Cls, typename... Args&gt;</p> <p>ClassList &gt; details &gt; result_of&lt; Ret(Cls::*)(Args...) const &gt;</p>"},{"location":"dictionary/structdetails_1_1result__of_3_01Ret_07Cls_1_1_5_08_07Args_8_8_8_08_01const_01_4/#public-types","title":"Public Types","text":"Type Name typedef Ret type"},{"location":"dictionary/structdetails_1_1result__of_3_01Ret_07Cls_1_1_5_08_07Args_8_8_8_08_01const_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"dictionary/structdetails_1_1result__of_3_01Ret_07Cls_1_1_5_08_07Args_8_8_8_08_01const_01_4/#typedef-type","title":"typedef type","text":"<pre><code>typedef Ret details::result_of&lt; Ret(Cls::*)(Args...) const &gt;::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structdetails_1_1void__t/","title":"Struct details::void_t","text":"<p>template &lt;typename...&gt;</p> <p>ClassList &gt; details &gt; void_t</p>"},{"location":"dictionary/structdetails_1_1void__t/#public-types","title":"Public Types","text":"Type Name typedef void type"},{"location":"dictionary/structdetails_1_1void__t/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"dictionary/structdetails_1_1void__t/#typedef-type","title":"typedef type","text":"<pre><code>typedef void details::void_t&lt;... &gt;::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/namespaceqqmusic/","title":"Namespace qqmusic","text":"<p>Namespace List &gt; qqmusic</p>"},{"location":"dictionary/namespaceqqmusic/#namespaces","title":"Namespaces","text":"Type Name namespace crypto namespace details namespace utils \u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027"},{"location":"dictionary/namespaceqqmusic/#classes","title":"Classes","text":"Type Name class BaseMediaFileType \u5a92\u4f53\u6587\u4ef6\u7c7b\u578b\u57fa\u7c7b class EncryptedSongFileType \u52a0\u5bc6\u6b4c\u66f2\u6587\u4ef6\u7c7b\u578b struct Lyric \u6b4c\u8bcd struct MvUrl Mv url\u5c01\u88dd struct PhoneLoginResult struct QRCode \u4e8c\u7ef4\u7801\u4fe1\u606f class QRCodeLoginEvent \u4e8c\u7ef4\u7801\u767b\u9646\u4e8b\u4ef6 struct QRCodeLoginResult \u4e8c\u7ef4\u7801\u767b\u9646\u7ed3\u679c\u5c01\u88c5 class SongFileType \u672a\u52a0\u5bc6\u7684\u6b4c\u66f2\u6587\u4ef6\u7c7b\u679a\u4e3e struct SongInfo class TabType \u6807\u7b7e\u7c7b"},{"location":"dictionary/namespaceqqmusic/#public-types","title":"Public Types","text":"Type Name enum int AreaType \u533a\u57df\u7c7b\u578b\u679a\u4e3e enum int CoverSize \u5c01\u9762\u7c7b\u578b\u679a\u4e3e enum int GenderType \u6027\u522b\u7c7b\u578b\u679a\u4e3e enum int GenreType \u98ce\u683c\u7c7b\u578b\u679a\u4e3e enum int IndexType \u7d22\u5f15\u7c7b\u578b\u679a\u4e3e, \u6309\u9996\u5b57\u6bcd\u7b5b\u9009\u65f6\u9700\u8981 enum int PhoneLoginEvent \u624b\u673a\u53f7\u767b\u9646\u72b6\u6001\u679a\u4e3e enum QRLoginType \u767b\u9646\u7c7b\u578b\u679a\u4e3e typedef Result&lt; T, qqmusic::utils::Exception &gt; Result Rust\u98ce\u683c\u7684\u8fd4\u56de\u7ed3\u679c\u5c01\u88c5, \u6b63\u786e\u7ed3\u679c\u548c\u5f02\u5e38\u5171\u7528\u540c\u4e00\u4e2a\u6e20\u9053\u8fd4\u56de enum unsigned SearchType \u641c\u7d22\u7c7b\u578b\u679a\u4e3e typedef boost::asio::awaitable&lt; T &gt; Task \u901a\u7528\u5f02\u6b65\u4efb\u52a1"},{"location":"dictionary/namespaceqqmusic/#public-functions","title":"Public Functions","text":"Type Name qqmusic::Task&lt; qqmusic::Result&lt; QRCodeLoginResult &gt; &gt; check_qq_qr (QRCode &amp; qrc) \u68c0\u67e5QQ\u4e8c\u7ef4\u7801\u72b6\u6001 qqmusic::Task&lt; qqmusic::Result&lt; QRCodeLoginResult &gt; &gt; check_wx_qr (QRCode &amp; qrc) \u68c0\u67e5\u5fae\u4fe1\u4e8c\u7ef4\u7801\u72b6\u6001 Task&lt; Result&lt; nlohmann::json &gt; &gt; general_search (std::string_view keyword, unsigned num=15, unsigned page=1, bool highlight=true) \u7efc\u5408\u641c\u7d22 std::string get_album_cover_url (std::string_view mid, CoverSize size) \u83b7\u53d6\u4e13\u8f91\u5c01\u9762url Task&lt; Result&lt; nlohmann::json &gt; &gt; get_album_detail (std::string_view album_mid) \u4ecemid\u83b7\u53d6\u4e13\u8f91\u4fe1\u606f Task&lt; Result&lt; nlohmann::json &gt; &gt; get_album_detail (uint64_t album_id) \u4eceid\u83b7\u53d6\u4e13\u8f91\u4fe1\u606f Task&lt; Result&lt; nlohmann::json &gt; &gt; get_album_list (std::string_view mid, unsigned number=10, unsigned begin=0) \u83b7\u53d6\u6b4c\u624b\u4e13\u8f91\u5217\u8868 Task&lt; Result&lt; nlohmann::json &gt; &gt; get_album_list_all (std::string_view mid) \u83b7\u53d6\u6b4c\u624b\u6240\u6709\u4e13\u8f91 Task&lt; Result&lt; nlohmann::json &gt; &gt; get_album_songs (std::string_view album_mid, unsigned int num=10, unsigned int page=1) \u4ecemid\u83b7\u53d6\u4e13\u8f91\u6b4c\u66f2\u5217\u8868 Task&lt; Result&lt; nlohmann::json &gt; &gt; get_album_songs (uint64_t album_id, unsigned int num=10, unsigned int page=1) \u4eceid\u83b7\u53d6\u4e13\u8f91\u6b4c\u66f2\u5217\u8868 Task&lt; Result&lt; nlohmann::json &gt; &gt; get_created_songlist (uint64_t musicid, std::optional&lt; utils::Credential &gt; credential=std::nullopt) \u83b7\u53d6\u521b\u5efa\u7684\u6b4c\u5355\u5217\u8868 Task&lt; Result&lt; std::string &gt; &gt; get_euin (uint64_t musicid) \u7531musicid\u83b7\u53d6euin Task&lt; Result&lt; nlohmann::json &gt; &gt; get_fans (std::string_view euin, unsigned page=1, unsigned num=10, std::optional&lt; utils::Credential &gt; credential=std::nullopt) \u7c89\u4e1d\u6570\u91cf Task&lt; Result&lt; nlohmann::json &gt; &gt; get_fav_album (std::string_view euin, unsigned page=1, unsigned num=10, std::optional&lt; utils::Credential &gt; credential=std::nullopt) \u83b7\u53d6\u6536\u85cf\u4e13\u8f91 Task&lt; Result&lt; nlohmann::json &gt; &gt; get_fav_mv (std::string_view euin, unsigned page=1, unsigned num=10, std::optional&lt; utils::Credential &gt; credential=std::nullopt) \u83b7\u53d6\u6536\u85cfMV Task&lt; Result&lt; nlohmann::json &gt; &gt; get_fav_num (std::span&lt; uint64_t &gt; id_list, bool readable=true) \u83b7\u53d6\u6b4c\u66f2\u7684\u6536\u85cf\u91cf Task&lt; Result&lt; nlohmann::json &gt; &gt; get_fav_song (std::string_view euin, unsigned page=1, unsigned num=10, std::optional&lt; utils::Credential &gt; credential=std::nullopt) \u83b7\u53d6\u6536\u85cf\u6b4c\u66f2 Task&lt; Result&lt; nlohmann::json &gt; &gt; get_fav_songlist (std::string_view euin, unsigned page=1, unsigned num=10, std::optional&lt; utils::Credential &gt; credential=std::nullopt) \u83b7\u53d6\u6536\u85cf\u6b4c\u5355 Task&lt; Result&lt; nlohmann::json &gt; &gt; get_follow_singers (std::string_view euin, unsigned page=1, unsigned num=10, std::optional&lt; utils::Credential &gt; credential=std::nullopt) \u83b7\u53d6\u5173\u6ce8\u7684\u6b4c\u624b\u5217\u8868 Task&lt; Result&lt; nlohmann::json &gt; &gt; get_follow_usr (std::string_view euin, unsigned page=1, unsigned num=10, std::optional&lt; utils::Credential &gt; credential=std::nullopt) \u83b7\u53d6\u5173\u6ce8\u7528\u6237\u5217\u8868 Task&lt; Result&lt; nlohmann::json &gt; &gt; get_friend_list (unsigned page=1, unsigned num=10, std::optional&lt; utils::Credential &gt; credential=std::nullopt) \u83b7\u53d6\u597d\u53cb\u5217\u8868 Task&lt; Result&lt; nlohmann::json &gt; &gt; get_homepage (std::string_view euin, std::optional&lt; utils::Credential &gt; credential=std::nullopt) \u83b7\u53d6\u7528\u6237\u4e3b\u9875\u4fe1\u606f Task&lt; Result&lt; nlohmann::json &gt; &gt; get_labels (uint64_t songid) \u83b7\u53d6\u6b4c\u66f2\u6807\u7b7e\u4fe1\u606f Task&lt; Result&lt; Lyric &gt; &gt; get_lyric (std::string_view mid, bool qrc=false, bool trans=false, bool roma=false) \u83b7\u53d6\u6b4c\u66f2\u7684\u6b4c\u8bcd Task&lt; Result&lt; Lyric &gt; &gt; get_lyric (uint64_t id, bool qrc=false, bool trans=false, bool roma=false) \u83b7\u53d6\u6b4c\u66f2\u7684\u6b4c\u8bcd Task&lt; Result&lt; nlohmann::json &gt; &gt; get_music_gene (std::string_view euin, std::optional&lt; utils::Credential &gt; credential=std::nullopt) \u83b7\u53d6\u97f3\u4e50\u57fa\u56e0 Task&lt; Result&lt; uint64_t &gt; &gt; get_musicid (std::string_view euin) \u7531euin\u83b7\u53d6musicid Task&lt; Result&lt; nlohmann::json &gt; &gt; get_mv_detail (std::span&lt; std::string &gt; vids) \u83b7\u53d6\u4e00\u7ec4MV\u7684\u4fe1\u606f Task&lt; Result&lt; nlohmann::json &gt; &gt; get_mv_list (std::string_view mid, unsigned number=10, unsigned begin=0) \u83b7\u53d6\u6b4c\u624bMV\u5217\u8868 Task&lt; Result&lt; nlohmann::json &gt; &gt; get_mv_list_all (std::string_view mid) \u83b7\u53d6\u6b4c\u624b\u6240\u6709MV Task&lt; Result&lt; std::vector&lt; MvUrl &gt; &gt; &gt; get_mv_urls (std::span&lt; std::string &gt; vids) \u83b7\u53d6mv url Task&lt; Result&lt; nlohmann::json &gt; &gt; get_other_version (std::string_view mid) \u83b7\u53d6\u540c\u540d\u6b4c\u66f2\u7684\u5176\u4ed6\u7248\u672c Task&lt; Result&lt; nlohmann::json &gt; &gt; get_other_version (uint64_t id) \u83b7\u53d6\u540c\u540d\u6b4c\u66f2\u7684\u5176\u4ed6\u7248\u672c Task&lt; Result&lt; nlohmann::json &gt; &gt; get_producer_info (std::string_view mid) \u83b7\u53d6\u6b4c\u66f2\u5236\u4f5c\u8005\u4fe1\u606f Task&lt; Result&lt; nlohmann::json &gt; &gt; get_producer_info (uint64_t id) \u83b7\u53d6\u6b4c\u66f2\u5236\u4f5c\u8005\u4fe1\u606f qqmusic::Task&lt; qqmusic::Result&lt; QRCode &gt; &gt; get_qrcode (QRLoginType login_type) \u83b7\u53d6\u767b\u9646\u4e8c\u7ef4\u7801 Task&lt; Result&lt; nlohmann::json &gt; &gt; get_related_mv (uint64_t songid, std::optional&lt; std::string &gt; last_mvid=std::nullopt) \u83b7\u53d6\u76f8\u5173MV Task&lt; Result&lt; nlohmann::json &gt; &gt; get_related_songlist (uint64_t songid) \u83b7\u53d6\u76f8\u5173\u6b4c\u5355\u5217\u8868 Task&lt; Result&lt; nlohmann::json &gt; &gt; get_sheet (std::string_view mid) \u83b7\u53d6\u66f2\u8c31\u4fe1\u606f Task&lt; Result&lt; nlohmann::json &gt; &gt; get_similar_singers (std::string_view mid, unsigned number=10) \u83b7\u53d6\u76f8\u4f3c\u6b4c\u624b\u4fe1\u606f Task&lt; Result&lt; nlohmann::json &gt; &gt; get_similar_songs (uint64_t songid) \u83b7\u53d6\u76f8\u4f3c\u6b4c\u66f2\u5217\u8868 Task&lt; Result&lt; nlohmann::json &gt; &gt; get_singer_desc (std::span&lt; std::string &gt; mids, unsigned number=10) \u83b7\u53d6\u591a\u4e2a\u6b4c\u624b\u7684\u7b80\u4ecb Task&lt; Result&lt; nlohmann::json &gt; &gt; get_singer_info (std::string_view mid) \u83b7\u53d6\u6b4c\u624b\u57fa\u672c\u4fe1\u606f Task&lt; Result&lt; nlohmann::json &gt; &gt; get_singer_list (AreaType area=AreaType::ALL, GenderType gender=GenderType::ALL, GenreType genre=GenreType::ALL) \u83b7\u53d6\u7b26\u5408\u7b5b\u9009\u6761\u4ef6\u7684\u6b4c\u624b\u4fe1\u606f\u8868\u5355 Task&lt; Result&lt; nlohmann::json &gt; &gt; get_singer_list_index (AreaType area=AreaType::ALL, GenderType gender=GenderType::ALL, GenreType genre=GenreType::ALL, IndexType index=IndexType::ALL, unsigned sin=0, unsigned cur_page=1) \u7b5b\u9009\u83b7\u5f97\u6b4c\u66f2\u6b4c\u5355\u539f\u59cb\u6570\u636e Task&lt; Result&lt; nlohmann::json &gt; &gt; get_singer_list_index_all (AreaType area=AreaType::ALL, GenderType gender=GenderType::ALL, GenreType genre=GenreType::ALL, IndexType index=IndexType::ALL) \u83b7\u53d6\u6240\u6709\u7b26\u5408\u6761\u4ef6\u7684\u6b4c\u5355\u539f\u59cb\u6570\u636e Task&lt; Result&lt; nlohmann::json &gt; &gt; get_song_detail (std::string_view mid) \u83b7\u53d6\u6b4c\u66f2\u8be6\u7ec6\u4fe1\u606f Task&lt; Result&lt; nlohmann::json &gt; &gt; get_song_detail (uint64_t id) \u83b7\u53d6\u6b4c\u66f2\u8be6\u7ec6\u4fe1\u606f Task&lt; Result&lt; std::vector&lt; SongInfo &gt; &gt; &gt; get_song_urls (std::span&lt; std::string &gt; mids, std::unique_ptr&lt; BaseMediaFileType &gt; file_type=std::make_unique&lt; SongFileType &gt;(), std::optional&lt; utils::Credential &gt; credential=std::nullopt) \u6279\u91cf\u83b7\u53d6\u6b4c\u66f2\u64ad\u653e\u94fe\u63a5 Task&lt; Result&lt; nlohmann::json &gt; &gt; get_songlist (uint64_t dissid, unsigned dirid=0) \u83b7\u53d6\u6b4c\u5355\u5217\u8868 Task&lt; Result&lt; nlohmann::json &gt; &gt; get_songlist_detail (uint64_t dissid, unsigned dirid=0, unsigned num=10, unsigned page=1, bool only_song=false, bool tag=true, bool user_info=true) \u83b7\u53d6\u6b4c\u5355\u4fe1\u606f Task&lt; Result&lt; nlohmann::json &gt; &gt; get_songs_list (std::string_view mid, unsigned num=10, unsigned begin=0) \u83b7\u53d6\u6b4c\u624b\u6b4c\u66f2\u539f\u59cb\u6570\u636e Task&lt; Result&lt; nlohmann::json &gt; &gt; get_songs_list_all (std::string_view mid) \u83b7\u53d6\u6b4c\u624b\u7684\u6240\u6709\u6b4c\u66f2 Task&lt; Result&lt; nlohmann::json &gt; &gt; get_tab_detail (std::string_view mid, TabType type, unsigned page=1, unsigned num=10) \u8fd4\u56de\u6807\u7b7e\u8be6\u7ec6\u4fe1\u606f Task&lt; Result&lt; nlohmann::json &gt; &gt; get_toplist_category () \u83b7\u53d6\u6240\u6709\u6392\u884c\u699c Task&lt; Result&lt; nlohmann::json &gt; &gt; get_toplist_item_detail (unsigned top_id, unsigned num=10, unsigned page=1, bool tag=true) \u83b7\u53d6\u6392\u884c\u699c\u6761\u76ee\u4fe1\u606f Task&lt; Result&lt; std::string &gt; &gt; get_try_url (std::string_view mid, std::string_view vs) \u83b7\u53d6\u8bd5\u542c\u94fe\u63a5 Task&lt; Result&lt; nlohmann::json &gt; &gt; get_vip_info (std::optional&lt; utils::Credential &gt; credential=std::nullopt) \u83b7\u53d6\u5f53\u524d\u8d26\u53f7vip\u4fe1\u606f Task&lt; Result&lt; nlohmann::json &gt; &gt; hotkey () \u83b7\u53d6\u641c\u7d22\u70ed\u8bcd Task&lt; Result&lt; nlohmann::json &gt; &gt; keyword_complete (std::string_view keyword) \u641c\u7d22\u8bcd\u8054\u60f3\u8865\u5168 qqmusic::Task&lt; qqmusic::Result&lt; utils::Credential &gt; &gt; phone_authorize (std::string_view phone, std::string_view auth_code, std::string_view country_code=\"86\") \u624b\u673a\u53f7\u8ba4\u8bc1 Task&lt; Result&lt; nlohmann::json &gt; &gt; query_song (std::span&lt; std::string &gt; mids) \u6279\u91cf\u67e5\u8be2\u6b4c\u66f2\u4fe1\u606f Task&lt; Result&lt; nlohmann::json &gt; &gt; query_song (std::span&lt; uint64_t &gt; ids) \u6279\u91cf\u67e5\u8be2\u6b4c\u66f2\u4fe1\u606f Task&lt; Result&lt; nlohmann::json &gt; &gt; quick_search (std::string_view keyword) \u5feb\u901f\u641c\u7d22 Task&lt; Result&lt; nlohmann::json &gt; &gt; search_by_type (std::string_view keyword, SearchType type=SearchType::SONG, unsigned num_per_page=10, unsigned page=1, bool highlight=true) \u6309\u7c7b\u578b\u641c\u7d22 qqmusic::Task&lt; qqmusic::Result&lt; PhoneLoginResult &gt; &gt; send_authcode (std::string_view phone, std::string_view country_code=\"86\") \u5411\u6307\u5b9a\u624b\u673a\u53f7\u53d1\u9001\u9a8c\u8bc1\u7801 Task&lt; Result&lt; bool &gt; &gt; songlist_add_songs (uint64_t dirid, std::span&lt; uint64_t &gt; song_ids, std::optional&lt; utils::Credential &gt; credential=std::nullopt) \u5411\u6b4c\u5355\u5185\u6dfb\u52a0\u6b4c\u66f2 Task&lt; Result&lt; nlohmann::json &gt; &gt; songlist_create (std::string_view dirname, std::optional&lt; utils::Credential &gt; credential=std::nullopt) \u521b\u5efa\u6b4c\u5355 Task&lt; Result&lt; bool &gt; &gt; songlist_delete (uint64_t dirid, std::optional&lt; utils::Credential &gt; credential=std::nullopt) \u5220\u9664\u6b4c\u5355 Task&lt; Result&lt; bool &gt; &gt; songlist_delete_songs (uint64_t dirid, std::span&lt; uint64_t &gt; song_ids, std::optional&lt; utils::Credential &gt; credential=std::nullopt) \u5220\u9664\u6b4c\u5355\u5185\u6307\u5b9a\u6b4c\u66f2"},{"location":"dictionary/namespaceqqmusic/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"dictionary/namespaceqqmusic/#enum-areatype","title":"enum AreaType","text":"<p>\u533a\u57df\u7c7b\u578b\u679a\u4e3e <pre><code>enum qqmusic::AreaType {\n    ALL = -100,\n    CHINA = 200,\n    TAIWAN = 2,\n    AMERICA = 5,\n    JAPAN = 4,\n    KOREA = 3\n};\n</code></pre></p>"},{"location":"dictionary/namespaceqqmusic/#enum-coversize","title":"enum CoverSize","text":"<p>\u5c01\u9762\u7c7b\u578b\u679a\u4e3e <pre><code>enum qqmusic::CoverSize {\n    SMALL = 150,\n    DEFAULT = 300,\n    MIDIUM = 500,\n    LARGE = 800\n};\n</code></pre></p>"},{"location":"dictionary/namespaceqqmusic/#enum-gendertype","title":"enum GenderType","text":"<p>\u6027\u522b\u7c7b\u578b\u679a\u4e3e <pre><code>enum qqmusic::GenderType {\n    ALL = -100,\n    MALE = 0,\n    FEMALE = 1,\n    GROUP = 2\n};\n</code></pre></p>"},{"location":"dictionary/namespaceqqmusic/#enum-genretype","title":"enum GenreType","text":"<p>\u98ce\u683c\u7c7b\u578b\u679a\u4e3e <pre><code>enum qqmusic::GenreType {\n    ALL = -100,\n    POP = 7,\n    RAP = 3,\n    CHINESE_STYLE = 19,\n    ROCK = 4,\n    ELECTRONIC = 2,\n    FOLK = 8,\n    R_AND_B = 11,\n    ETHNIC = 37,\n    LIGHT_MUSIC = 93,\n    JAZZ = 14,\n    CLASSICAL = 33,\n    COUNTRY = 13,\n    BLUES = 10\n};\n</code></pre></p>"},{"location":"dictionary/namespaceqqmusic/#enum-indextype","title":"enum IndexType","text":"<p>\u7d22\u5f15\u7c7b\u578b\u679a\u4e3e, \u6309\u9996\u5b57\u6bcd\u7b5b\u9009\u65f6\u9700\u8981 <pre><code>enum qqmusic::IndexType {\n    A = 1,\n    B,\n    C,\n    D,\n    E,\n    F,\n    G,\n    H,\n    I,\n    J,\n    K,\n    L,\n    M,\n    N,\n    O,\n    P,\n    Q,\n    R,\n    S,\n    T,\n    U,\n    V,\n    W,\n    X,\n    Y,\n    Z,\n    HASH,\n    ALL = -100\n};\n</code></pre></p>"},{"location":"dictionary/namespaceqqmusic/#enum-phoneloginevent","title":"enum PhoneLoginEvent","text":"<p>\u624b\u673a\u53f7\u767b\u9646\u72b6\u6001\u679a\u4e3e <pre><code>enum qqmusic::PhoneLoginEvent {\n    SEND = 0,\n    CAPTCHA = 20276,\n    FREQUENCY = 100001,\n    OTHER = -1\n};\n</code></pre></p>"},{"location":"dictionary/namespaceqqmusic/#enum-qrlogintype","title":"enum QRLoginType","text":"<p>\u767b\u9646\u7c7b\u578b\u679a\u4e3e <pre><code>enum qqmusic::QRLoginType {\n    QQ,\n    WX\n};\n</code></pre></p>"},{"location":"dictionary/namespaceqqmusic/#typedef-result","title":"typedef Result","text":"<p>Rust\u98ce\u683c\u7684\u8fd4\u56de\u7ed3\u679c\u5c01\u88c5, \u6b63\u786e\u7ed3\u679c\u548c\u5f02\u5e38\u5171\u7528\u540c\u4e00\u4e2a\u6e20\u9053\u8fd4\u56de <pre><code>using qqmusic::Result = typedef Result&lt;T, qqmusic::utils::Exception&gt;;\n</code></pre></p> <p>\u4f7f\u7528\u65b9\u6cd5:  <pre><code>Result&lt;int&gt; func(int a);\n\nint main() {\n    auto res = func(114514);\n    if (res.isErr()) {\n        // error occurred in func, unwrap the error\n        std::cout &lt;&lt; res.unwrapErr().what() &lt;&lt; std::endl;\n    }\n    // func returned normally, unwrap the result\n    int x = res.unwrap();\n    return 0;\n}\n</code></pre></p>"},{"location":"dictionary/namespaceqqmusic/#enum-searchtype","title":"enum SearchType","text":"<p>\u641c\u7d22\u7c7b\u578b\u679a\u4e3e <pre><code>enum qqmusic::SearchType {\n    SONG = 0,\n    SINGER = 1,\n    ALBUM = 2,\n    SONG_LIST = 3,\n    MV = 4,\n    LYRIC = 7,\n    USER = 8,\n    AUDIO_ALBUM = 15,\n    AUDIO = 18\n};\n</code></pre></p>"},{"location":"dictionary/namespaceqqmusic/#typedef-task","title":"typedef Task","text":"<p>\u901a\u7528\u5f02\u6b65\u4efb\u52a1 <pre><code>using qqmusic::Task = typedef boost::asio::awaitable&lt;T&gt;;\n</code></pre></p>"},{"location":"dictionary/namespaceqqmusic/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/namespaceqqmusic/#function-check_qq_qr","title":"function check_qq_qr","text":"<p>\u68c0\u67e5QQ\u4e8c\u7ef4\u7801\u72b6\u6001 <pre><code>qqmusic::Task&lt; qqmusic::Result&lt; QRCodeLoginResult &gt; &gt; qqmusic::check_qq_qr (\n    QRCode &amp; qrc\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>qrc</code> QQ\u4e8c\u7ef4\u7801</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786e\u7ed3\u679c\u7684<code>Task&lt; Result &lt; QRCodeLoginResult &gt;&gt;</code>. \u5982\u679c\u767b\u9646\u6210\u529f\u4f1a\u5305\u542bCredential</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-check_wx_qr","title":"function check_wx_qr","text":"<p>\u68c0\u67e5\u5fae\u4fe1\u4e8c\u7ef4\u7801\u72b6\u6001 <pre><code>qqmusic::Task&lt; qqmusic::Result&lt; QRCodeLoginResult &gt; &gt; qqmusic::check_wx_qr (\n    QRCode &amp; qrc\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>qrc</code> \u5fae\u4fe1\u4e8c\u7ef4\u7801</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786e\u7ed3\u679c\u7684<code>Task&lt; Result &lt; QRCodeLoginResult &gt;&gt;</code>. \u5982\u679c\u767b\u9646\u6210\u529f\u4f1a\u5305\u542bCredential</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-general_search","title":"function general_search","text":"<p>\u7efc\u5408\u641c\u7d22 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::general_search (\n    std::string_view keyword,\n    unsigned num=15,\n    unsigned page=1,\n    bool highlight=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>keyword</code> \u641c\u7d22\u8bcd </li> <li><code>num</code> \u6bcf\u9875\u7ed3\u679c\u6570, \u9ed8\u8ba4<code>15</code> </li> <li><code>page</code> \u9875\u6570, \u9ed8\u8ba4<code>1</code> </li> <li><code>highlight</code> \u662f\u5426\u9ad8\u4eae, \u9ed8\u8ba4<code>true</code></li> </ul> <p>Returns:</p> <p>Json\u683c\u5f0f\u641c\u7d22\u7ed3\u679c</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_album_cover_url","title":"function get_album_cover_url","text":"<p>\u83b7\u53d6\u4e13\u8f91\u5c01\u9762url <pre><code>std::string qqmusic::get_album_cover_url (\n    std::string_view mid,\n    CoverSize size\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u66f2mid </li> <li><code>size</code> \u6b4c\u66f2\u5c01\u9762\u5c3a\u5bf8</li> </ul> <p>Returns:</p> <p>std::string\u683c\u5f0f\u6b4c\u66f2\u5c01\u9762\u7684url </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_album_detail","title":"function get_album_detail","text":"<p>\u4ecemid\u83b7\u53d6\u4e13\u8f91\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_album_detail (\n    std::string_view album_mid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>album_mid</code> \u4e13\u8f91mid</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_album_detail_1","title":"function get_album_detail","text":"<p>\u4eceid\u83b7\u53d6\u4e13\u8f91\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_album_detail (\n    uint64_t album_id\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>album_id</code> \u4e13\u8f91id</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_album_list","title":"function get_album_list","text":"<p>\u83b7\u53d6\u6b4c\u624b\u4e13\u8f91\u5217\u8868 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_album_list (\n    std::string_view mid,\n    unsigned number=10,\n    unsigned begin=0\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u624bmid </li> <li><code>number</code> \u5355\u6b21\u83b7\u53d6\u6570\u636e\u91cf, \u9ed8\u8ba4<code>10</code> </li> <li><code>begin</code> \u4ece\u7b2c\u51e0\u4e2a\u5f00\u59cb</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_album_list_all","title":"function get_album_list_all","text":"<p>\u83b7\u53d6\u6b4c\u624b\u6240\u6709\u4e13\u8f91 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_album_list_all (\n    std::string_view mid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u624bmid</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_album_songs","title":"function get_album_songs","text":"<p>\u4ecemid\u83b7\u53d6\u4e13\u8f91\u6b4c\u66f2\u5217\u8868 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_album_songs (\n    std::string_view album_mid,\n    unsigned int num=10,\n    unsigned int page=1\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>album_mid</code> \u4e13\u8f91mid</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_album_songs_1","title":"function get_album_songs","text":"<p>\u4eceid\u83b7\u53d6\u4e13\u8f91\u6b4c\u66f2\u5217\u8868 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_album_songs (\n    uint64_t album_id,\n    unsigned int num=10,\n    unsigned int page=1\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>album_id</code> \u4e13\u8f91id</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_created_songlist","title":"function get_created_songlist","text":"<p>\u83b7\u53d6\u521b\u5efa\u7684\u6b4c\u5355\u5217\u8868 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_created_songlist (\n    uint64_t musicid,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>musicid</code> </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f </li> </ul>"},{"location":"dictionary/namespaceqqmusic/#function-get_euin","title":"function get_euin","text":"<p>\u7531musicid\u83b7\u53d6euin <pre><code>Task&lt; Result &lt; std::string &gt; &gt; qqmusic::get_euin (\n    uint64_t musicid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>musicid</code> MusicID, \u901a\u5e38\u662fQQ\u53f7</li> </ul> <p>Returns:</p> <p>Euin </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_fans","title":"function get_fans","text":"<p>\u7c89\u4e1d\u6570\u91cf <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_fans (\n    std::string_view euin,\n    unsigned page=1,\n    unsigned num=10,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>encrypt_uin</code> </li> <li><code>page</code> \u9875\u7801, \u9ed8\u8ba4<code>1</code> </li> <li><code>num</code> \u8fd4\u56de\u6570\u91cf, \u9ed8\u8ba4<code>10</code> </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f </li> </ul>"},{"location":"dictionary/namespaceqqmusic/#function-get_fav_album","title":"function get_fav_album","text":"<p>\u83b7\u53d6\u6536\u85cf\u4e13\u8f91 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_fav_album (\n    std::string_view euin,\n    unsigned page=1,\n    unsigned num=10,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>encrypt_uin</code> </li> <li><code>page</code> \u9875\u7801, \u9ed8\u8ba4<code>1</code> </li> <li><code>num</code> \u8fd4\u56de\u6570\u91cf, \u9ed8\u8ba4<code>10</code> </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f </li> </ul>"},{"location":"dictionary/namespaceqqmusic/#function-get_fav_mv","title":"function get_fav_mv","text":"<p>\u83b7\u53d6\u6536\u85cfMV <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_fav_mv (\n    std::string_view euin,\n    unsigned page=1,\n    unsigned num=10,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>encrypt_uin</code> </li> <li><code>page</code> \u9875\u7801, \u9ed8\u8ba4<code>1</code> </li> <li><code>num</code> \u8fd4\u56de\u6570\u91cf, \u9ed8\u8ba4<code>10</code> </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f </li> </ul>"},{"location":"dictionary/namespaceqqmusic/#function-get_fav_num","title":"function get_fav_num","text":"<p>\u83b7\u53d6\u6b4c\u66f2\u7684\u6536\u85cf\u91cf <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_fav_num (\n    std::span&lt; uint64_t &gt; id_list,\n    bool readable=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id_list</code> \u6b4c\u66f2id\u5217\u8868 </li> <li><code>readable</code> \u662f\u5426\u4eba\u7c7b\u53ef\u8bfb</li> </ul> <p>\u793a\u4f8b:</p> <pre><code>readable == false \u8fd4\u56de: {'438910555': 1000001}\nreadable == true \u8fd4\u56de:  {'438910555': '550w+'}\n</code></pre> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_fav_song","title":"function get_fav_song","text":"<p>\u83b7\u53d6\u6536\u85cf\u6b4c\u66f2 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_fav_song (\n    std::string_view euin,\n    unsigned page=1,\n    unsigned num=10,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>encrypt_uin</code> </li> <li><code>page</code> \u9875\u7801, \u9ed8\u8ba4<code>1</code> </li> <li><code>num</code> \u8fd4\u56de\u6570\u91cf, \u9ed8\u8ba4<code>10</code> </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f </li> </ul>"},{"location":"dictionary/namespaceqqmusic/#function-get_fav_songlist","title":"function get_fav_songlist","text":"<p>\u83b7\u53d6\u6536\u85cf\u6b4c\u5355 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_fav_songlist (\n    std::string_view euin,\n    unsigned page=1,\n    unsigned num=10,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>encrypt_uin</code> </li> <li><code>page</code> \u9875\u7801, \u9ed8\u8ba4<code>1</code> </li> <li><code>num</code> \u8fd4\u56de\u6570\u91cf, \u9ed8\u8ba4<code>10</code> </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f </li> </ul>"},{"location":"dictionary/namespaceqqmusic/#function-get_follow_singers","title":"function get_follow_singers","text":"<p>\u83b7\u53d6\u5173\u6ce8\u7684\u6b4c\u624b\u5217\u8868 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_follow_singers (\n    std::string_view euin,\n    unsigned page=1,\n    unsigned num=10,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>encrypt_uin</code> </li> <li><code>page</code> \u9875\u7801, \u9ed8\u8ba4<code>1</code> </li> <li><code>num</code> \u8fd4\u56de\u6570\u91cf, \u9ed8\u8ba4<code>10</code> </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f </li> </ul>"},{"location":"dictionary/namespaceqqmusic/#function-get_follow_usr","title":"function get_follow_usr","text":"<p>\u83b7\u53d6\u5173\u6ce8\u7528\u6237\u5217\u8868 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_follow_usr (\n    std::string_view euin,\n    unsigned page=1,\n    unsigned num=10,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>encrypt_uin</code> </li> <li><code>page</code> \u9875\u7801, \u9ed8\u8ba4<code>1</code> </li> <li><code>num</code> \u8fd4\u56de\u6570\u91cf, \u9ed8\u8ba4<code>10</code> </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f </li> </ul>"},{"location":"dictionary/namespaceqqmusic/#function-get_friend_list","title":"function get_friend_list","text":"<p>\u83b7\u53d6\u597d\u53cb\u5217\u8868 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_friend_list (\n    unsigned page=1,\n    unsigned num=10,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>page</code> \u9875\u7801, \u9ed8\u8ba4<code>1</code> </li> <li><code>num</code> \u8fd4\u56de\u6570\u91cf, \u9ed8\u8ba4<code>10</code> </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f </li> </ul>"},{"location":"dictionary/namespaceqqmusic/#function-get_homepage","title":"function get_homepage","text":"<p>\u83b7\u53d6\u7528\u6237\u4e3b\u9875\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_homepage (\n    std::string_view euin,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>euin</code> encrypt_uin </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f</li> </ul> <p>Returns:</p> <p>\u7528\u6237\u4e3b\u9875\u4fe1\u606f, \u5305\u542b\u97f3\u4e50\u57fa\u56e0, \u6b4c\u5355\u7b49 </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_labels","title":"function get_labels","text":"<p>\u83b7\u53d6\u6b4c\u66f2\u6807\u7b7e\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_labels (\n    uint64_t songid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> \u6b4c\u66f2id</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_lyric","title":"function get_lyric","text":"<p>\u83b7\u53d6\u6b4c\u66f2\u7684\u6b4c\u8bcd <pre><code>Task&lt; Result &lt; Lyric &gt; &gt; qqmusic::get_lyric (\n    std::string_view mid,\n    bool qrc=false,\n    bool trans=false,\n    bool roma=false\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u66f2mid </li> <li><code>qrc</code> lyric\u662f\u5426\u662fxml\u683c\u5f0f, \u9ed8\u8ba4false </li> <li><code>trans</code> \u662f\u5426\u9644\u5e26\u7ffb\u8bd1 </li> <li><code>roma</code> \u662f\u5426\u9644\u5e26\u7f57\u9a6c\u97f3</li> </ul> <p>Returns:</p> <p>\u539f\u59cb\u7684\u6b4c\u8bcd\u5b57\u7b26\u4e32, qrc\u6b4c\u8bcd\u4ec5\u7ecf\u8fc7\u89e3\u7801, \u8fd8\u662f\u539f\u59cb\u7684xml\u683c\u5f0f</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_lyric_1","title":"function get_lyric","text":"<p>\u83b7\u53d6\u6b4c\u66f2\u7684\u6b4c\u8bcd <pre><code>Task&lt; Result &lt; Lyric &gt; &gt; qqmusic::get_lyric (\n    uint64_t id,\n    bool qrc=false,\n    bool trans=false,\n    bool roma=false\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> \u6b4c\u66f2id </li> <li><code>qrc</code> lyric\u662f\u5426\u662fxml\u683c\u5f0f, \u9ed8\u8ba4false </li> <li><code>trans</code> \u662f\u5426\u9644\u5e26\u7ffb\u8bd1 </li> <li><code>roma</code> \u662f\u5426\u9644\u5e26\u7f57\u9a6c\u97f3</li> </ul> <p>Returns:</p> <p>\u539f\u59cb\u7684\u6b4c\u8bcd\u5b57\u7b26\u4e32, qrc\u6b4c\u8bcd\u4ec5\u7ecf\u8fc7\u89e3\u7801, \u8fd8\u662f\u539f\u59cb\u7684xml\u683c\u5f0f</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_music_gene","title":"function get_music_gene","text":"<p>\u83b7\u53d6\u97f3\u4e50\u57fa\u56e0 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_music_gene (\n    std::string_view euin,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>euin</code> encrypt_uin </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f </li> </ul>"},{"location":"dictionary/namespaceqqmusic/#function-get_musicid","title":"function get_musicid","text":"<p>\u7531euin\u83b7\u53d6musicid <pre><code>Task&lt; Result &lt; uint64_t &gt; &gt; qqmusic::get_musicid (\n    std::string_view euin\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>euin</code> encrypt_uin</li> </ul> <p>Returns:</p> <p>musicid </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_mv_detail","title":"function get_mv_detail","text":"<p>\u83b7\u53d6\u4e00\u7ec4MV\u7684\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_mv_detail (\n    std::span&lt; std::string &gt; vids\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>vids</code> \u5f85\u67e5\u8be2\u7684MV vid\u5217\u8868</li> </ul> <p>Returns:</p> <p>MV\u4fe1\u606fjson</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_mv_list","title":"function get_mv_list","text":"<p>\u83b7\u53d6\u6b4c\u624bMV\u5217\u8868 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_mv_list (\n    std::string_view mid,\n    unsigned number=10,\n    unsigned begin=0\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u624bmid </li> <li><code>number</code> \u5355\u6b21\u83b7\u53d6\u6570\u636e\u91cf, \u9ed8\u8ba4<code>10</code> </li> <li><code>begin</code> \u4ece\u7b2c\u51e0\u4e2a\u5f00\u59cb</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_mv_list_all","title":"function get_mv_list_all","text":"<p>\u83b7\u53d6\u6b4c\u624b\u6240\u6709MV <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_mv_list_all (\n    std::string_view mid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u624bmid</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_mv_urls","title":"function get_mv_urls","text":"<p>\u83b7\u53d6mv url <pre><code>Task&lt; Result &lt; std::vector&lt; MvUrl &gt; &gt; &gt; qqmusic::get_mv_urls (\n    std::span&lt; std::string &gt; vids\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>vids</code> \u5f85\u67e5\u8be2\u7684MV vid\u5217\u8868</li> </ul> <p>Returns:</p> <p>MvUrl\u5217\u8868</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_other_version","title":"function get_other_version","text":"<p>\u83b7\u53d6\u540c\u540d\u6b4c\u66f2\u7684\u5176\u4ed6\u7248\u672c <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_other_version (\n    std::string_view mid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u66f2mid</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_other_version_1","title":"function get_other_version","text":"<p>\u83b7\u53d6\u540c\u540d\u6b4c\u66f2\u7684\u5176\u4ed6\u7248\u672c <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_other_version (\n    uint64_t id\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> \u6b4c\u66f2id</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_producer_info","title":"function get_producer_info","text":"<p>\u83b7\u53d6\u6b4c\u66f2\u5236\u4f5c\u8005\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_producer_info (\n    std::string_view mid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u66f2mid</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u53ef\u80fd\u8fd4\u56deJSON\u7684<code>null</code>, \u5373\u6ca1\u6709\u5236\u4f5c\u8005\u4fe1\u606f </p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_producer_info_1","title":"function get_producer_info","text":"<p>\u83b7\u53d6\u6b4c\u66f2\u5236\u4f5c\u8005\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_producer_info (\n    uint64_t id\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> \u6b4c\u66f2id</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u53ef\u80fd\u8fd4\u56deJSON\u7684<code>null</code>, \u5373\u6ca1\u6709\u5236\u4f5c\u8005\u4fe1\u606f </p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_qrcode","title":"function get_qrcode","text":"<p>\u83b7\u53d6\u767b\u9646\u4e8c\u7ef4\u7801 <pre><code>qqmusic::Task&lt; qqmusic::Result&lt; QRCode &gt; &gt; qqmusic::get_qrcode (\n    QRLoginType login_type\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>login_type</code> \u767b\u9646\u7c7b\u578b</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786e\u7ed3\u679c\u7684<code>Task&lt; Result &lt; QRCode &gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_related_mv","title":"function get_related_mv","text":"<p>\u83b7\u53d6\u76f8\u5173MV <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_related_mv (\n    uint64_t songid,\n    std::optional&lt; std::string &gt; last_mvid=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> \u6b4c\u66f2id</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_related_songlist","title":"function get_related_songlist","text":"<p>\u83b7\u53d6\u76f8\u5173\u6b4c\u5355\u5217\u8868 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_related_songlist (\n    uint64_t songid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> \u6b4c\u66f2id</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_sheet","title":"function get_sheet","text":"<p>\u83b7\u53d6\u66f2\u8c31\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_sheet (\n    std::string_view mid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u66f2mid</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_similar_singers","title":"function get_similar_singers","text":"<p>\u83b7\u53d6\u76f8\u4f3c\u6b4c\u624b\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_similar_singers (\n    std::string_view mid,\n    unsigned number=10\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mids</code> \u6b4c\u624bmid </li> <li><code>number</code> \u76f8\u4f3c\u6b4c\u624b\u6570\u91cf, \u9ed8\u8ba4\u4e3a<code>0</code></li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>See also: TabType </p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_similar_songs","title":"function get_similar_songs","text":"<p>\u83b7\u53d6\u76f8\u4f3c\u6b4c\u66f2\u5217\u8868 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_similar_songs (\n    uint64_t songid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> \u6b4c\u66f2id</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_singer_desc","title":"function get_singer_desc","text":"<p>\u83b7\u53d6\u591a\u4e2a\u6b4c\u624b\u7684\u7b80\u4ecb <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_singer_desc (\n    std::span&lt; std::string &gt; mids,\n    unsigned number=10\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mids</code> \u6b4c\u624bmid\u5217\u8868 </li> <li><code>number</code> \u76f8\u4f3c\u6b4c\u624b\u6570\u91cf, \u9ed8\u8ba4\u4e3a<code>0</code></li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>See also: TabType </p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_singer_info","title":"function get_singer_info","text":"<p>\u83b7\u53d6\u6b4c\u624b\u57fa\u672c\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_singer_info (\n    std::string_view mid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>\u6b4c\u624bmid</code> </li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_singer_list","title":"function get_singer_list","text":"<p>\u83b7\u53d6\u7b26\u5408\u7b5b\u9009\u6761\u4ef6\u7684\u6b4c\u624b\u4fe1\u606f\u8868\u5355 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_singer_list (\n    AreaType area=AreaType::ALL,\n    GenderType gender=GenderType::ALL,\n    GenreType genre=GenreType::ALL\n) \n</code></pre></p> <p>\u83b7\u53d6JSON\u683c\u5f0f\u7684\u6b4c\u624b\u4fe1\u606f, \u53ef\u4ee5\u4f7f\u7528area, gender\u548cgenre\u7b5b\u9009</p> <p>Parameters:</p> <ul> <li><code>area</code> \u533a\u57df\u4fe1\u606f\u7b5b\u9009, \u9ed8\u8ba4<code>AreaType::ALL</code>. </li> <li><code>gender</code> \u6027\u522b\u4fe1\u606f\u7b5b\u9009, \u9ed8\u8ba4<code>GenderType::ALL</code>. </li> <li><code>genre</code> \u98ce\u683c\u4fe1\u606f\u7b5b\u9009, \u9ed8\u8ba4<code>GenreType::ALL</code>.</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>See also: AreaType, GenderType, GenreType </p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_singer_list_index","title":"function get_singer_list_index","text":"<p>\u7b5b\u9009\u83b7\u5f97\u6b4c\u66f2\u6b4c\u5355\u539f\u59cb\u6570\u636e <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_singer_list_index (\n    AreaType area=AreaType::ALL,\n    GenderType gender=GenderType::ALL,\n    GenreType genre=GenreType::ALL,\n    IndexType index=IndexType::ALL,\n    unsigned sin=0,\n    unsigned cur_page=1\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>area</code> \u533a\u57df\u4fe1\u606f\u7b5b\u9009, \u9ed8\u8ba4<code>AreaType::ALL</code>. </li> <li><code>gender</code> \u6027\u522b\u4fe1\u606f\u7b5b\u9009, \u9ed8\u8ba4<code>GenderType::ALL</code>. </li> <li><code>genre</code> \u98ce\u683c\u4fe1\u606f\u7b5b\u9009, \u9ed8\u8ba4<code>GenreType::ALL</code>. </li> <li><code>sin</code> \u8df3\u8fc7\u7684\u6761\u76ee\u6570\u91cf, \u9ed8\u8ba4<code>0</code> </li> <li><code>cur_page</code> \u5f53\u524d\u9875\u9762\u7684\u7d22\u5f15, \u9ed8\u8ba4<code>1</code></li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>See also: AreaType, GenderType, GenreType, IndexType </p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_singer_list_index_all","title":"function get_singer_list_index_all","text":"<p>\u83b7\u53d6\u6240\u6709\u7b26\u5408\u6761\u4ef6\u7684\u6b4c\u5355\u539f\u59cb\u6570\u636e <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_singer_list_index_all (\n    AreaType area=AreaType::ALL,\n    GenderType gender=GenderType::ALL,\n    GenreType genre=GenreType::ALL,\n    IndexType index=IndexType::ALL\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>area</code> \u533a\u57df\u4fe1\u606f\u7b5b\u9009, \u9ed8\u8ba4<code>AreaType::ALL</code>. </li> <li><code>gender</code> \u6027\u522b\u4fe1\u606f\u7b5b\u9009, \u9ed8\u8ba4<code>GenderType::ALL</code>. </li> <li><code>genre</code> \u98ce\u683c\u4fe1\u606f\u7b5b\u9009, \u9ed8\u8ba4<code>GenreType::ALL</code>. </li> <li><code>index</code> \u7d22\u5f15\u4fe1\u606f\u7b5b\u9009, \u9ed8\u8ba4<code>IndexType::ALL</code>.</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>See also: AreaType, GenderType, GenreType, IndexType </p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_song_detail","title":"function get_song_detail","text":"<p>\u83b7\u53d6\u6b4c\u66f2\u8be6\u7ec6\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_song_detail (\n    std::string_view mid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u66f2mid</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_song_detail_1","title":"function get_song_detail","text":"<p>\u83b7\u53d6\u6b4c\u66f2\u8be6\u7ec6\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_song_detail (\n    uint64_t id\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> \u6b4c\u66f2id</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_song_urls","title":"function get_song_urls","text":"<p>\u6279\u91cf\u83b7\u53d6\u6b4c\u66f2\u64ad\u653e\u94fe\u63a5 <pre><code>Task&lt; Result &lt; std::vector&lt; SongInfo &gt; &gt; &gt; qqmusic::get_song_urls (\n    std::span&lt; std::string &gt; mids,\n    std::unique_ptr&lt; BaseMediaFileType &gt; file_type=std::make_unique&lt; SongFileType &gt;(),\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>@params mids \u6b4c\u66f2mid\u5217\u8868 @params file_type \u6b4c\u66f2\u6587\u4ef6\u7c7b\u578b, \u9ed8\u8ba4MP3_128\u7c7b\u578b @params credential \u51ed\u8bc1\u4fe1\u606f</p> <p>\u8c03\u7528\u793a\u4f8b:  <pre><code>std::vector&lt;std::string&gt; mids{\"002n5zzy3VVGau\"};\n\n// \u672a\u52a0\u5bc6\u7c7b\u578b\nauto res = co_await get_song_urls(mids,\n    std::make_unique&lt;SongFileType&gt;(SongFileType::ACC_192));\n\n// \u52a0\u5bc6\u6587\u4ef6\u7c7b\u578b \nauto res = co_await get_song_urls(mids,\n    std::make_unique&lt;EncryptedSongFileType&gt;(EncryptedSongFileType::MASTER));\n</code></pre></p> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>See also: BaseMediaFileType, SongFileType, EncryptedSongFileType </p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_songlist","title":"function get_songlist","text":"<p>\u83b7\u53d6\u6b4c\u5355\u5217\u8868 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_songlist (\n    uint64_t dissid,\n    unsigned dirid=0\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dissid</code> \u6b4c\u5355ID </li> <li><code>dirid</code> \u6b4c\u5355dirid, \u9ed8\u8ba4\u4e3a0</li> </ul> <p>Returns:</p> <p>Json\u683c\u5f0f\u6b4c\u5355\u5217\u8868</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_songlist_detail","title":"function get_songlist_detail","text":"<p>\u83b7\u53d6\u6b4c\u5355\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_songlist_detail (\n    uint64_t dissid,\n    unsigned dirid=0,\n    unsigned num=10,\n    unsigned page=1,\n    bool only_song=false,\n    bool tag=true,\n    bool user_info=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dissid</code> \u6b4c\u5355ID </li> <li><code>dirid</code> \u6b4c\u5355drid, \u9ed8\u8ba4\u4e3a<code>0</code> </li> <li><code>num</code> \u8fd4\u56desonglist\u5143\u7d20\u6570\u91cf, \u9ed8\u8ba4\u4e3a<code>10</code> </li> <li><code>page</code> \u7b2c\u51e0\u9875, \u9ed8\u8ba4\u4e3a<code>1</code> </li> <li><code>only_song</code> \u662f\u5426\u4ec5\u8fd4\u56de\u6b4c\u66f2\u4fe1\u606f, \u9ed8\u8ba4<code>false</code> </li> <li><code>tag</code> \u662f\u5426\u8fd4\u56de\u6b4c\u5355\u6807\u7b7e\u4fe1\u606f, \u9ed8\u8ba4<code>true</code> </li> <li><code>user_info</code> \u662f\u5426\u8fd4\u56de\u6b4c\u5355\u521b\u5efa\u8005\u7684\u7528\u6237\u4fe1\u606f, \u9ed8\u8ba4<code>true</code></li> </ul> <p>Returns:</p> <p>Json\u683c\u5f0f\u7684\u6b4c\u5355\u4fe1\u606f</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_songs_list","title":"function get_songs_list","text":"<p>\u83b7\u53d6\u6b4c\u624b\u6b4c\u66f2\u539f\u59cb\u6570\u636e <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_songs_list (\n    std::string_view mid,\n    unsigned num=10,\n    unsigned begin=0\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u624bmid </li> <li><code>num</code> \u6bcf\u6b21\u83b7\u53d6\u7684\u6700\u5927\u6570\u91cf, \u9ed8\u8ba4<code>10</code>, \u6700\u5927<code>30</code> </li> <li><code>begin</code> \u4ece\u7b2c\u51e0\u4e2a\u5f00\u59cb</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_songs_list_all","title":"function get_songs_list_all","text":"<p>\u83b7\u53d6\u6b4c\u624b\u7684\u6240\u6709\u6b4c\u66f2 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_songs_list_all (\n    std::string_view mid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u624bmid</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_tab_detail","title":"function get_tab_detail","text":"<p>\u8fd4\u56de\u6807\u7b7e\u8be6\u7ec6\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_tab_detail (\n    std::string_view mid,\n    TabType type,\n    unsigned page=1,\n    unsigned num=10\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mid</code> \u6b4c\u624bmid </li> <li><code>type</code> \u6807\u7b7e\u4fe1\u606f </li> <li><code>page</code> \u9875\u7801 </li> <li><code>num</code> \u6bcf\u9875\u8fd4\u56de\u6570\u91cf</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>See also: TabType </p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_toplist_category","title":"function get_toplist_category","text":"<p>\u83b7\u53d6\u6240\u6709\u6392\u884c\u699c <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_toplist_category () \n</code></pre></p>"},{"location":"dictionary/namespaceqqmusic/#function-get_toplist_item_detail","title":"function get_toplist_item_detail","text":"<p>\u83b7\u53d6\u6392\u884c\u699c\u6761\u76ee\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_toplist_item_detail (\n    unsigned top_id,\n    unsigned num=10,\n    unsigned page=1,\n    bool tag=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>top_id</code> \u6392\u884c\u699cID </li> <li><code>num</code> \u8fd4\u56de\u6570\u91cf, \u9ed8\u8ba4\u4e3a<code>10</code> </li> <li><code>page</code> \u9875\u7801, \u9ed8\u8ba4\u4e3a<code>0</code> </li> <li><code>tag</code> \u662f\u5426\u8fd4\u56de\u6b4c\u66f2\u6807\u7b7e, \u9ed8\u8ba4\u4e3a<code>true</code></li> </ul> <p>Returns:</p>"},{"location":"dictionary/namespaceqqmusic/#function-get_try_url","title":"function get_try_url","text":"<p>\u83b7\u53d6\u8bd5\u542c\u94fe\u63a5 <pre><code>Task&lt; Result &lt; std::string &gt; &gt; qqmusic::get_try_url (\n    std::string_view mid,\n    std::string_view vs\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>area</code> \u533a\u57df\u4fe1\u606f\u7b5b\u9009, \u9ed8\u8ba4<code>AreaType::ALL</code>. </li> <li><code>gender</code> \u6027\u522b\u4fe1\u606f\u7b5b\u9009, \u9ed8\u8ba4<code>GenderType::ALL</code>. </li> <li><code>genre</code> \u98ce\u683c\u4fe1\u606f\u7b5b\u9009, \u9ed8\u8ba4<code>GenreType::ALL</code>.</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>See also: AreaType, GenderType, GenreType </p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-get_vip_info","title":"function get_vip_info","text":"<p>\u83b7\u53d6\u5f53\u524d\u8d26\u53f7vip\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::get_vip_info (\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f </li> </ul>"},{"location":"dictionary/namespaceqqmusic/#function-hotkey","title":"function hotkey","text":"<p>\u83b7\u53d6\u641c\u7d22\u70ed\u8bcd <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::hotkey () \n</code></pre></p> <p>Returns:</p> <p>Json\u683c\u5f0f\u7684\u641c\u7d22\u70ed\u8bcd</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-keyword_complete","title":"function keyword_complete","text":"<p>\u641c\u7d22\u8bcd\u8054\u60f3\u8865\u5168 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::keyword_complete (\n    std::string_view keyword\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>keyword</code> \u5f53\u524d\u641c\u7d22\u8bcd</li> </ul> <p>Returns:</p> <p>\u5e26\u6709\u9ad8\u4eae\u7684\u8865\u5168\u7ed3\u679c</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-phone_authorize","title":"function phone_authorize","text":"<p>\u624b\u673a\u53f7\u8ba4\u8bc1 <pre><code>qqmusic::Task&lt; qqmusic::Result&lt; utils::Credential &gt; &gt; qqmusic::phone_authorize (\n    std::string_view phone,\n    std::string_view auth_code,\n    std::string_view country_code=\"86\"\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>phone</code> \u624b\u673a\u53f7 </li> <li><code>auth_code</code> \u9a8c\u8bc1\u7801 </li> <li><code>country_code</code> \u5730\u533a\u524d\u7f00</li> </ul> <p>Returns:</p> <p><code>qqmusic::Task&lt;qqmusic::Result&lt; qqmusic::utils::Credential &gt;&gt;</code> \u51fa\u9519\u5c31\u4f1a\u8fd4\u56de<code>Err</code></p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code></p> <p>Warning:</p> <p>\u8be5\u51fd\u6570\u4ecd\u6709\u95ee\u9898, \u4e0d\u5e94\u4f7f\u7528 </p>"},{"location":"dictionary/namespaceqqmusic/#function-query_song","title":"function query_song","text":"<p>\u6279\u91cf\u67e5\u8be2\u6b4c\u66f2\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::query_song (\n    std::span&lt; std::string &gt; mids\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mids</code> \u5f85\u67e5\u8be2\u6b4c\u66f2mid\u5217\u8868</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-query_song_1","title":"function query_song","text":"<p>\u6279\u91cf\u67e5\u8be2\u6b4c\u66f2\u4fe1\u606f <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::query_song (\n    std::span&lt; uint64_t &gt; ids\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mids</code> \u5f85\u67e5\u8be2\u6b4c\u66f2id\u5217\u8868</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;nlohmann::json&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-quick_search","title":"function quick_search","text":"<p>\u5feb\u901f\u641c\u7d22 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::quick_search (\n    std::string_view keyword\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>keyword</code> \u641c\u7d22\u8bcd</li> </ul> <p>Returns:</p> <p>Json\u683c\u5f0f\u641c\u7d22\u7ed3\u679c</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-search_by_type","title":"function search_by_type","text":"<p>\u6309\u7c7b\u578b\u641c\u7d22 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::search_by_type (\n    std::string_view keyword,\n    SearchType type=SearchType::SONG,\n    unsigned num_per_page=10,\n    unsigned page=1,\n    bool highlight=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>keybord</code> \u641c\u7d22\u8bcd </li> <li><code>type</code> \u641c\u7d22\u7c7b\u578b </li> <li><code>num_per_page</code> \u6bcf\u9875\u7ed3\u679c\u6570 </li> <li><code>page</code> \u9875\u6570</li> </ul> <p>Returns:</p> <p>Json\u683c\u5f0f\u641c\u7d22\u7ed3\u679c</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-send_authcode","title":"function send_authcode","text":"<p>\u5411\u6307\u5b9a\u624b\u673a\u53f7\u53d1\u9001\u9a8c\u8bc1\u7801 <pre><code>qqmusic::Task&lt; qqmusic::Result&lt; PhoneLoginResult &gt; &gt; qqmusic::send_authcode (\n    std::string_view phone,\n    std::string_view country_code=\"86\"\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>phone</code> \u624b\u673a\u53f7 </li> <li><code>country_code</code> \u5730\u533a\u524d\u7f00</li> </ul> <p>Returns:</p> <p><code>qqmusic::Task&lt;qqmusic::Result&lt; PhoneLoginResult &gt;&gt;</code> \u51fa\u9519\u5c31\u4f1a\u8fd4\u56de<code>Err</code></p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code></p> <p>Warning:</p> <p>\u8be5\u51fd\u6570\u4ecd\u6709\u95ee\u9898, \u4e0d\u5e94\u4f7f\u7528 </p>"},{"location":"dictionary/namespaceqqmusic/#function-songlist_add_songs","title":"function songlist_add_songs","text":"<p>\u5411\u6b4c\u5355\u5185\u6dfb\u52a0\u6b4c\u66f2 <pre><code>Task&lt; Result &lt; bool &gt; &gt; qqmusic::songlist_add_songs (\n    uint64_t dirid,\n    std::span&lt; uint64_t &gt; song_ids,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dirid</code> \u6b4c\u5355ID </li> <li><code>song_ids</code> \u5f85\u6dfb\u52a0\u6b4c\u5355\u5217\u8868 </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f</li> </ul> <p>Returns:</p> <p>\u662f\u5426\u6dfb\u52a0\u6210\u529f, \u6b4c\u66f2\u5df2\u5b58\u5728\u5219\u8fd4\u56de<code>false</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-songlist_create","title":"function songlist_create","text":"<p>\u521b\u5efa\u6b4c\u5355 <pre><code>Task&lt; Result &lt; nlohmann::json &gt; &gt; qqmusic::songlist_create (\n    std::string_view dirname,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dirname</code> \u65b0\u7684\u6b4c\u5355\u540d\u79f0 </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f</li> </ul> <p>Returns:</p> <p>\u521b\u5efa\u6b4c\u5355\u7684\u57fa\u672c\u4fe1\u606f</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code></p> <p>Warning:</p> <p>\u6b4c\u5355\u540d\u79f0\u4e0d\u5e94\u8be5\u542b\u6709\u9664\u4e86\u6b63\u5e38\u5b57\u7b26\u4e4b\u5916\u7684\u4e1c\u897f, \u4f8b\u5982emoji, \u8fd9\u5c06\u5bfc\u81f4\u6b4c\u5355\u867d\u7136\u88ab\u6b63\u786e\u521b\u5efa, \u4f46\u662f\u8fd4\u56de\u65f6json\u89e3\u6790\u5f02\u5e38\u62a5\u9519 </p>"},{"location":"dictionary/namespaceqqmusic/#function-songlist_delete","title":"function songlist_delete","text":"<p>\u5220\u9664\u6b4c\u5355 <pre><code>Task&lt; Result &lt; bool &gt; &gt; qqmusic::songlist_delete (\n    uint64_t dirid,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dirid</code> \u6b4c\u5355ID </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f</li> </ul> <p>Returns:</p> <p>\u662f\u5426\u5220\u9664\u6210\u529f, \u5982\u679c\u4e0d\u5b58\u5728\u8fd9\u4e2a\u6b4c\u5355\u5219\u8fd4\u56de<code>false</code> </p>"},{"location":"dictionary/namespaceqqmusic/#function-songlist_delete_songs","title":"function songlist_delete_songs","text":"<p>\u5220\u9664\u6b4c\u5355\u5185\u6307\u5b9a\u6b4c\u66f2 <pre><code>Task&lt; Result &lt; bool &gt; &gt; qqmusic::songlist_delete_songs (\n    uint64_t dirid,\n    std::span&lt; uint64_t &gt; song_ids,\n    std::optional&lt; utils::Credential &gt; credential=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dirid</code> \u6b4c\u5355ID </li> <li><code>song_ids</code> \u5f85\u5220\u9664\u6b4c\u5355\u5217\u8868 </li> <li><code>credential</code> \u51ed\u636e\u4fe1\u606f</li> </ul> <p>Returns:</p> <p>\u662f\u5426\u5220\u9664\u6210\u529f, \u6b4c\u66f2\u4e0d\u5b58\u5728\u5219\u8fd4\u56de<code>false</code> </p> <p>The documentation for this class was generated from the following file <code>src/album.cc</code></p>"},{"location":"dictionary/classqqmusic_1_1BaseMediaFileType/","title":"Class qqmusic::BaseMediaFileType","text":"<p>ClassList &gt; qqmusic &gt; BaseMediaFileType</p> <p>\u5a92\u4f53\u6587\u4ef6\u7c7b\u578b\u57fa\u7c7b </p> <ul> <li><code>#include &lt;song.h&gt;</code></li> </ul> <p>Inherited by the following classes: qqmusic::EncryptedSongFileType,  qqmusic::SongFileType</p>"},{"location":"dictionary/classqqmusic_1_1BaseMediaFileType/#public-functions","title":"Public Functions","text":"Type Name virtual bool encrypted () = 0\u662f\u5426\u52a0\u5bc6 virtual std::string_view expandation () = 0\u83b7\u53d6\u6269\u5c55\u540d virtual std::string_view prefix () = 0\u83b7\u53d6\u57fa\u7c7bID virtual ~BaseMediaFileType () = default"},{"location":"dictionary/classqqmusic_1_1BaseMediaFileType/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/classqqmusic_1_1BaseMediaFileType/#function-encrypted","title":"function encrypted","text":"<p>\u662f\u5426\u52a0\u5bc6 <pre><code>virtual bool qqmusic::BaseMediaFileType::encrypted () = 0\n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1BaseMediaFileType/#function-expandation","title":"function expandation","text":"<p>\u83b7\u53d6\u6269\u5c55\u540d <pre><code>virtual std::string_view qqmusic::BaseMediaFileType::expandation () = 0\n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1BaseMediaFileType/#function-prefix","title":"function prefix","text":"<p>\u83b7\u53d6\u57fa\u7c7bID <pre><code>virtual std::string_view qqmusic::BaseMediaFileType::prefix () = 0\n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1BaseMediaFileType/#function-basemediafiletype","title":"function ~BaseMediaFileType","text":"<pre><code>virtual qqmusic::BaseMediaFileType::~BaseMediaFileType () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/song.h</code></p>"},{"location":"dictionary/classqqmusic_1_1EncryptedSongFileType/","title":"Class qqmusic::EncryptedSongFileType","text":"<p>ClassList &gt; qqmusic &gt; EncryptedSongFileType</p> <p>\u52a0\u5bc6\u6b4c\u66f2\u6587\u4ef6\u7c7b\u578b More...</p> <ul> <li><code>#include &lt;song.h&gt;</code></li> </ul> <p>Inherits the following classes: qqmusic::BaseMediaFileType</p>"},{"location":"dictionary/classqqmusic_1_1EncryptedSongFileType/#public-types","title":"Public Types","text":"Type Name enum Type \u52a0\u5bc6\u6b4c\u66f2\u7c7b\u578b\u679a\u4e3e"},{"location":"dictionary/classqqmusic_1_1EncryptedSongFileType/#public-functions","title":"Public Functions","text":"Type Name EncryptedSongFileType (Type type) \u901a\u8fc7\u7c7b\u578b\u679a\u4e3e\u521d\u59cb\u5316 EncryptedSongFileType () \u9ed8\u8ba4\u521d\u59cb\u5316\u51fd\u6570, \u9ed8\u8ba4\u683c\u5f0f: FLAC\u683c\u5f0f virtual bool encrypted () override\u8be5\u683c\u5f0f\u662f\u5426\u52a0\u5bc6 virtual std::string_view expandation () override\u83b7\u53d6\u6b4c\u66f2\u7c7bID\u6269\u5c55 virtual std::string_view prefix () override\u83b7\u53d6\u6b4c\u66f2\u7c7bID\u524d\u7f00 ~EncryptedSongFileType () override"},{"location":"dictionary/classqqmusic_1_1EncryptedSongFileType/#public-functions-inherited-from-qqmusicbasemediafiletype","title":"Public Functions inherited from qqmusic::BaseMediaFileType","text":"<p>See qqmusic::BaseMediaFileType</p> Type Name virtual bool encrypted () = 0\u662f\u5426\u52a0\u5bc6 virtual std::string_view expandation () = 0\u83b7\u53d6\u6269\u5c55\u540d virtual std::string_view prefix () = 0\u83b7\u53d6\u57fa\u7c7bID virtual ~BaseMediaFileType () = default"},{"location":"dictionary/classqqmusic_1_1EncryptedSongFileType/#detailed-description","title":"Detailed Description","text":"<p>See also: BaseMediaFileType </p>"},{"location":"dictionary/classqqmusic_1_1EncryptedSongFileType/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"dictionary/classqqmusic_1_1EncryptedSongFileType/#enum-type","title":"enum Type","text":"<p>\u52a0\u5bc6\u6b4c\u66f2\u7c7b\u578b\u679a\u4e3e <pre><code>enum qqmusic::EncryptedSongFileType::Type {\n    MASTER,\n    ATMOS_2,\n    ATMOS_51,\n    FLAC,\n    OGG_640,\n    OGG_320,\n    OGG_192,\n    OGG_96\n};\n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1EncryptedSongFileType/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/classqqmusic_1_1EncryptedSongFileType/#function-encryptedsongfiletype-12","title":"function EncryptedSongFileType [1/2]","text":"<p>\u901a\u8fc7\u7c7b\u578b\u679a\u4e3e\u521d\u59cb\u5316 <pre><code>inline qqmusic::EncryptedSongFileType::EncryptedSongFileType (\n    Type type\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>type</code> \u7c7b\u578b\u679a\u4e3e</li> </ul> <p>See also: EncryptedSongFileType::Type</p> <p>Exception:</p> <ul> <li><code>\u82e5\u63d0\u4f9b\u7684\u679a\u4e3e\u4e0d\u5408\u6cd5</code> </li> </ul>"},{"location":"dictionary/classqqmusic_1_1EncryptedSongFileType/#function-encryptedsongfiletype-22","title":"function EncryptedSongFileType [2/2]","text":"<p>\u9ed8\u8ba4\u521d\u59cb\u5316\u51fd\u6570, \u9ed8\u8ba4\u683c\u5f0f: FLAC\u683c\u5f0f <pre><code>inline qqmusic::EncryptedSongFileType::EncryptedSongFileType () \n</code></pre></p> <p>See also: SongFileType::Type </p>"},{"location":"dictionary/classqqmusic_1_1EncryptedSongFileType/#function-encrypted","title":"function encrypted","text":"<p>\u8be5\u683c\u5f0f\u662f\u5426\u52a0\u5bc6 <pre><code>inline virtual bool qqmusic::EncryptedSongFileType::encrypted () override\n</code></pre></p> <p>Returns:</p> <p>\u603b\u662f\u8fd4\u56de<code>true</code> </p> <p>Implements qqmusic::BaseMediaFileType::encrypted</p>"},{"location":"dictionary/classqqmusic_1_1EncryptedSongFileType/#function-expandation","title":"function expandation","text":"<p>\u83b7\u53d6\u6b4c\u66f2\u7c7bID\u6269\u5c55 <pre><code>inline virtual std::string_view qqmusic::EncryptedSongFileType::expandation () override\n</code></pre></p> <p>Returns:</p> <p>\u8fd4\u56de<code>std::string</code>\u683c\u5f0f\u7684\u7c7b\u578b\u6269\u5c55\u540d </p> <p>Implements qqmusic::BaseMediaFileType::expandation</p>"},{"location":"dictionary/classqqmusic_1_1EncryptedSongFileType/#function-prefix","title":"function prefix","text":"<p>\u83b7\u53d6\u6b4c\u66f2\u7c7bID\u524d\u7f00 <pre><code>inline virtual std::string_view qqmusic::EncryptedSongFileType::prefix () override\n</code></pre></p> <p>Returns:</p> <p>\u8fd4\u56de<code>std::string</code>\u683c\u5f0f\u7684\u7c7b\u578b\u524d\u7f00 </p> <p>Implements qqmusic::BaseMediaFileType::prefix</p>"},{"location":"dictionary/classqqmusic_1_1EncryptedSongFileType/#function-encryptedsongfiletype","title":"function ~EncryptedSongFileType","text":"<pre><code>qqmusic::EncryptedSongFileType::~EncryptedSongFileType () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/song.h</code></p>"},{"location":"dictionary/structqqmusic_1_1Lyric/","title":"Struct qqmusic::Lyric","text":"<p>ClassList &gt; qqmusic &gt; Lyric</p> <p>\u6b4c\u8bcd </p> <ul> <li><code>#include &lt;lyric.h&gt;</code></li> </ul>"},{"location":"dictionary/structqqmusic_1_1Lyric/#public-attributes","title":"Public Attributes","text":"Type Name std::string lyric \u539f\u59cb\u6b4c\u8bcd std::string roma \u7f57\u9a6c\u97f3 std::string trans \u7ffb\u8bd1"},{"location":"dictionary/structqqmusic_1_1Lyric/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"dictionary/structqqmusic_1_1Lyric/#variable-lyric","title":"variable lyric","text":"<p>\u539f\u59cb\u6b4c\u8bcd <pre><code>std::string qqmusic::Lyric::lyric;\n</code></pre></p>"},{"location":"dictionary/structqqmusic_1_1Lyric/#variable-roma","title":"variable roma","text":"<p>\u7f57\u9a6c\u97f3 <pre><code>std::string qqmusic::Lyric::roma;\n</code></pre></p>"},{"location":"dictionary/structqqmusic_1_1Lyric/#variable-trans","title":"variable trans","text":"<p>\u7ffb\u8bd1 <pre><code>std::string qqmusic::Lyric::trans;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/lyric.h</code></p>"},{"location":"dictionary/structqqmusic_1_1MvUrl/","title":"Struct qqmusic::MvUrl","text":"<p>ClassList &gt; qqmusic &gt; MvUrl</p> <p>Mv url\u5c01\u88dd </p> <ul> <li><code>#include &lt;mv.h&gt;</code></li> </ul>"},{"location":"dictionary/structqqmusic_1_1MvUrl/#public-attributes","title":"Public Attributes","text":"Type Name std::map&lt; std::string, std::string &gt; hls hls\u683c\u5f0furl std::map&lt; std::string, std::string &gt; mp4 mp4\u683c\u5f0furl std::string vid Mv\u7684vid"},{"location":"dictionary/structqqmusic_1_1MvUrl/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"dictionary/structqqmusic_1_1MvUrl/#variable-hls","title":"variable hls","text":"<p>hls\u683c\u5f0furl <pre><code>std::map&lt;std::string, std::string&gt; qqmusic::MvUrl::hls;\n</code></pre></p>"},{"location":"dictionary/structqqmusic_1_1MvUrl/#variable-mp4","title":"variable mp4","text":"<p>mp4\u683c\u5f0furl <pre><code>std::map&lt;std::string, std::string&gt; qqmusic::MvUrl::mp4;\n</code></pre></p>"},{"location":"dictionary/structqqmusic_1_1MvUrl/#variable-vid","title":"variable vid","text":"<p>Mv\u7684vid <pre><code>std::string qqmusic::MvUrl::vid;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/mv.h</code></p>"},{"location":"dictionary/structqqmusic_1_1PhoneLoginResult/","title":"Struct qqmusic::PhoneLoginResult","text":"<p>ClassList &gt; qqmusic &gt; PhoneLoginResult</p>"},{"location":"dictionary/structqqmusic_1_1PhoneLoginResult/#public-attributes","title":"Public Attributes","text":"Type Name PhoneLoginEvent event std::string msg"},{"location":"dictionary/structqqmusic_1_1PhoneLoginResult/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"dictionary/structqqmusic_1_1PhoneLoginResult/#variable-event","title":"variable event","text":"<pre><code>PhoneLoginEvent qqmusic::PhoneLoginResult::event;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1PhoneLoginResult/#variable-msg","title":"variable msg","text":"<pre><code>std::string qqmusic::PhoneLoginResult::msg;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/login.h</code></p>"},{"location":"dictionary/structqqmusic_1_1QRCode/","title":"Struct qqmusic::QRCode","text":"<p>ClassList &gt; qqmusic &gt; QRCode</p> <p>\u4e8c\u7ef4\u7801\u4fe1\u606f </p> <ul> <li><code>#include &lt;login.h&gt;</code></li> </ul>"},{"location":"dictionary/structqqmusic_1_1QRCode/#public-attributes","title":"Public Attributes","text":"Type Name qqmusic::utils::buffer data qr code image binary data std::string identifier qr code identifier std::string mimie_type qr code image type QRLoginType qr_type qr code type"},{"location":"dictionary/structqqmusic_1_1QRCode/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"dictionary/structqqmusic_1_1QRCode/#variable-data","title":"variable data","text":"<p>qr code image binary data <pre><code>qqmusic::utils::buffer qqmusic::QRCode::data;\n</code></pre></p>"},{"location":"dictionary/structqqmusic_1_1QRCode/#variable-identifier","title":"variable identifier","text":"<p>qr code identifier <pre><code>std::string qqmusic::QRCode::identifier;\n</code></pre></p>"},{"location":"dictionary/structqqmusic_1_1QRCode/#variable-mimie_type","title":"variable mimie_type","text":"<p>qr code image type <pre><code>std::string qqmusic::QRCode::mimie_type;\n</code></pre></p>"},{"location":"dictionary/structqqmusic_1_1QRCode/#variable-qr_type","title":"variable qr_type","text":"<p>qr code type <pre><code>QRLoginType qqmusic::QRCode::qr_type;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/login.h</code></p>"},{"location":"dictionary/classqqmusic_1_1QRCodeLoginEvent/","title":"Class qqmusic::QRCodeLoginEvent","text":"<p>ClassList &gt; qqmusic &gt; QRCodeLoginEvent</p> <p>\u4e8c\u7ef4\u7801\u767b\u9646\u4e8b\u4ef6 </p> <ul> <li><code>#include &lt;login.h&gt;</code></li> </ul>"},{"location":"dictionary/classqqmusic_1_1QRCodeLoginEvent/#public-types","title":"Public Types","text":"Type Name enum Status \u4e8c\u7ef4\u7801\u72b6\u6001"},{"location":"dictionary/classqqmusic_1_1QRCodeLoginEvent/#public-functions","title":"Public Functions","text":"Type Name QRCodeLoginEvent (Status stat) \u4ece\u72b6\u6001\u6784\u9020 QRCodeLoginEvent (unsigned int code) \u4eceHttp\u8bf7\u6c42\u8fd4\u56de\u7684\u72b6\u6001\u7801\u6784\u9020 std::string_view name () const\u83b7\u53d6\u5f53\u524d\u72b6\u6001\u7684\u540d\u5b57 bool operator!= (const QRCodeLoginEvent &amp; e) \u72b6\u6001\u662f\u5426\u4e0d\u76f8\u540c bool operator!= (Status stat) \u548c\u679a\u4e3e\u76f4\u63a5\u6bd4\u8f83\u662f\u5426\u4e0d\u76f8\u540c bool operator== (const QRCodeLoginEvent &amp; e) \u72b6\u6001\u662f\u5426\u76f8\u540c bool operator== (Status stat) \u548c\u679a\u4e3e\u76f4\u63a5\u6bd4\u8f83\u662f\u5426\u76f8\u540c"},{"location":"dictionary/classqqmusic_1_1QRCodeLoginEvent/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"dictionary/classqqmusic_1_1QRCodeLoginEvent/#enum-status","title":"enum Status","text":"<p>\u4e8c\u7ef4\u7801\u72b6\u6001 <pre><code>enum qqmusic::QRCodeLoginEvent::Status {\n    DONE,\n    SCAN,\n    CONF,\n    REFUSE,\n    TIMEOUT,\n    OTHER\n};\n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1QRCodeLoginEvent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/classqqmusic_1_1QRCodeLoginEvent/#function-qrcodeloginevent-12","title":"function QRCodeLoginEvent [1/2]","text":"<p>\u4ece\u72b6\u6001\u6784\u9020 <pre><code>inline qqmusic::QRCodeLoginEvent::QRCodeLoginEvent (\n    Status stat\n) \n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1QRCodeLoginEvent/#function-qrcodeloginevent-22","title":"function QRCodeLoginEvent [2/2]","text":"<p>\u4eceHttp\u8bf7\u6c42\u8fd4\u56de\u7684\u72b6\u6001\u7801\u6784\u9020 <pre><code>inline qqmusic::QRCodeLoginEvent::QRCodeLoginEvent (\n    unsigned int code\n) \n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1QRCodeLoginEvent/#function-name","title":"function name","text":"<p>\u83b7\u53d6\u5f53\u524d\u72b6\u6001\u7684\u540d\u5b57 <pre><code>inline std::string_view qqmusic::QRCodeLoginEvent::name () const\n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1QRCodeLoginEvent/#function-operator","title":"function operator!=","text":"<p>\u72b6\u6001\u662f\u5426\u4e0d\u76f8\u540c <pre><code>inline bool qqmusic::QRCodeLoginEvent::operator!= (\n    const QRCodeLoginEvent &amp; e\n) \n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1QRCodeLoginEvent/#function-operator_1","title":"function operator!=","text":"<p>\u548c\u679a\u4e3e\u76f4\u63a5\u6bd4\u8f83\u662f\u5426\u4e0d\u76f8\u540c <pre><code>inline bool qqmusic::QRCodeLoginEvent::operator!= (\n    Status stat\n) \n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1QRCodeLoginEvent/#function-operator_2","title":"function operator==","text":"<p>\u72b6\u6001\u662f\u5426\u76f8\u540c <pre><code>inline bool qqmusic::QRCodeLoginEvent::operator== (\n    const QRCodeLoginEvent &amp; e\n) \n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1QRCodeLoginEvent/#function-operator_3","title":"function operator==","text":"<p>\u548c\u679a\u4e3e\u76f4\u63a5\u6bd4\u8f83\u662f\u5426\u76f8\u540c <pre><code>inline bool qqmusic::QRCodeLoginEvent::operator== (\n    Status stat\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/login.h</code></p>"},{"location":"dictionary/structqqmusic_1_1QRCodeLoginResult/","title":"Struct qqmusic::QRCodeLoginResult","text":"<p>ClassList &gt; qqmusic &gt; QRCodeLoginResult</p> <p>\u4e8c\u7ef4\u7801\u767b\u9646\u7ed3\u679c\u5c01\u88c5 </p> <ul> <li><code>#include &lt;login.h&gt;</code></li> </ul>"},{"location":"dictionary/structqqmusic_1_1QRCodeLoginResult/#public-attributes","title":"Public Attributes","text":"Type Name std::optional&lt; utils::Credential &gt; credential QRCodeLoginEvent status   = <code>{QRCodeLoginEvent::Status::OTHER}</code>"},{"location":"dictionary/structqqmusic_1_1QRCodeLoginResult/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"dictionary/structqqmusic_1_1QRCodeLoginResult/#variable-credential","title":"variable credential","text":"<pre><code>std::optional&lt;utils::Credential&gt; qqmusic::QRCodeLoginResult::credential;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1QRCodeLoginResult/#variable-status","title":"variable status","text":"<pre><code>QRCodeLoginEvent qqmusic::QRCodeLoginResult::status;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/login.h</code></p>"},{"location":"dictionary/classqqmusic_1_1SongFileType/","title":"Class qqmusic::SongFileType","text":"<p>ClassList &gt; qqmusic &gt; SongFileType</p> <p>\u672a\u52a0\u5bc6\u7684\u6b4c\u66f2\u6587\u4ef6\u7c7b\u679a\u4e3e More...</p> <ul> <li><code>#include &lt;song.h&gt;</code></li> </ul> <p>Inherits the following classes: qqmusic::BaseMediaFileType</p>"},{"location":"dictionary/classqqmusic_1_1SongFileType/#public-types","title":"Public Types","text":"Type Name enum Type \u672a\u52a0\u5bc6\u6b4c\u66f2\u7c7b\u578b\u679a\u4e3e"},{"location":"dictionary/classqqmusic_1_1SongFileType/#public-functions","title":"Public Functions","text":"Type Name SongFileType (Type type) \u901a\u8fc7\u7c7b\u578b\u679a\u4e3e\u521d\u59cb\u5316 SongFileType () \u9ed8\u8ba4\u521d\u59cb\u5316\u51fd\u6570, \u9ed8\u8ba4\u683c\u5f0f: MP3_128\u683c\u5f0f virtual bool encrypted () override\u8be5\u683c\u5f0f\u662f\u5426\u52a0\u5bc6 virtual std::string_view expandation () override\u83b7\u53d6\u6b4c\u66f2\u7c7bID\u6269\u5c55 virtual std::string_view prefix () override\u83b7\u53d6\u6b4c\u66f2\u7c7bID\u524d\u7f00 ~SongFileType () override"},{"location":"dictionary/classqqmusic_1_1SongFileType/#public-functions-inherited-from-qqmusicbasemediafiletype","title":"Public Functions inherited from qqmusic::BaseMediaFileType","text":"<p>See qqmusic::BaseMediaFileType</p> Type Name virtual bool encrypted () = 0\u662f\u5426\u52a0\u5bc6 virtual std::string_view expandation () = 0\u83b7\u53d6\u6269\u5c55\u540d virtual std::string_view prefix () = 0\u83b7\u53d6\u57fa\u7c7bID virtual ~BaseMediaFileType () = default"},{"location":"dictionary/classqqmusic_1_1SongFileType/#detailed-description","title":"Detailed Description","text":"<p>See also: BaseMediaFileType </p>"},{"location":"dictionary/classqqmusic_1_1SongFileType/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"dictionary/classqqmusic_1_1SongFileType/#enum-type","title":"enum Type","text":"<p>\u672a\u52a0\u5bc6\u6b4c\u66f2\u7c7b\u578b\u679a\u4e3e <pre><code>enum qqmusic::SongFileType::Type {\n    MASTER,\n    ATMOS_2,\n    ATMOS_51,\n    FLAC,\n    OGG_640,\n    OGG_320,\n    OGG_192,\n    OGG_96,\n    MP3_320,\n    MP3_128,\n    ACC_192,\n    ACC_96,\n    ACC_48\n};\n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1SongFileType/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/classqqmusic_1_1SongFileType/#function-songfiletype-12","title":"function SongFileType [1/2]","text":"<p>\u901a\u8fc7\u7c7b\u578b\u679a\u4e3e\u521d\u59cb\u5316 <pre><code>inline qqmusic::SongFileType::SongFileType (\n    Type type\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>type</code> \u7c7b\u578b\u679a\u4e3e</li> </ul> <p>See also: SongFileType::Type</p> <p>Exception:</p> <ul> <li><code>\u82e5\u63d0\u4f9b\u7684\u679a\u4e3e\u4e0d\u5408\u6cd5</code> </li> </ul>"},{"location":"dictionary/classqqmusic_1_1SongFileType/#function-songfiletype-22","title":"function SongFileType [2/2]","text":"<p>\u9ed8\u8ba4\u521d\u59cb\u5316\u51fd\u6570, \u9ed8\u8ba4\u683c\u5f0f: MP3_128\u683c\u5f0f <pre><code>inline qqmusic::SongFileType::SongFileType () \n</code></pre></p> <p>See also: SongFileType::Type </p>"},{"location":"dictionary/classqqmusic_1_1SongFileType/#function-encrypted","title":"function encrypted","text":"<p>\u8be5\u683c\u5f0f\u662f\u5426\u52a0\u5bc6 <pre><code>inline virtual bool qqmusic::SongFileType::encrypted () override\n</code></pre></p> <p>Returns:</p> <p>\u603b\u662f\u8fd4\u56de<code>false</code> </p> <p>Implements qqmusic::BaseMediaFileType::encrypted</p>"},{"location":"dictionary/classqqmusic_1_1SongFileType/#function-expandation","title":"function expandation","text":"<p>\u83b7\u53d6\u6b4c\u66f2\u7c7bID\u6269\u5c55 <pre><code>inline virtual std::string_view qqmusic::SongFileType::expandation () override\n</code></pre></p> <p>Returns:</p> <p>\u8fd4\u56de<code>std::string</code>\u683c\u5f0f\u7684\u7c7b\u578b\u6269\u5c55\u540d </p> <p>Implements qqmusic::BaseMediaFileType::expandation</p>"},{"location":"dictionary/classqqmusic_1_1SongFileType/#function-prefix","title":"function prefix","text":"<p>\u83b7\u53d6\u6b4c\u66f2\u7c7bID\u524d\u7f00 <pre><code>inline virtual std::string_view qqmusic::SongFileType::prefix () override\n</code></pre></p> <p>Returns:</p> <p>\u8fd4\u56de<code>std::string</code>\u683c\u5f0f\u7684\u7c7b\u578b\u524d\u7f00 </p> <p>Implements qqmusic::BaseMediaFileType::prefix</p>"},{"location":"dictionary/classqqmusic_1_1SongFileType/#function-songfiletype","title":"function ~SongFileType","text":"<pre><code>qqmusic::SongFileType::~SongFileType () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/song.h</code></p>"},{"location":"dictionary/structqqmusic_1_1SongInfo/","title":"Struct qqmusic::SongInfo","text":"<p>ClassList &gt; qqmusic &gt; SongInfo</p>"},{"location":"dictionary/structqqmusic_1_1SongInfo/#public-attributes","title":"Public Attributes","text":"Type Name std::optional&lt; std::string &gt; ekey   = <code>std::nullopt</code> std::string mid std::optional&lt; std::string &gt; url   = <code>std::nullopt</code>"},{"location":"dictionary/structqqmusic_1_1SongInfo/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"dictionary/structqqmusic_1_1SongInfo/#variable-ekey","title":"variable ekey","text":"<pre><code>std::optional&lt;std::string&gt; qqmusic::SongInfo::ekey;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1SongInfo/#variable-mid","title":"variable mid","text":"<pre><code>std::string qqmusic::SongInfo::mid;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1SongInfo/#variable-url","title":"variable url","text":"<pre><code>std::optional&lt;std::string&gt; qqmusic::SongInfo::url;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/song.h</code></p>"},{"location":"dictionary/classqqmusic_1_1TabType/","title":"Class qqmusic::TabType","text":"<p>ClassList &gt; qqmusic &gt; TabType</p> <p>\u6807\u7b7e\u7c7b </p> <ul> <li><code>#include &lt;singer.h&gt;</code></li> </ul>"},{"location":"dictionary/classqqmusic_1_1TabType/#public-types","title":"Public Types","text":"Type Name enum Type \u6807\u7b7e\u7c7b\u578b\u679a\u4e3e"},{"location":"dictionary/classqqmusic_1_1TabType/#public-functions","title":"Public Functions","text":"Type Name TabType () = delete\u4f7f\u7528\u679a\u4e3e\u503c\u521d\u59cb\u5316\u6807\u7b7e\u7c7b TabType (Type type)  std::string get_id () const\u83b7\u53d6tab id std::string get_name () const\u83b7\u53d6tab\u540d\u79f0"},{"location":"dictionary/classqqmusic_1_1TabType/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"dictionary/classqqmusic_1_1TabType/#enum-type","title":"enum Type","text":"<p>\u6807\u7b7e\u7c7b\u578b\u679a\u4e3e <pre><code>enum qqmusic::TabType::Type {\n    WIKI,\n    ALBUM,\n    COMPOSER,\n    LYRICIST,\n    PRODUCER,\n    ARRANGER,\n    MUSICIAN,\n    SONG,\n    VIDEO\n};\n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1TabType/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/classqqmusic_1_1TabType/#function-tabtype-12","title":"function TabType [1/2]","text":"<p>\u4f7f\u7528\u679a\u4e3e\u503c\u521d\u59cb\u5316\u6807\u7b7e\u7c7b <pre><code>qqmusic::TabType::TabType () = delete\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>type</code> \u6807\u7b7e\u7c7b\u578b\u679a\u4e3e</li> </ul> <p>Exception:</p> <ul> <li><code>\u82e5\u63d0\u4f9b\u7684\u679a\u4e3e\u503c\u4e0d\u5408\u6cd5</code> </li> </ul>"},{"location":"dictionary/classqqmusic_1_1TabType/#function-tabtype-22","title":"function TabType [2/2]","text":"<pre><code>inline qqmusic::TabType::TabType (\n    Type type\n) \n</code></pre>"},{"location":"dictionary/classqqmusic_1_1TabType/#function-get_id","title":"function get_id","text":"<p>\u83b7\u53d6tab id <pre><code>inline std::string qqmusic::TabType::get_id () const\n</code></pre></p> <p>Returns:</p> <p>std::string\u683c\u5f0ftab id </p>"},{"location":"dictionary/classqqmusic_1_1TabType/#function-get_name","title":"function get_name","text":"<p>\u83b7\u53d6tab\u540d\u79f0 <pre><code>inline std::string qqmusic::TabType::get_name () const\n</code></pre></p> <p>Returns:</p> <p>std::string\u683c\u5f0ftab name </p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/singer.h</code></p>"},{"location":"dictionary/namespaceqqmusic_1_1crypto/","title":"Namespace qqmusic::crypto","text":"<p>Namespace List &gt; qqmusic &gt; crypto</p>"},{"location":"dictionary/namespaceqqmusic_1_1crypto/#namespaces","title":"Namespaces","text":"Type Name namespace TeaCipher"},{"location":"dictionary/namespaceqqmusic_1_1crypto/#classes","title":"Classes","text":"Type Name class Cipher class Decoder class KeyDerive class MapCipher class RC4Cipher"},{"location":"dictionary/namespaceqqmusic_1_1crypto/#public-functions","title":"Public Functions","text":"Type Name bool read2buf (qqmusic::utils::buffer &amp;&amp; buf)"},{"location":"dictionary/namespaceqqmusic_1_1crypto/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/namespaceqqmusic_1_1crypto/#function-read2buf","title":"function read2buf","text":"<pre><code>bool qqmusic::crypto::read2buf (\n    qqmusic::utils::buffer &amp;&amp; buf\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/crypto/cipher_map.cc</code></p>"},{"location":"dictionary/classqqmusic_1_1crypto_1_1Cipher/","title":"Class qqmusic::crypto::Cipher","text":"<p>ClassList &gt; qqmusic &gt; crypto &gt; Cipher</p> <p>Inherited by the following classes: qqmusic::crypto::MapCipher,  qqmusic::crypto::RC4Cipher</p>"},{"location":"dictionary/classqqmusic_1_1crypto_1_1Cipher/#public-functions","title":"Public Functions","text":"Type Name virtual void decrypt (qqmusic::utils::buffer &amp; buf, size_t offset) = 0\u5bc6\u94a5\u89e3\u5bc6\u7b97\u6cd5 virtual ~Cipher () = default"},{"location":"dictionary/classqqmusic_1_1crypto_1_1Cipher/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/classqqmusic_1_1crypto_1_1Cipher/#function-decrypt","title":"function decrypt","text":"<p>\u5bc6\u94a5\u89e3\u5bc6\u7b97\u6cd5 <pre><code>virtual void qqmusic::crypto::Cipher::decrypt (\n    qqmusic::utils::buffer &amp; buf,\n    size_t offset\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buf</code> \u5f85\u89e3\u5bc6\u7684\u5bc6\u94a5 </li> <li><code>offset</code> \u504f\u79fb\u91cf </li> </ul>"},{"location":"dictionary/classqqmusic_1_1crypto_1_1Cipher/#function-cipher","title":"function ~Cipher","text":"<pre><code>virtual qqmusic::crypto::Cipher::~Cipher () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/crypto/cipher.h</code></p>"},{"location":"dictionary/classqqmusic_1_1crypto_1_1Decoder/","title":"Class qqmusic::crypto::Decoder","text":"<p>ClassList &gt; qqmusic &gt; crypto &gt; Decoder</p>"},{"location":"dictionary/classqqmusic_1_1crypto_1_1Decoder/#public-functions","title":"Public Functions","text":"Type Name Decoder (std::string &amp;&amp; ekey) \u89e3\u7801\u5668\u6784\u9020\u51fd\u6570 bool decrypt () \u89e3\u7801\u5668\u5b8c\u6574\u89e3\u7801\u8fc7\u7a0b bool read2buf (qqmusic::utils::buffer &amp;&amp; buf) \u5b58\u53d6\u5f85\u89e3\u5bc6\u6570\u636e\u5230 buf_in \u4e2d"},{"location":"dictionary/classqqmusic_1_1crypto_1_1Decoder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/classqqmusic_1_1crypto_1_1Decoder/#function-decoder","title":"function Decoder","text":"<p>\u89e3\u7801\u5668\u6784\u9020\u51fd\u6570 <pre><code>explicit qqmusic::crypto::Decoder::Decoder (\n    std::string &amp;&amp; ekey\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ekey</code> \u9700\u8981\u4f20\u5165\u52a0\u5bc6\u7684\u5bc6\u94a5 </li> </ul>"},{"location":"dictionary/classqqmusic_1_1crypto_1_1Decoder/#function-decrypt","title":"function decrypt","text":"<p>\u89e3\u7801\u5668\u5b8c\u6574\u89e3\u7801\u8fc7\u7a0b <pre><code>bool qqmusic::crypto::Decoder::decrypt () \n</code></pre></p> <ul> <li>\u89e3\u5bc6\u5bc6\u94a5</li> <li>\u521d\u59cb\u5316\u89e3\u5bc6\u7b97\u6cd5</li> <li>\u8fdb\u884c\u89e3\u5bc6 </li> </ul>"},{"location":"dictionary/classqqmusic_1_1crypto_1_1Decoder/#function-read2buf","title":"function read2buf","text":"<p>\u5b58\u53d6\u5f85\u89e3\u5bc6\u6570\u636e\u5230 buf_in \u4e2d <pre><code>bool qqmusic::crypto::Decoder::read2buf (\n    qqmusic::utils::buffer &amp;&amp; buf\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buf</code> \u7f13\u51b2\u533a\uff08\u5b58\u653e\u672a\u89e3\u5bc6\u7684\u6570\u636e\uff09 </li> </ul> <p>The documentation for this class was generated from the following file <code>include/qqmusic/crypto/qmc.h</code></p>"},{"location":"dictionary/classqqmusic_1_1crypto_1_1KeyDerive/","title":"Class qqmusic::crypto::KeyDerive","text":"<p>ClassList &gt; qqmusic &gt; crypto &gt; KeyDerive</p>"},{"location":"dictionary/classqqmusic_1_1crypto_1_1KeyDerive/#public-static-functions","title":"Public Static Functions","text":"Type Name qqmusic::utils::buffer derive (qqmusic::utils::buffer &amp;&amp; raw_key) \u4e3b\u8981\u7684\u5bc6\u94a5\u6d3e\u751f\u51fd\u6570\uff0c\u5904\u7406\u6d3e\u751f\u903b\u8f91 \u5f53\u68c0\u6d4b\u5230V2\u524d\u7f00\u65f6\uff0c\u5148\u8fdb\u884cV2\u89e3\u5bc6\uff0c\u7136\u540e\u8fdb\u884cV1\u89e3\u5bc6 \u5982\u679c\u6ca1\u6709V2\u524d\u7f00\uff0c\u5219\u76f4\u63a5\u8fdb\u884cV1\u89e3\u5bc6"},{"location":"dictionary/classqqmusic_1_1crypto_1_1KeyDerive/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"dictionary/classqqmusic_1_1crypto_1_1KeyDerive/#function-derive","title":"function derive","text":"<p>\u4e3b\u8981\u7684\u5bc6\u94a5\u6d3e\u751f\u51fd\u6570\uff0c\u5904\u7406\u6d3e\u751f\u903b\u8f91 \u5f53\u68c0\u6d4b\u5230V2\u524d\u7f00\u65f6\uff0c\u5148\u8fdb\u884cV2\u89e3\u5bc6\uff0c\u7136\u540e\u8fdb\u884cV1\u89e3\u5bc6 \u5982\u679c\u6ca1\u6709V2\u524d\u7f00\uff0c\u5219\u76f4\u63a5\u8fdb\u884cV1\u89e3\u5bc6 <pre><code>static qqmusic::utils::buffer qqmusic::crypto::KeyDerive::derive (\n    qqmusic::utils::buffer &amp;&amp; raw_key\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>raw_key</code> \u539f\u59cb\u5bc6\u94a5 </li> </ul> <p>Returns:</p> <p>qqmusic::utils::buffer \u89e3\u5bc6\u540e\u7684\u5bc6\u94a5 </p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/crypto/key_derive.h</code></p>"},{"location":"dictionary/classqqmusic_1_1crypto_1_1MapCipher/","title":"Class qqmusic::crypto::MapCipher","text":"<p>ClassList &gt; qqmusic &gt; crypto &gt; MapCipher</p> <p>Inherits the following classes: qqmusic::crypto::Cipher</p>"},{"location":"dictionary/classqqmusic_1_1crypto_1_1MapCipher/#public-functions","title":"Public Functions","text":"Type Name MapCipher (const std::vector&lt; uint8_t &gt; &amp; key)  virtual void decrypt (qqmusic::utils::buffer &amp; buf, size_t offset) overridemap\u89e3\u5bc6\u7b97\u6cd5"},{"location":"dictionary/classqqmusic_1_1crypto_1_1MapCipher/#public-functions-inherited-from-qqmusiccryptocipher","title":"Public Functions inherited from qqmusic::crypto::Cipher","text":"<p>See qqmusic::crypto::Cipher</p> Type Name virtual void decrypt (qqmusic::utils::buffer &amp; buf, size_t offset) = 0\u5bc6\u94a5\u89e3\u5bc6\u7b97\u6cd5 virtual ~Cipher () = default"},{"location":"dictionary/classqqmusic_1_1crypto_1_1MapCipher/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/classqqmusic_1_1crypto_1_1MapCipher/#function-mapcipher","title":"function MapCipher","text":"<pre><code>explicit qqmusic::crypto::MapCipher::MapCipher (\n    const std::vector&lt; uint8_t &gt; &amp; key\n) \n</code></pre>"},{"location":"dictionary/classqqmusic_1_1crypto_1_1MapCipher/#function-decrypt","title":"function decrypt","text":"<p>map\u89e3\u5bc6\u7b97\u6cd5 <pre><code>virtual void qqmusic::crypto::MapCipher::decrypt (\n    qqmusic::utils::buffer &amp; buf,\n    size_t offset\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buf</code> \u5f85\u89e3\u5bc6\u7684\u5bc6\u94a5 </li> <li><code>offset</code> \u504f\u79fb\u91cf </li> </ul> <p>Implements qqmusic::crypto::Cipher::decrypt</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/crypto/cipher_map.h</code></p>"},{"location":"dictionary/classqqmusic_1_1crypto_1_1RC4Cipher/","title":"Class qqmusic::crypto::RC4Cipher","text":"<p>ClassList &gt; qqmusic &gt; crypto &gt; RC4Cipher</p> <p>Inherits the following classes: qqmusic::crypto::Cipher</p>"},{"location":"dictionary/classqqmusic_1_1crypto_1_1RC4Cipher/#public-functions","title":"Public Functions","text":"Type Name RC4Cipher (const std::vector&lt; uint8_t &gt; &amp; key)  virtual void decrypt (qqmusic::utils::buffer &amp; buf, size_t offset) overrideRC4\u89e3\u5bc6\u7b97\u6cd5"},{"location":"dictionary/classqqmusic_1_1crypto_1_1RC4Cipher/#public-functions-inherited-from-qqmusiccryptocipher","title":"Public Functions inherited from qqmusic::crypto::Cipher","text":"<p>See qqmusic::crypto::Cipher</p> Type Name virtual void decrypt (qqmusic::utils::buffer &amp; buf, size_t offset) = 0\u5bc6\u94a5\u89e3\u5bc6\u7b97\u6cd5 virtual ~Cipher () = default"},{"location":"dictionary/classqqmusic_1_1crypto_1_1RC4Cipher/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/classqqmusic_1_1crypto_1_1RC4Cipher/#function-rc4cipher","title":"function RC4Cipher","text":"<pre><code>explicit qqmusic::crypto::RC4Cipher::RC4Cipher (\n    const std::vector&lt; uint8_t &gt; &amp; key\n) \n</code></pre>"},{"location":"dictionary/classqqmusic_1_1crypto_1_1RC4Cipher/#function-decrypt","title":"function decrypt","text":"<p>RC4\u89e3\u5bc6\u7b97\u6cd5 <pre><code>virtual void qqmusic::crypto::RC4Cipher::decrypt (\n    qqmusic::utils::buffer &amp; buf,\n    size_t offset\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buf</code> \u5f85\u89e3\u5bc6\u7684\u5bc6\u94a5 </li> <li><code>offset</code> \u504f\u79fb\u91cf </li> </ul> <p>Implements qqmusic::crypto::Cipher::decrypt</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/crypto/cipher_rc4.h</code></p>"},{"location":"dictionary/namespaceqqmusic_1_1crypto_1_1TeaCipher/","title":"Namespace qqmusic::crypto::TeaCipher","text":"<p>Namespace List &gt; qqmusic &gt; crypto &gt; TeaCipher</p>"},{"location":"dictionary/namespaceqqmusic_1_1crypto_1_1TeaCipher/#public-functions","title":"Public Functions","text":"Type Name void decrypt (qqmusic::utils::buffer &amp; buf, size_t offset, const std::vector&lt; uint8_t &gt; &amp; key) tea\u89e3\u5bc6\uff0c\u6bcf\u6b21\u89e3\u5bc68\u5b57\u8282"},{"location":"dictionary/namespaceqqmusic_1_1crypto_1_1TeaCipher/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/namespaceqqmusic_1_1crypto_1_1TeaCipher/#function-decrypt","title":"function decrypt","text":"<p>tea\u89e3\u5bc6\uff0c\u6bcf\u6b21\u89e3\u5bc68\u5b57\u8282 <pre><code>void qqmusic::crypto::TeaCipher::decrypt (\n    qqmusic::utils::buffer &amp; buf,\n    size_t offset,\n    const std::vector&lt; uint8_t &gt; &amp; key\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buf</code> \u5f85\u89e3\u5bc6\u7684\u5bc6\u94a5 </li> <li><code>offset</code> \u504f\u79fb\u91cf </li> <li><code>key</code> \u89e3\u5bc6\u9700\u8981\u7528\u5230\u7684\u5bc6\u94a5\uff0c\u5728 key_derive.cc \u4e2d\u751f\u6210 </li> </ul> <p>The documentation for this class was generated from the following file <code>include/qqmusic/crypto/cipher_tea.h</code></p>"},{"location":"dictionary/namespaceqqmusic_1_1details/","title":"Namespace qqmusic::details","text":"<p>Namespace List &gt; qqmusic &gt; details</p> <p>More...</p>"},{"location":"dictionary/namespaceqqmusic_1_1details/#classes","title":"Classes","text":"Type Name class Api Api\u7c7b, \u7b80\u5316\u8bf7\u6c42\u62a5\u6587\u7ec4\u88c5\u548c\u8fd4\u56de\u62a5\u6587\u89e3\u6790\u8fc7\u7a0b struct ApiConfig Api\u76f8\u5173\u5e38\u91cf struct NetworkContext \u6253\u5305\u7684\u4e0a\u4e0b\u6587 struct RequestParam \u5305\u88c5\u8bf7\u6c42\u6240\u9700\u7684\u53c2\u6570"},{"location":"dictionary/namespaceqqmusic_1_1details/#public-types","title":"Public Types","text":"Type Name enum tripledes_crypt_mode typedef std::vector&lt; std::vector&lt; std::vector&lt; uint32_t &gt; &gt; &gt; tripledes_key_schedule"},{"location":"dictionary/namespaceqqmusic_1_1details/#public-attributes","title":"Public Attributes","text":"Type Name const char VERSION   = <code>\"13.2.5.8\"</code>Api\u7248\u672c\u53f7 const uint64_t VERSION_CODE   = <code>13020508</code>\u7248\u672c\u4ee3\u7801"},{"location":"dictionary/namespaceqqmusic_1_1details/#public-functions","title":"Public Functions","text":"Type Name void tripledes_crypt (utils::buffer &amp; buf_in, utils::buffer &amp; buf_out, tripledes_key_schedule key_schedule)  tripledes_key_schedule tripledes_key_setup (const uint8_t * key_head, size_t key_size, tripledes_crypt_mode mode)"},{"location":"dictionary/namespaceqqmusic_1_1details/#public-static-functions","title":"Public Static Functions","text":"Type Name uint32_t bitnum (const uint8_t * head, size_t size, uint32_t b, uint32_t c)  uint32_t bitnum_intl (uint32_t a, uint32_t b, uint32_t c)  uint32_t bitnum_intr (uint32_t a, uint32_t b, uint32_t c)  void crypt (utils::buffer &amp; buf, std::vector&lt; std::vector&lt; uint32_t &gt; &gt; key)  void initial_permutation (uint32_t * a, uint32_t * b, utils::buffer &amp; buf)  void inverse_permutation (uint32_t a, uint32_t b, utils::buffer &amp; buf)  std::vector&lt; std::vector&lt; uint32_t &gt; &gt; key_schedule (const uint8_t * key_head, size_t key_size, tripledes_crypt_mode mode)  uint32_t sbox_bit (uint32_t a)  uint32_t transform (uint32_t state, std::vector&lt; uint32_t &gt; key)"},{"location":"dictionary/namespaceqqmusic_1_1details/#detailed-description","title":"Detailed Description","text":"<p>----------------------------qqmusic/details/tripledes.h------------------------------------ </p>"},{"location":"dictionary/namespaceqqmusic_1_1details/#3des-decrypt-functions-for-qrc-decoder","title":"3des decrypt functions, for qrc-decoder.","text":""},{"location":"dictionary/namespaceqqmusic_1_1details/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"dictionary/namespaceqqmusic_1_1details/#enum-tripledes_crypt_mode","title":"enum tripledes_crypt_mode","text":"<pre><code>enum qqmusic::details::tripledes_crypt_mode {\n    encrypt,\n    decrypt\n};\n</code></pre>"},{"location":"dictionary/namespaceqqmusic_1_1details/#typedef-tripledes_key_schedule","title":"typedef tripledes_key_schedule","text":"<pre><code>using qqmusic::details::tripledes_key_schedule = typedef std::vector&lt;std::vector&lt;std::vector&lt;uint32_t&gt; &gt;&gt;;\n</code></pre>"},{"location":"dictionary/namespaceqqmusic_1_1details/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"dictionary/namespaceqqmusic_1_1details/#variable-version","title":"variable VERSION","text":"<p>Api\u7248\u672c\u53f7 <pre><code>const char qqmusic::details::VERSION[];\n</code></pre></p>"},{"location":"dictionary/namespaceqqmusic_1_1details/#variable-version_code","title":"variable VERSION_CODE","text":"<p>\u7248\u672c\u4ee3\u7801 <pre><code>const uint64_t qqmusic::details::VERSION_CODE;\n</code></pre></p>"},{"location":"dictionary/namespaceqqmusic_1_1details/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/namespaceqqmusic_1_1details/#function-tripledes_crypt","title":"function tripledes_crypt","text":"<pre><code>void qqmusic::details::tripledes_crypt (\n    utils::buffer &amp; buf_in,\n    utils::buffer &amp; buf_out,\n    tripledes_key_schedule key_schedule\n) \n</code></pre>"},{"location":"dictionary/namespaceqqmusic_1_1details/#function-tripledes_key_setup","title":"function tripledes_key_setup","text":"<pre><code>tripledes_key_schedule qqmusic::details::tripledes_key_setup (\n    const uint8_t * key_head,\n    size_t key_size,\n    tripledes_crypt_mode mode\n) \n</code></pre>"},{"location":"dictionary/namespaceqqmusic_1_1details/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"dictionary/namespaceqqmusic_1_1details/#function-bitnum","title":"function bitnum","text":"<pre><code>static uint32_t qqmusic::details::bitnum (\n    const uint8_t * head,\n    size_t size,\n    uint32_t b,\n    uint32_t c\n) \n</code></pre>"},{"location":"dictionary/namespaceqqmusic_1_1details/#function-bitnum_intl","title":"function bitnum_intl","text":"<pre><code>static uint32_t qqmusic::details::bitnum_intl (\n    uint32_t a,\n    uint32_t b,\n    uint32_t c\n) \n</code></pre>"},{"location":"dictionary/namespaceqqmusic_1_1details/#function-bitnum_intr","title":"function bitnum_intr","text":"<pre><code>static uint32_t qqmusic::details::bitnum_intr (\n    uint32_t a,\n    uint32_t b,\n    uint32_t c\n) \n</code></pre>"},{"location":"dictionary/namespaceqqmusic_1_1details/#function-crypt","title":"function crypt","text":"<pre><code>static void qqmusic::details::crypt (\n    utils::buffer &amp; buf,\n    std::vector&lt; std::vector&lt; uint32_t &gt; &gt; key\n) \n</code></pre>"},{"location":"dictionary/namespaceqqmusic_1_1details/#function-initial_permutation","title":"function initial_permutation","text":"<pre><code>static void qqmusic::details::initial_permutation (\n    uint32_t * a,\n    uint32_t * b,\n    utils::buffer &amp; buf\n) \n</code></pre>"},{"location":"dictionary/namespaceqqmusic_1_1details/#function-inverse_permutation","title":"function inverse_permutation","text":"<pre><code>static void qqmusic::details::inverse_permutation (\n    uint32_t a,\n    uint32_t b,\n    utils::buffer &amp; buf\n) \n</code></pre>"},{"location":"dictionary/namespaceqqmusic_1_1details/#function-key_schedule","title":"function key_schedule","text":"<pre><code>static std::vector&lt; std::vector&lt; uint32_t &gt; &gt; qqmusic::details::key_schedule (\n    const uint8_t * key_head,\n    size_t key_size,\n    tripledes_crypt_mode mode\n) \n</code></pre>"},{"location":"dictionary/namespaceqqmusic_1_1details/#function-sbox_bit","title":"function sbox_bit","text":"<pre><code>static uint32_t qqmusic::details::sbox_bit (\n    uint32_t a\n) \n</code></pre>"},{"location":"dictionary/namespaceqqmusic_1_1details/#function-transform","title":"function transform","text":"<pre><code>static uint32_t qqmusic::details::transform (\n    uint32_t state,\n    std::vector&lt; uint32_t &gt; key\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/details/api.cc</code></p>"},{"location":"dictionary/classqqmusic_1_1details_1_1Api/","title":"Class qqmusic::details::Api","text":"<p>ClassList &gt; qqmusic &gt; details &gt; Api</p> <p>Api\u7c7b, \u7b80\u5316\u8bf7\u6c42\u62a5\u6587\u7ec4\u88c5\u548c\u8fd4\u56de\u62a5\u6587\u89e3\u6790\u8fc7\u7a0b </p> <ul> <li><code>#include &lt;api.h&gt;</code></li> </ul>"},{"location":"dictionary/classqqmusic_1_1details_1_1Api/#public-functions","title":"Public Functions","text":"Type Name Api (utils::Session &amp; session, std::string module, std::string method, utils::Credential credential={}, nlohmann::json common={{}}) \u6784\u9020\u51fd\u6570 qqmusic::Result&lt; nlohmann::json &gt; parse_response (utils::buffer &amp;&amp; response) \u5c06\u8fd4\u56de\u62a5\u6587\u89e3\u6790\u6210Json\u7ed3\u679c, \u5fc5\u987b\u662f\u7531Api\u7c7b\u4ea7\u751f\u7684\u8bf7\u6c42\u4ea7\u751f\u7684\u7ed3\u679c qqmusic::Task&lt; qqmusic::Result&lt; RequestParam &gt; &gt; prepare_request (const nlohmann::json &amp; params, bool verify=false) \u4f7f\u7528\u7ed9\u5b9a\u7684\u53c2\u6570\u7ec4\u88c5\u8bf7\u6c42"},{"location":"dictionary/classqqmusic_1_1details_1_1Api/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/classqqmusic_1_1details_1_1Api/#function-api","title":"function Api","text":"<p>\u6784\u9020\u51fd\u6570 <pre><code>inline qqmusic::details::Api::Api (\n    utils::Session &amp; session,\n    std::string module,\n    std::string method,\n    utils::Credential credential={},\n    nlohmann::json common={{}}\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>session</code> session\u5b9e\u4f8b\u5f15\u7528 </li> <li><code>module</code> Api\u6240\u5c5e\u6a21\u5757 </li> <li><code>method</code> Api\u8bf7\u6c42\u65b9\u6cd5 </li> <li><code>credential</code> \u51ed\u8bc1, \u9ed8\u8ba4\u4e3a\u7a7a </li> <li><code>common</code> \u516c\u5171\u53c2\u6570</li> </ul> <p>Note:</p> <p>credential\u7684\u53d6\u820d\u4f18\u5148\u7ea7: <code>\u4f20\u5165\u7684\u53c2\u6570 &gt; session(\u5168\u5c40\u9ed8\u8ba4) &gt; \u9ed8\u8ba4\u521d\u59cb\u5316credential</code> </p>"},{"location":"dictionary/classqqmusic_1_1details_1_1Api/#function-parse_response","title":"function parse_response","text":"<p>\u5c06\u8fd4\u56de\u62a5\u6587\u89e3\u6790\u6210Json\u7ed3\u679c, \u5fc5\u987b\u662f\u7531Api\u7c7b\u4ea7\u751f\u7684\u8bf7\u6c42\u4ea7\u751f\u7684\u7ed3\u679c <pre><code>qqmusic::Result&lt; nlohmann::json &gt; qqmusic::details::Api::parse_response (\n    utils::buffer &amp;&amp; response\n) \n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1details_1_1Api/#function-prepare_request","title":"function prepare_request","text":"<p>\u4f7f\u7528\u7ed9\u5b9a\u7684\u53c2\u6570\u7ec4\u88c5\u8bf7\u6c42 <pre><code>qqmusic::Task&lt; qqmusic::Result&lt; RequestParam &gt; &gt; qqmusic::details::Api::prepare_request (\n    const nlohmann::json &amp; params,\n    bool verify=false\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>params</code> \u8bf7\u6c42\u4f53\u6570\u636e\u8868\u5355 </li> <li><code>verify</code> \u662f\u5426\u9700\u8981\u5408\u6cd5\u7684Credential\u8fdb\u884c\u8bf7\u6c42</li> </ul> <p>Returns:</p> <p>\u4ea7\u751f<code>RequestParam</code>\u6253\u5305\u7684\u8bf7\u6c42\u53c2\u6570 </p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/api.h</code></p>"},{"location":"dictionary/structqqmusic_1_1details_1_1ApiConfig/","title":"Struct qqmusic::details::ApiConfig","text":"<p>ClassList &gt; qqmusic &gt; details &gt; ApiConfig</p> <p>Api\u76f8\u5173\u5e38\u91cf </p> <ul> <li><code>#include &lt;context.h&gt;</code></li> </ul>"},{"location":"dictionary/structqqmusic_1_1details_1_1ApiConfig/#public-attributes","title":"Public Attributes","text":"Type Name bool enable_sign   = <code>false</code>\u8bf7\u6c42\u53c2\u6570\u662f\u5426\u9700\u8981\u7b7e\u540d std::string enc_endpoint   = <code>\"https://u.y.qq.com/cgi-bin/musics.fcg\"</code>\u52a0\u5bc6\u63a5\u53e3url std::string endpoint   = <code>\"https://u.y.qq.com/cgi-bin/musicu.fcg\"</code>\u672a\u52a0\u5bc6\u63a5\u53e3url std::string version   = <code>[**VERSION**](namespaceqqmusic_1_1details.md#variable-version)</code> uint64_t version_code   = <code>[**VERSION\\_CODE**](namespaceqqmusic_1_1details.md#variable-version_code)</code>"},{"location":"dictionary/structqqmusic_1_1details_1_1ApiConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"dictionary/structqqmusic_1_1details_1_1ApiConfig/#variable-enable_sign","title":"variable enable_sign","text":"<p>\u8bf7\u6c42\u53c2\u6570\u662f\u5426\u9700\u8981\u7b7e\u540d <pre><code>bool qqmusic::details::ApiConfig::enable_sign;\n</code></pre></p>"},{"location":"dictionary/structqqmusic_1_1details_1_1ApiConfig/#variable-enc_endpoint","title":"variable enc_endpoint","text":"<p>\u52a0\u5bc6\u63a5\u53e3url <pre><code>std::string qqmusic::details::ApiConfig::enc_endpoint;\n</code></pre></p>"},{"location":"dictionary/structqqmusic_1_1details_1_1ApiConfig/#variable-endpoint","title":"variable endpoint","text":"<p>\u672a\u52a0\u5bc6\u63a5\u53e3url <pre><code>std::string qqmusic::details::ApiConfig::endpoint;\n</code></pre></p>"},{"location":"dictionary/structqqmusic_1_1details_1_1ApiConfig/#variable-version","title":"variable version","text":"<pre><code>std::string qqmusic::details::ApiConfig::version;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1details_1_1ApiConfig/#variable-version_code","title":"variable version_code","text":"<pre><code>uint64_t qqmusic::details::ApiConfig::version_code;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/context.h</code></p>"},{"location":"dictionary/structqqmusic_1_1details_1_1NetworkContext/","title":"Struct qqmusic::details::NetworkContext","text":"<p>ClassList &gt; qqmusic &gt; details &gt; NetworkContext</p> <p>\u6253\u5305\u7684\u4e0a\u4e0b\u6587 </p> <ul> <li><code>#include &lt;context.h&gt;</code></li> </ul>"},{"location":"dictionary/structqqmusic_1_1details_1_1NetworkContext/#public-attributes","title":"Public Attributes","text":"Type Name ApiConfig api_config qqmusic::utils::CookieJar cookies qqmusic::utils::Credential credential qqmusic::utils::Device device bool ignore_ssl_error qqmusic::utils::QimeiResult qimei std::chrono::seconds timeout"},{"location":"dictionary/structqqmusic_1_1details_1_1NetworkContext/#public-functions","title":"Public Functions","text":"Type Name NetworkContext ()"},{"location":"dictionary/structqqmusic_1_1details_1_1NetworkContext/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"dictionary/structqqmusic_1_1details_1_1NetworkContext/#variable-api_config","title":"variable api_config","text":"<pre><code>ApiConfig qqmusic::details::NetworkContext::api_config;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1details_1_1NetworkContext/#variable-cookies","title":"variable cookies","text":"<pre><code>qqmusic::utils::CookieJar qqmusic::details::NetworkContext::cookies;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1details_1_1NetworkContext/#variable-credential","title":"variable credential","text":"<pre><code>qqmusic::utils::Credential qqmusic::details::NetworkContext::credential;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1details_1_1NetworkContext/#variable-device","title":"variable device","text":"<pre><code>qqmusic::utils::Device qqmusic::details::NetworkContext::device;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1details_1_1NetworkContext/#variable-ignore_ssl_error","title":"variable ignore_ssl_error","text":"<pre><code>bool qqmusic::details::NetworkContext::ignore_ssl_error;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1details_1_1NetworkContext/#variable-qimei","title":"variable qimei","text":"<pre><code>qqmusic::utils::QimeiResult qqmusic::details::NetworkContext::qimei;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1details_1_1NetworkContext/#variable-timeout","title":"variable timeout","text":"<pre><code>std::chrono::seconds qqmusic::details::NetworkContext::timeout;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1details_1_1NetworkContext/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/structqqmusic_1_1details_1_1NetworkContext/#function-networkcontext","title":"function NetworkContext","text":"<pre><code>inline qqmusic::details::NetworkContext::NetworkContext () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/context.h</code></p>"},{"location":"dictionary/structqqmusic_1_1details_1_1RequestParam/","title":"Struct qqmusic::details::RequestParam","text":"<p>ClassList &gt; qqmusic &gt; details &gt; RequestParam</p> <p>\u5305\u88c5\u8bf7\u6c42\u6240\u9700\u7684\u53c2\u6570 </p> <ul> <li><code>#include &lt;api.h&gt;</code></li> </ul>"},{"location":"dictionary/structqqmusic_1_1details_1_1RequestParam/#public-attributes","title":"Public Attributes","text":"Type Name http::request&lt; http::string_body &gt; req boost::url url"},{"location":"dictionary/structqqmusic_1_1details_1_1RequestParam/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"dictionary/structqqmusic_1_1details_1_1RequestParam/#variable-req","title":"variable req","text":"<pre><code>http::request&lt;http::string_body&gt; qqmusic::details::RequestParam::req;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1details_1_1RequestParam/#variable-url","title":"variable url","text":"<pre><code>boost::url qqmusic::details::RequestParam::url;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/api.h</code></p>"},{"location":"dictionary/namespaceqqmusic_1_1utils/","title":"Namespace qqmusic::utils","text":"<p>Namespace List &gt; qqmusic &gt; utils</p> <p>\u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027More...</p>"},{"location":"dictionary/namespaceqqmusic_1_1utils/#classes","title":"Classes","text":"Type Name class AsyncExecutor \u5168\u5c40\u8c03\u5ea6\u5668\u7c7b struct Cookie \u4ee3\u8868\u4e00\u6761Cookie class CookieJar \u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027 class Credential \u51ed\u636e\u4fe1\u606f\u7c7b struct Device \u8bbe\u5907\u4fe1\u606f class Exception \u5168\u5c40\u5f02\u5e38\u7c7b struct OSVersion class PathManager \u8fd4\u56de\u9ed8\u8ba4\u8def\u5f84 struct QimeiResult class Session \u4e0a\u4e0b\u6587 class SessionGuard \u4e00\u4e2a <code>RAII</code> \u98ce\u683c\u7684Session\u5207\u6362\u5668 class SessionManager \u5168\u5c40\u5355\u4f8b\u7684Session\u7ba1\u7406\u5668, \u8d1f\u8d23\u7ef4\u62a4\u5168\u5c40\u4e0a\u4e0b\u6587\u6808, \u5e76\u8d1f\u8d23 <code>session</code> \u5b9e\u4f8b\u7684\u751f\u6210 class buffer \u4e8c\u8fdb\u5236\u7f13\u51b2\u533a\u7684\u7edf\u4e00\u8868\u793a"},{"location":"dictionary/namespaceqqmusic_1_1utils/#public-types","title":"Public Types","text":"Type Name typedef http::response&lt; http::dynamic_body &gt; HttpResponse enum qrc_type QRC\u6b4c\u8bcd\u79cd\u7c7b"},{"location":"dictionary/namespaceqqmusic_1_1utils/#public-functions","title":"Public Functions","text":"Type Name qqmusic::Result&lt; void &gt; cache_device (const Device &amp; device) \u5c06\u8bbe\u5907\u4fe1\u606f\u7f13\u5b58\u5230\u6587\u4ef6\u7f13\u5b58\u8def\u5f84\u4e0b\u7684 <code>device.json</code> __ boost::asio::awaitable&lt; void &gt; custom_co_spawn_entry_point (boost::asio::awaitable&lt; T, Executor &gt; aw, std::function&lt; void(std::exception_ptr, std::optional&lt; T &gt;)&gt; handler) Result&lt;&gt;\u4e0d\u80fd\u8fdb\u884c\u62f7\u8d1d, \u4e5f\u6ca1\u6709\u9ed8\u8ba4\u6784\u9020\u51fd\u6570. boost::asio::co_spawn\u4e2d\u4f1a\u8c03\u7528\u9ed8\u8ba4\u6784\u9020\u51fd\u6570. \u6240\u4ee5\u9700\u8981\u5305\u88c5\u539f\u672c\u7684\u5f02\u6b65\u4efb\u52a1, \u4f7f\u7528\u79fb\u52a8\u6784\u9020\u51fd\u6570\u6765\u6784\u9020result qqmusic::Result&lt; Device &gt; get_device_info () \u83b7\u53d6\u968f\u673a\u8bbe\u5907\u4fe1\u606f qqmusic::Result&lt; QimeiResult &gt; get_qimei (qqmusic::utils::Device &amp; device, std::string_view version)  std::string get_search_id () \u8fd4\u56de\u968f\u673a\u641c\u7d22ID uint64_t hash33 (std::string_view str, uint64_t prev=0) \u8ba1\u7b97utf-8\u5b57\u7b26\u4e32\u7684\u54c8\u5e0c\u503c buffer hex2buf (std::string_view hex) \u5341\u516d\u8fdb\u5236\u5b57\u7b26\u4e32\u8f6c\u6210buffer qqmusic::Result&lt; nlohmann::json &gt; parse_cookie (std::string_view cookie_str) \u5c06Cookie\u5b57\u7b26\u4e32\u89e3\u6790\u6210Json\u5bf9\u8c61 qqmusic::Result&lt; std::string &gt; qrc_decode (const qqmusic::utils::buffer &amp; src, qqmusic::utils::qrc_type type) \u89e3\u7801\u52a0\u5bc6\u7684QRC\u6b4c\u8bcd buffer resp2buf (http::response&lt; http::dynamic_body &gt; &amp;&amp; resp) \u5c06\u8bf7\u6c42\u56de\u590d\u62a5\u6587\u4f53\u8f6c\u6362\u6210\u4e8c\u8fdb\u5236buffer std::string sign (const nlohmann::json &amp; params) QQ\u97f3\u4e50\u8bf7\u6c42\u7b7e\u540d T sync_exec (boost::asio::io_context &amp; ioc, qqmusic::Task&lt; T &gt; task) \u540c\u6b65\u6267\u884c\u5f02\u6b65\u51fd\u6570 T sync_exec (qqmusic::Task&lt; T &gt; task) \u540c\u6b65\u6267\u884c\u5f02\u6b65\u51fd\u6570"},{"location":"dictionary/namespaceqqmusic_1_1utils/#public-static-functions","title":"Public Static Functions","text":"Type Name int decompress (const buffer &amp; src, buffer &amp; dest)  std::string head (std::span&lt; uint8_t &gt; data)  std::string middle (std::span&lt; uint8_t &gt; data)  void qmc1_decrypt (buffer &amp; src)  std::string tail (std::span&lt; uint8_t &gt; data)"},{"location":"dictionary/namespaceqqmusic_1_1utils/#detailed-description","title":"Detailed Description","text":"<p>API\u5f02\u5e38\u7c7b, \u63d0\u4f9b\u5168\u5c40\u9519\u8bef\u7c7b\u578b\u8868\u793a</p> <p>\u8bbe\u5907\u4fe1\u606f\u63d0\u4f9b\u8bbe\u5907\u4fe1\u606f\u63cf\u8ff0, \u968f\u673a\u751f\u6210\u8bbe\u5907\u4fe1\u606f</p> <p>QQ\u97f3\u4e50\u8d26\u53f7\u51ed\u636e, \u90e8\u5206\u548c\u4f1a\u5458, \u7528\u6237\u76f8\u5173\u7684Api\u9700\u8981\u4f9d\u9760\u4f20\u5165\u51ed\u636e\u624d\u80fd\u751f\u6548, \u51ed\u636e\u7531<code>Login</code>\u90e8\u5206\u7684 Api\u83b7\u53d6</p> <p>-------------------------------qqmusic/utils/common.h--------------------------------------</p> <p>@ brief \u5de5\u5177\u51fd\u6570</p> <p>@ date 2025-3-21</p> <p>------------------------------qqmusic/details/cookie.h-------------------------------------</p> <p>Date:</p> <p>2025-3-21</p> <p>-------------------------------------utils/credential.h------------------------------------</p> <p>Date:</p> <p>2025-3-21</p> <p>--------------------------------qqmusic/details/device.h-----------------------------------</p> <p>Date:</p> <p>2025-3-21</p> <p>----------------------------qqmusic/utils/exception.h--------------------------------------</p> <p>Date:</p> <p>2025-3-21</p> <p>---------------------------------------utils/paths.h--------------------------------------- PathManager provide common interface to file system.</p> <p>PathManager provide 3 types of files for io : log, cache, download * log for debug log info * cache for cached credential, identification, recent cached songs * download for downloaded media and lyrics</p> <p>Default paths are: * Linux:   * cache: $XDG_CACHE_HOME/qqmusic-api-cxx/cache OR $HOME/.cache/qqmusic-api-cxx/cache   * log: $XDG_CACHE_HOME/qqmusic-api-cxx/log OR $HOME/.cache/qqmusic-api-cxx/log   * download: $HOME/Download/qqmusic-api-cxx</p> <p>Applications can set the path by themselves Usage: </p>"},{"location":"dictionary/namespaceqqmusic_1_1utils/#icode","title":"@icode","text":"<p>\"get instance first\" auto&amp; pm = PathManager::get_instance(); auto cache_path = cm.get_cache_path();  </p>"},{"location":"dictionary/namespaceqqmusic_1_1utils/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"dictionary/namespaceqqmusic_1_1utils/#typedef-httpresponse","title":"typedef HttpResponse","text":"<pre><code>using qqmusic::utils::HttpResponse = typedef http::response&lt;http::dynamic_body&gt;;\n</code></pre>"},{"location":"dictionary/namespaceqqmusic_1_1utils/#enum-qrc_type","title":"enum qrc_type","text":"<p>QRC\u6b4c\u8bcd\u79cd\u7c7b <pre><code>enum qqmusic::utils::qrc_type {\n    cloud,\n    local\n};\n</code></pre></p>"},{"location":"dictionary/namespaceqqmusic_1_1utils/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/namespaceqqmusic_1_1utils/#function-cache_device","title":"function cache_device","text":"<p>\u5c06\u8bbe\u5907\u4fe1\u606f\u7f13\u5b58\u5230\u6587\u4ef6\u7f13\u5b58\u8def\u5f84\u4e0b\u7684 <code>device.json</code> __ <pre><code>qqmusic::Result&lt; void &gt; qqmusic::utils::cache_device (\n    const Device &amp; device\n) \n</code></pre></p> <p>See also: qqmusic::utils::PathManager </p>"},{"location":"dictionary/namespaceqqmusic_1_1utils/#function-custom_co_spawn_entry_point","title":"function custom_co_spawn_entry_point","text":"<p>Result&lt;&gt;\u4e0d\u80fd\u8fdb\u884c\u62f7\u8d1d, \u4e5f\u6ca1\u6709\u9ed8\u8ba4\u6784\u9020\u51fd\u6570. boost::asio::co_spawn\u4e2d\u4f1a\u8c03\u7528\u9ed8\u8ba4\u6784\u9020\u51fd\u6570. \u6240\u4ee5\u9700\u8981\u5305\u88c5\u539f\u672c\u7684\u5f02\u6b65\u4efb\u52a1, \u4f7f\u7528\u79fb\u52a8\u6784\u9020\u51fd\u6570\u6765\u6784\u9020result <pre><code>template&lt;typename T, typename Executor&gt;\nboost::asio::awaitable&lt; void &gt; qqmusic::utils::custom_co_spawn_entry_point (\n    boost::asio::awaitable&lt; T, Executor &gt; aw,\n    std::function&lt; void(std::exception_ptr, std::optional&lt; T &gt;)&gt; handler\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>aw</code> \u5f02\u6b65\u4efb\u52a1 </li> <li><code>handler</code> \u56de\u8c03\u51fd\u6570</li> </ul> <p>Note:</p> <p>\u56de\u8c03\u51fd\u6570\u7684\u7b7e\u540d\u662f<code>void(std::exception_ptr, std::optional&lt;T&gt;)</code>, \u524d\u4e00\u4e2a\u53c2\u6570\u662f\u5904\u7406\u5f02\u5e38\u7684, \u540e\u4e00\u4e2a\u53c2\u6570\u662f\u6b63\u5e38\u7684\u8fd4\u56de\u7ed3\u679c. \u5982\u679c\u51fa\u9519, \u5219\u8fd4\u56de\u7ed3\u679c\u7684<code>std::optional</code>\u7f6e\u7a7a</p> <p>See also: qqmusic::Result </p>"},{"location":"dictionary/namespaceqqmusic_1_1utils/#function-get_device_info","title":"function get_device_info","text":"<p>\u83b7\u53d6\u968f\u673a\u8bbe\u5907\u4fe1\u606f <pre><code>qqmusic::Result&lt; Device &gt; qqmusic::utils::get_device_info () \n</code></pre></p> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786e\u7ed3\u679c\u6216\u5f02\u5e38\u7684<code>Result &lt; Device &gt;</code> </p>"},{"location":"dictionary/namespaceqqmusic_1_1utils/#function-get_qimei","title":"function get_qimei","text":"<pre><code>qqmusic::Result&lt; QimeiResult &gt; qqmusic::utils::get_qimei (\n    qqmusic::utils::Device &amp; device,\n    std::string_view version\n) \n</code></pre>"},{"location":"dictionary/namespaceqqmusic_1_1utils/#function-get_search_id","title":"function get_search_id","text":"<p>\u8fd4\u56de\u968f\u673a\u641c\u7d22ID <pre><code>std::string qqmusic::utils::get_search_id () \n</code></pre></p>"},{"location":"dictionary/namespaceqqmusic_1_1utils/#function-hash33","title":"function hash33","text":"<p>\u8ba1\u7b97utf-8\u5b57\u7b26\u4e32\u7684\u54c8\u5e0c\u503c <pre><code>uint64_t qqmusic::utils::hash33 (\n    std::string_view str,\n    uint64_t prev=0\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>str</code> \u5f85\u6c42\u503c\u5b57\u7b26\u4e32 </li> <li><code>prev</code> \u591a\u6b21\u6c42\u503c\u65f6\u4f20\u5165\u4e0a\u6b21\u6c42\u51fa\u7684\u7ed3\u679c, \u9ed8\u8ba4\u4e3a<code>0</code></li> </ul> <p>Returns:</p> <p>64\u4f4d\u6574\u6570\u683c\u5f0f\u7684\u54c8\u5e0c </p>"},{"location":"dictionary/namespaceqqmusic_1_1utils/#function-hex2buf","title":"function hex2buf","text":"<p>\u5341\u516d\u8fdb\u5236\u5b57\u7b26\u4e32\u8f6c\u6210buffer <pre><code>buffer qqmusic::utils::hex2buf (\n    std::string_view hex\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>hex</code> \u5341\u516d\u8fdb\u5236\u7f16\u7801\u5b57\u7b26\u4e32</li> </ul> <p>Returns:</p> <p>qqmusic::utils::buffer\u7c7b\u578bbuffer </p>"},{"location":"dictionary/namespaceqqmusic_1_1utils/#function-parse_cookie","title":"function parse_cookie","text":"<p>\u5c06Cookie\u5b57\u7b26\u4e32\u89e3\u6790\u6210Json\u5bf9\u8c61 <pre><code>qqmusic::Result&lt; nlohmann::json &gt; qqmusic::utils::parse_cookie (\n    std::string_view cookie_str\n) \n</code></pre></p> <pre><code>key1=value1; key2=value2; key3=value3; key4=value4\n     |\n     v\n{\n    \"key1\": \"value1\",\n    \"key2\": \"value2\",\n    \"key3\": \"value3\",\n    \"key4\": \"value4\",\n}\n</code></pre>"},{"location":"dictionary/namespaceqqmusic_1_1utils/#function-qrc_decode","title":"function qrc_decode","text":"<p>\u89e3\u7801\u52a0\u5bc6\u7684QRC\u6b4c\u8bcd <pre><code>qqmusic::Result&lt; std::string &gt; qqmusic::utils::qrc_decode (\n    const qqmusic::utils::buffer &amp; src,\n    qqmusic::utils::qrc_type type\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>src</code> \u88ab\u52a0\u5bc6\u7684\u6b4c\u8bcd </li> <li><code>type</code> \u6b4c\u8bcd\u7c7b\u578b</li> </ul> <p>Returns:</p> <p>\u89e3\u7801\u540e\u7684\u5b57\u7b26\u4e32, \u5982\u679c\u51fa\u9519\u4f1a\u8fd4\u56de<code>Exception</code> </p>"},{"location":"dictionary/namespaceqqmusic_1_1utils/#function-resp2buf","title":"function resp2buf","text":"<p>\u5c06\u8bf7\u6c42\u56de\u590d\u62a5\u6587\u4f53\u8f6c\u6362\u6210\u4e8c\u8fdb\u5236buffer <pre><code>buffer qqmusic::utils::resp2buf (\n    http::response&lt; http::dynamic_body &gt; &amp;&amp; resp\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>resp</code> \u56de\u590d\u62a5\u6587</li> </ul> <p>Returns:</p> <p>qqmusic::utils::buffer\u7c7b\u578bbuffer </p>"},{"location":"dictionary/namespaceqqmusic_1_1utils/#function-sign","title":"function sign","text":"<p>QQ\u97f3\u4e50\u8bf7\u6c42\u7b7e\u540d <pre><code>std::string qqmusic::utils::sign (\n    const nlohmann::json &amp; params\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>params</code> \u8bf7\u6c42\u6570\u636e\u8868\u5355</li> </ul> <p>Returns:</p> <p>\u7b7e\u540d\u7ed3\u679c </p>"},{"location":"dictionary/namespaceqqmusic_1_1utils/#function-sync_exec","title":"function sync_exec","text":"<p>\u540c\u6b65\u6267\u884c\u5f02\u6b65\u51fd\u6570 <pre><code>template&lt;typename T&gt;\nT qqmusic::utils::sync_exec (\n    boost::asio::io_context &amp; ioc,\n    qqmusic::Task&lt; T &gt; task\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ioc</code> \u5f53\u524dio_context\u5f15\u7528 </li> <li><code>task</code> \u5f02\u6b65\u4efb\u52a1</li> </ul> <p>Returns:</p> <p>\u8fd4\u56de\u6267\u884c\u7ed3\u679c</p> <p>Exception:</p> <ul> <li><code>std::runtime_error</code> </li> </ul>"},{"location":"dictionary/namespaceqqmusic_1_1utils/#function-sync_exec_1","title":"function sync_exec","text":"<p>\u540c\u6b65\u6267\u884c\u5f02\u6b65\u51fd\u6570 <pre><code>template&lt;typename T&gt;\nT qqmusic::utils::sync_exec (\n    qqmusic::Task&lt; T &gt; task\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>task</code> \u5f02\u6b65\u4efb\u52a1</li> </ul> <p>Returns:</p> <p>\u8fd4\u56de\u6267\u884c\u7ed3\u679c </p>"},{"location":"dictionary/namespaceqqmusic_1_1utils/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"dictionary/namespaceqqmusic_1_1utils/#function-decompress","title":"function decompress","text":"<pre><code>static int qqmusic::utils::decompress (\n    const buffer &amp; src,\n    buffer &amp; dest\n) \n</code></pre>"},{"location":"dictionary/namespaceqqmusic_1_1utils/#function-head","title":"function head","text":"<pre><code>static std::string qqmusic::utils::head (\n    std::span&lt; uint8_t &gt; data\n) \n</code></pre>"},{"location":"dictionary/namespaceqqmusic_1_1utils/#function-middle","title":"function middle","text":"<pre><code>static std::string qqmusic::utils::middle (\n    std::span&lt; uint8_t &gt; data\n) \n</code></pre>"},{"location":"dictionary/namespaceqqmusic_1_1utils/#function-qmc1_decrypt","title":"function qmc1_decrypt","text":"<pre><code>static void qqmusic::utils::qmc1_decrypt (\n    buffer &amp; src\n) \n</code></pre>"},{"location":"dictionary/namespaceqqmusic_1_1utils/#function-tail","title":"function tail","text":"<pre><code>static std::string qqmusic::utils::tail (\n    std::span&lt; uint8_t &gt; data\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/utils/async-executor.cc</code></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1AsyncExecutor/","title":"Class qqmusic::utils::AsyncExecutor","text":"<p>ClassList &gt; qqmusic &gt; utils &gt; AsyncExecutor</p> <p>\u5168\u5c40\u8c03\u5ea6\u5668\u7c7b </p> <ul> <li><code>#include &lt;async-executor.h&gt;</code></li> </ul>"},{"location":"dictionary/classqqmusic_1_1utils_1_1AsyncExecutor/#public-functions","title":"Public Functions","text":"Type Name AsyncExecutor (const AsyncExecutor &amp;) = delete void async_exec (qqmusic::Task&lt; T &gt; task, CompletionCallback &amp;&amp; callback) \u5f02\u6b65\u6267\u884c\u4efb\u52a1, \u5e76\u5728\u4efb\u52a1\u7ed3\u675f\u540e\u89e6\u53d1\u56de\u8c03 void async_exec (qqmusic::Task&lt; void &gt; task, CompletionCallback &amp;&amp; callback) \u5f02\u6b65\u6267\u884c\u4efb\u52a1\u51fd\u6570\u7684void\u7279\u5316, \u5e76\u5728\u4efb\u52a1\u7ed3\u675f\u540e\u89e6\u53d1\u56de\u8c03 void async_exec (qqmusic::Task&lt; T &gt; task, CompletionCallback &amp;&amp; callback, std::chrono::steady_clock::duration timeout, TimeoutCallback &amp;&amp; timeout_callback) \u5f02\u6b65\u6267\u884c\u4efb\u52a1\u51fd\u6570, \u5e26\u6709\u8d85\u65f6\u9650\u5236, \u5e76\u5728\u4efb\u52a1\u7ed3\u675f\u540e\u89e6\u53d1\u56de\u8c03 void async_exec (qqmusic::Task&lt; void &gt; task, CompletionCallback &amp;&amp; callback, std::chrono::steady_clock::duration timeout, TimeoutCallback &amp;&amp; timeout_callback) \u5f02\u6b65\u6267\u884c\u4efb\u52a1\u51fd\u6570void\u7279\u5316, \u5e26\u6709\u8d85\u65f6\u9650\u5236. \u5e76\u5728\u4efb\u52a1\u7ed3\u675f\u540e\u89e6\u53d1\u56de\u8c03 AsyncExecutor &amp; operator= (const AsyncExecutor &amp;) = delete void shutdown ()  auto when_all (std::vector&lt; boost::asio::awaitable&lt; T &gt; &gt; tasks) \u7b49\u5f85\u4efb\u52a1\u5217\u8868\u4e2d\u6240\u6709\u7684\u4efb\u52a1\u6267\u884c\u5b8c\u6bd5\u4e4b\u540e\u8fd4\u56de\u7ed3\u679c\u5217\u8868"},{"location":"dictionary/classqqmusic_1_1utils_1_1AsyncExecutor/#public-static-functions","title":"Public Static Functions","text":"Type Name AsyncExecutor &amp; get_instance () \u83b7\u53d6\u5168\u5c40\u5355\u4f8b\u5f15\u7528"},{"location":"dictionary/classqqmusic_1_1utils_1_1AsyncExecutor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/classqqmusic_1_1utils_1_1AsyncExecutor/#function-asyncexecutor-12","title":"function AsyncExecutor [1/2]","text":"<pre><code>qqmusic::utils::AsyncExecutor::AsyncExecutor (\n    const AsyncExecutor &amp;\n) = delete\n</code></pre>"},{"location":"dictionary/classqqmusic_1_1utils_1_1AsyncExecutor/#function-async_exec-14","title":"function async_exec [1/4]","text":"<p>\u5f02\u6b65\u6267\u884c\u4efb\u52a1, \u5e76\u5728\u4efb\u52a1\u7ed3\u675f\u540e\u89e6\u53d1\u56de\u8c03 <pre><code>template&lt;typename T, BOOST_ASIO_COMPLETION_TOKEN_FOR(void(T &amp;&amp;)) CompletionCallback&gt;\ninline void qqmusic::utils::AsyncExecutor::async_exec (\n    qqmusic::Task&lt; T &gt; task,\n    CompletionCallback &amp;&amp; callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>task</code> \u5f02\u6b65\u4efb\u52a1 </li> <li><code>callback</code> \u56de\u8c03\u51fd\u6570, \u4f1a\u5c06<code>task</code>\u7684\u6267\u884c\u7ed3\u679c\u4f20\u9012\u7ed9\u56de\u8c03\u51fd\u6570 \u56de\u8c03\u51fd\u6570\u4e0d\u8fd4\u56de\u4efb\u4f55\u503c </li> </ul>"},{"location":"dictionary/classqqmusic_1_1utils_1_1AsyncExecutor/#function-async_exec-24","title":"function async_exec [2/4]","text":"<p>\u5f02\u6b65\u6267\u884c\u4efb\u52a1\u51fd\u6570\u7684void\u7279\u5316, \u5e76\u5728\u4efb\u52a1\u7ed3\u675f\u540e\u89e6\u53d1\u56de\u8c03 <pre><code>template&lt;BOOST_ASIO_COMPLETION_TOKEN_FOR(void()) CompletionCallback&gt;\ninline void qqmusic::utils::AsyncExecutor::async_exec (\n    qqmusic::Task&lt; void &gt; task,\n    CompletionCallback &amp;&amp; callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>task</code> \u5f02\u6b65\u4efb\u52a1 </li> <li><code>callback</code> \u56de\u8c03\u51fd\u6570, \u4f1a\u5c06<code>task</code>\u7684\u6267\u884c\u7ed3\u679c\u4f20\u9012\u7ed9\u56de\u8c03\u51fd\u6570 \u56de\u8c03\u51fd\u6570\u4e0d\u8fd4\u56de\u4efb\u4f55\u503c </li> </ul>"},{"location":"dictionary/classqqmusic_1_1utils_1_1AsyncExecutor/#function-async_exec-34","title":"function async_exec [3/4]","text":"<p>\u5f02\u6b65\u6267\u884c\u4efb\u52a1\u51fd\u6570, \u5e26\u6709\u8d85\u65f6\u9650\u5236, \u5e76\u5728\u4efb\u52a1\u7ed3\u675f\u540e\u89e6\u53d1\u56de\u8c03 <pre><code>template&lt;typename T, BOOST_ASIO_COMPLETION_TOKEN_FOR(void(T &amp;&amp;)) CompletionCallback, BOOST_ASIO_COMPLETION_TOKEN_FOR(void()) TimeoutCallback&gt;\ninline void qqmusic::utils::AsyncExecutor::async_exec (\n    qqmusic::Task&lt; T &gt; task,\n    CompletionCallback &amp;&amp; callback,\n    std::chrono::steady_clock::duration timeout,\n    TimeoutCallback &amp;&amp; timeout_callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>task</code> \u5f02\u6b65\u4efb\u52a1 </li> <li><code>callback</code> \u56de\u8c03\u51fd\u6570, \u4f1a\u5c06<code>task</code>\u7684\u6267\u884c\u7ed3\u679c\u4f20\u9012\u7ed9\u56de\u8c03\u51fd\u6570 \u56de\u8c03\u51fd\u6570\u4e0d\u8fd4\u56de\u4efb\u4f55\u503c </li> <li><code>timeout</code> \u8d85\u65f6\u65f6\u95f4\u9650\u5236 </li> <li><code>timeout_callback</code> \u8d85\u65f6\u4e4b\u540e\u9700\u8981\u6267\u884c\u7684\u56de\u8c03\u51fd\u6570 </li> </ul>"},{"location":"dictionary/classqqmusic_1_1utils_1_1AsyncExecutor/#function-async_exec-44","title":"function async_exec [4/4]","text":"<p>\u5f02\u6b65\u6267\u884c\u4efb\u52a1\u51fd\u6570void\u7279\u5316, \u5e26\u6709\u8d85\u65f6\u9650\u5236. \u5e76\u5728\u4efb\u52a1\u7ed3\u675f\u540e\u89e6\u53d1\u56de\u8c03 <pre><code>template&lt;BOOST_ASIO_COMPLETION_TOKEN_FOR(void()) CompletionCallback, BOOST_ASIO_COMPLETION_TOKEN_FOR(void()) TimeoutCallback&gt;\ninline void qqmusic::utils::AsyncExecutor::async_exec (\n    qqmusic::Task&lt; void &gt; task,\n    CompletionCallback &amp;&amp; callback,\n    std::chrono::steady_clock::duration timeout,\n    TimeoutCallback &amp;&amp; timeout_callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>task</code> \u5f02\u6b65\u4efb\u52a1 </li> <li><code>callback</code> \u56de\u8c03\u51fd\u6570, \u4f1a\u5c06<code>task</code>\u7684\u6267\u884c\u7ed3\u679c\u4f20\u9012\u7ed9\u56de\u8c03\u51fd\u6570 \u56de\u8c03\u51fd\u6570\u4e0d\u8fd4\u56de\u4efb\u4f55\u503c </li> <li><code>timeout</code> \u8d85\u65f6\u65f6\u95f4\u9650\u5236 </li> <li><code>timeout_callback</code> \u8d85\u65f6\u4e4b\u540e\u9700\u8981\u6267\u884c\u7684\u56de\u8c03\u51fd\u6570 </li> </ul>"},{"location":"dictionary/classqqmusic_1_1utils_1_1AsyncExecutor/#function-operator","title":"function operator=","text":"<pre><code>AsyncExecutor &amp; qqmusic::utils::AsyncExecutor::operator= (\n    const AsyncExecutor &amp;\n) = delete\n</code></pre>"},{"location":"dictionary/classqqmusic_1_1utils_1_1AsyncExecutor/#function-shutdown","title":"function shutdown","text":"<pre><code>void qqmusic::utils::AsyncExecutor::shutdown () \n</code></pre>"},{"location":"dictionary/classqqmusic_1_1utils_1_1AsyncExecutor/#function-when_all","title":"function when_all","text":"<p>\u7b49\u5f85\u4efb\u52a1\u5217\u8868\u4e2d\u6240\u6709\u7684\u4efb\u52a1\u6267\u884c\u5b8c\u6bd5\u4e4b\u540e\u8fd4\u56de\u7ed3\u679c\u5217\u8868 <pre><code>template&lt;typename T&gt;\ninline auto qqmusic::utils::AsyncExecutor::when_all (\n    std::vector&lt; boost::asio::awaitable&lt; T &gt; &gt; tasks\n) \n</code></pre></p> <pre><code>// \u4f7f\u7528\u793a\u4f8b:\nstd::vector&lt;Task&lt;nlohmann::json&gt;&gt; tasks{}; // \u7ed9\u5b9a\u4efb\u52a1\u5217\u8868\nauto&amp; executor = qqmusic::utils::AsyncExecutor::get_instance();\nauto results = executor.when_all(std::move(tasks));\nfor (auto&amp; result : results) {\n    // handle the result ...\n}\n</code></pre> <p>Parameters:</p> <ul> <li><code>tasks</code> \u5f02\u6b65\u4efb\u52a1\u5217\u8868</li> </ul> <p>Returns:</p> <p>\u5305\u542b\u7ed3\u679c\u5217\u8868\u7684\u4efb\u52a1<code>boost::asio::awaitable&lt;std::vector&lt;T&gt;&gt;</code></p> <p>@warn \u539f\u672c\u4efb\u52a1\u7684\u987a\u5e8f\u548c\u7ed3\u679c\u987a\u5e8f\u4e0d\u4e00\u5b9a\u4e00\u81f4 </p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1AsyncExecutor/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"dictionary/classqqmusic_1_1utils_1_1AsyncExecutor/#function-get_instance","title":"function get_instance","text":"<p>\u83b7\u53d6\u5168\u5c40\u5355\u4f8b\u5f15\u7528 <pre><code>static AsyncExecutor &amp; qqmusic::utils::AsyncExecutor::get_instance () \n</code></pre></p> <p>Returns:</p> <p>\u5168\u5c40\u8c03\u5ea6\u5668\u5b9e\u4f8b\u5f15\u7528 </p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/async-executor.h</code></p>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Cookie/","title":"Struct qqmusic::utils::Cookie","text":"<p>ClassList &gt; qqmusic &gt; utils &gt; Cookie</p> <p>\u4ee3\u8868\u4e00\u6761Cookie </p> <ul> <li><code>#include &lt;cookie.h&gt;</code></li> </ul>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Cookie/#public-attributes","title":"Public Attributes","text":"Type Name std::string domain \u57df\u540d std::string key \u952e std::string path   = <code>\"/\"</code>\u8def\u5f84 std::string value \u503c"},{"location":"dictionary/structqqmusic_1_1utils_1_1Cookie/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"dictionary/structqqmusic_1_1utils_1_1Cookie/#variable-domain","title":"variable domain","text":"<p>\u57df\u540d <pre><code>std::string qqmusic::utils::Cookie::domain;\n</code></pre></p>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Cookie/#variable-key","title":"variable key","text":"<p>\u952e <pre><code>std::string qqmusic::utils::Cookie::key;\n</code></pre></p>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Cookie/#variable-path","title":"variable path","text":"<p>\u8def\u5f84 <pre><code>std::string qqmusic::utils::Cookie::path;\n</code></pre></p>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Cookie/#variable-value","title":"variable value","text":"<p>\u503c <pre><code>std::string qqmusic::utils::Cookie::value;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/cookie.h</code></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1CookieJar/","title":"Class qqmusic::utils::CookieJar","text":"<p>ClassList &gt; qqmusic &gt; utils &gt; CookieJar</p> <p>\u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027More...</p> <ul> <li><code>#include &lt;cookie.h&gt;</code></li> </ul>"},{"location":"dictionary/classqqmusic_1_1utils_1_1CookieJar/#public-functions","title":"Public Functions","text":"Type Name CookieJar () \u7a7a\u521d\u59cb\u5316 CookieJar (std::string_view cache) \u7f13\u5b58\u53cd\u5e8f\u5217\u5316, \u4ece <code>dump</code> \u51fd\u6570\u4ea7\u751f\u7684\u7f13\u5b58\u6784\u9020 CookieJar (std::string_view cookie_str, std::string_view domain, std::string_view path=\"/\") \u4ece\u539f\u59cbcookie\u5b57\u7b26\u4e32\u89e3\u6790 qqmusic::Result&lt; void &gt; clear (std::optional&lt; std::string &gt; domain=std::nullopt, std::optional&lt; std::string &gt; path=std::nullopt, std::optional&lt; std::string &gt; key=std::nullopt) \u5220\u9664\u5bf9\u5e94\u533a\u57df\u7684cookie qqmusic::Result&lt; void &gt; del (std::string_view key, std::optional&lt; std::string &gt; domain=std::nullopt, std::optional&lt; std::string &gt; path=std::nullopt) \u5220\u9664\u5bf9\u5e94\u952e\u7684Cookie\u5b57\u6bb5\u548c\u4ed6\u7684\u503c qqmusic::Result&lt; std::string &gt; dump () \u5e8f\u5217\u5316Cookie qqmusic::Result&lt; std::string &gt; get (std::string_view key, std::optional&lt; std::string &gt; domain=std::nullopt, std::optional&lt; std::string &gt; path=std::nullopt) \u67e5\u8be2\u5bf9\u5e94\u952e\u7684Cookie\u5b57\u6bb5\u7684\u503c qqmusic::Result&lt; void &gt; merge (const CookieJar &amp; cookies) \u5408\u5e76CookieJar\u5185\u5bb9 qqmusic::Result&lt; std::string &gt; serialize (std::string_view domain, std::string_view path=\"/\") \u5c06\u5bf9\u5e94\u57df\u540d\u548c\u8def\u5f84\u7684Cookie\u5e8f\u5217\u5316\u6210\u8bf7\u6c42\u62a5\u6587 qqmusic::Result&lt; void &gt; set (const Cookie &amp; cookie) \u63d2\u5165\u4e00\u6761Cookie qqmusic::Result&lt; void &gt; update (const CookieJar &amp; cookies) \u66ff\u6362CookieJar\u7684\u5185\u5bb9"},{"location":"dictionary/classqqmusic_1_1utils_1_1CookieJar/#detailed-description","title":"Detailed Description","text":"<p>\u4f7f\u7528Json\u6570\u636e\u7ed3\u6784\u6765\u50a8\u5b58Cookie  <pre><code>{\n    \"domain1\" : {\n        \"path1\": {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\"\n        },\n        \"path2\": {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\"\n        }\n    },\n    \"domain2\" : {\n        \"path1\": {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\"\n        },\n        \"path2\": {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\"\n        }\n    }\n}\n</code></pre></p> <p>Warning:</p> <p>\u4e0d\u652f\u6301path\u7684\u5d4c\u5957, <code>example.com/menu</code> \u548c <code>example.com/menu/usr</code> \u88ab\u8ba4\u4e3a\u662f\u57df\u540d<code>example.com</code>\u4e0b\u4e24\u4e2a\u5b8c\u5168\u4e0d\u540c\u7684\u8def\u5f84.</p> <p>\u4e0d\u652f\u6301\u89e3\u6790<code>HttpOnly</code>, <code>Expires</code>\u8fd9\u6837\u7684\u5b57\u6bb5, \u4e0d\u662f\u952e\u503c\u5bf9\u5f62\u5f0f\u7684 Cookie\u6761\u76ee\u4f1a\u88ab\u4e22\u5f03.</p> <p>\u5f85\u529e\u4e8b\u9879</p> <p>\u9700\u8981\u652f\u6301\u5d4c\u5957\u7684\u8def\u5f84, \u652f\u6301\u975e\u952e\u503c\u5bf9\u5f62\u5f0f\u7684Cookie </p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1CookieJar/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/classqqmusic_1_1utils_1_1CookieJar/#function-cookiejar-13","title":"function CookieJar [1/3]","text":"<p>\u7a7a\u521d\u59cb\u5316 <pre><code>inline qqmusic::utils::CookieJar::CookieJar () \n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1CookieJar/#function-cookiejar-23","title":"function CookieJar [2/3]","text":"<p>\u7f13\u5b58\u53cd\u5e8f\u5217\u5316, \u4ece <code>dump</code> \u51fd\u6570\u4ea7\u751f\u7684\u7f13\u5b58\u6784\u9020 <pre><code>inline qqmusic::utils::CookieJar::CookieJar (\n    std::string_view cache\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cache</code> \u7f13\u5b58 </li> </ul>"},{"location":"dictionary/classqqmusic_1_1utils_1_1CookieJar/#function-cookiejar-33","title":"function CookieJar [3/3]","text":"<p>\u4ece\u539f\u59cbcookie\u5b57\u7b26\u4e32\u89e3\u6790 <pre><code>qqmusic::utils::CookieJar::CookieJar (\n    std::string_view cookie_str,\n    std::string_view domain,\n    std::string_view path=\"/\"\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cookie_str</code> \u8bf7\u6c42\u62a5\u6587\u4e2dcookie\u5b57\u7b26\u4e32, \u4e00\u822c\u5b58\u5728\u4e8e<code>Set-Cookie</code>\u5b57\u6bb5 </li> <li><code>domain</code> \u57df\u540d </li> <li><code>path</code> \u8def\u5f84, \u9ed8\u8ba4\u662f<code>/</code> </li> </ul>"},{"location":"dictionary/classqqmusic_1_1utils_1_1CookieJar/#function-clear","title":"function clear","text":"<p>\u5220\u9664\u5bf9\u5e94\u533a\u57df\u7684cookie <pre><code>qqmusic::Result&lt; void &gt; qqmusic::utils::CookieJar::clear (\n    std::optional&lt; std::string &gt; domain=std::nullopt,\n    std::optional&lt; std::string &gt; path=std::nullopt,\n    std::optional&lt; std::string &gt; key=std::nullopt\n) \n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1CookieJar/#function-del","title":"function del","text":"<p>\u5220\u9664\u5bf9\u5e94\u952e\u7684Cookie\u5b57\u6bb5\u548c\u4ed6\u7684\u503c <pre><code>qqmusic::Result&lt; void &gt; qqmusic::utils::CookieJar::del (\n    std::string_view key,\n    std::optional&lt; std::string &gt; domain=std::nullopt,\n    std::optional&lt; std::string &gt; path=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>key</code> \u952e </li> <li><code>domain</code> \u57df\u540d, \u9ed8\u8ba4<code>std::nullopt</code>, \u82e5\u4e0d\u7ed9\u51fa\u5219\u5168\u5c40\u5bfb\u627e </li> <li><code>path</code> \u8def\u5f84, \u9ed8\u8ba4<code>std::nullopt</code>, \u82e5\u4e0d\u7ed9\u51fa\u5219\u5728\u57df\u540d\u4e0b\u5bfb\u627e</li> </ul> <p>Returns:</p> <p><code>Result &lt;void&gt;</code>, \u5982\u679c\u6ca1\u6709\u5bf9\u5e94\u7684\u952e, \u4f1a\u8fd4\u56de<code>JsonError</code></p> <p>Note:</p> <p>\u7f3a\u7701\u53c2\u6570\u65f6\u603b\u662f\u5220\u9664\u7b2c\u4e00\u4e2a\u627e\u5230\u7b26\u5408\u7684\u952e\u503c\u5bf9 </p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1CookieJar/#function-dump","title":"function dump","text":"<p>\u5e8f\u5217\u5316Cookie <pre><code>qqmusic::Result&lt; std::string &gt; qqmusic::utils::CookieJar::dump () \n</code></pre></p> <p>Returns:</p> <p>\u5df2\u7ecf\u5e8f\u5217\u5316\u7684json\u5b57\u7b26\u4e32, \u5982\u679c\u51fa\u9519\u4f1a\u8fd4\u56de<code>JsonError</code> </p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1CookieJar/#function-get","title":"function get","text":"<p>\u67e5\u8be2\u5bf9\u5e94\u952e\u7684Cookie\u5b57\u6bb5\u7684\u503c <pre><code>qqmusic::Result&lt; std::string &gt; qqmusic::utils::CookieJar::get (\n    std::string_view key,\n    std::optional&lt; std::string &gt; domain=std::nullopt,\n    std::optional&lt; std::string &gt; path=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>key</code> \u952e </li> <li><code>domain</code> \u57df\u540d, \u9ed8\u8ba4<code>std::nullopt</code>, \u82e5\u4e0d\u7ed9\u51fa\u5219\u5168\u5c40\u5bfb\u627e </li> <li><code>path</code> \u8def\u5f84, \u9ed8\u8ba4<code>std::nullopt</code>, \u82e5\u4e0d\u7ed9\u51fa\u5219\u5728\u57df\u540d\u4e0b\u5bfb\u627e</li> </ul> <p>Returns:</p> <p><code>Result &lt;std::string&gt;</code>, \u952e\u503c\u5bf9\u7684\u503c\u662f\u5b57\u7b26\u4e32\u5f62\u5f0f\u7684 \u627e\u4e0d\u5230\u4f1a\u8fd4\u56de<code>JsonError</code></p> <p>Note:</p> <p>\u53c2\u6570\u7f3a\u7701\u65f6\u603b\u662f\u8fd4\u56de\u7b2c\u4e00\u4e2a\u627e\u5230\u7684\u952e\u503c\u5bf9\u7684\u503c </p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1CookieJar/#function-merge","title":"function merge","text":"<p>\u5408\u5e76CookieJar\u5185\u5bb9 <pre><code>qqmusic::Result&lt; void &gt; qqmusic::utils::CookieJar::merge (\n    const CookieJar &amp; cookies\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cookies</code> \u5f85\u5408\u5e76cookie</li> </ul> <p>Note:</p> <p>\u539f\u672cCookie\u4e0d\u5b58\u5728\u7684\u5b57\u6bb5\u88ab\u521b\u5efa, \u91cd\u5408\u7684\u5b57\u6bb5\u88ab\u65b0\u503c\u8986\u76d6 </p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1CookieJar/#function-serialize","title":"function serialize","text":"<p>\u5c06\u5bf9\u5e94\u57df\u540d\u548c\u8def\u5f84\u7684Cookie\u5e8f\u5217\u5316\u6210\u8bf7\u6c42\u62a5\u6587 <pre><code>qqmusic::Result&lt; std::string &gt; qqmusic::utils::CookieJar::serialize (\n    std::string_view domain,\n    std::string_view path=\"/\"\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>domain</code> \u57df\u540d </li> <li><code>path</code> \u8def\u5f84, \u9ed8\u8ba4<code>/</code> </li> </ul>"},{"location":"dictionary/classqqmusic_1_1utils_1_1CookieJar/#function-set","title":"function set","text":"<p>\u63d2\u5165\u4e00\u6761Cookie <pre><code>qqmusic::Result&lt; void &gt; qqmusic::utils::CookieJar::set (\n    const Cookie &amp; cookie\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cookie</code> \u4e00\u4e2aCookie\u6761\u76ee</li> </ul> <p>Note:</p> <p>\u5982\u679c\u5bf9\u5e94\u57df\u540d\u548c\u8def\u5f84\u7684\u8fd9\u4e2aCookie\u7684\u952e\u5df2\u7ecf\u5b58\u5728, \u90a3\u4e48\u4f1a\u8986\u76d6\u8001\u7684\u503c </p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1CookieJar/#function-update","title":"function update","text":"<p>\u66ff\u6362CookieJar\u7684\u5185\u5bb9 <pre><code>qqmusic::Result&lt; void &gt; qqmusic::utils::CookieJar::update (\n    const CookieJar &amp; cookies\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cookies</code> \u65b0\u7684Cookies </li> </ul> <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/cookie.h</code></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/","title":"Class qqmusic::utils::Credential","text":"<p>ClassList &gt; qqmusic &gt; utils &gt; Credential</p> <p>\u51ed\u636e\u4fe1\u606f\u7c7b </p> <ul> <li><code>#include &lt;credential.h&gt;</code></li> </ul>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#public-attributes","title":"Public Attributes","text":"Type Name std::string access_token AccessToken std::string encryptUin \u52a0\u5bc6\u7684euin, euin\u548c\u8d26\u53f7ID\u4e00\u4e00\u5bf9\u5e94 uint64_t expired_at   = <code>0</code>\u5230\u671f\u65f6\u95f4, \u79d2\u7ea7\u65f6\u95f4\u6233 nlohmann::json extra_fields \u6ca1\u6709\u6536\u5f55\u5728\u4e0a\u9762\u7684\u5b57\u6bb5 int loginType   = <code>2</code>\u767b\u5f55\u6a21\u5f0f <code>1</code> : \u5fae\u4fe1\u767b\u9646<code>2</code> : QQ\u767b\u9646 uint64_t musicid   = <code>0</code>\u8d26\u53f7MusicID, \u4e00\u822c\u662fQQ\u53f7 std::string musickey \u8d26\u53f7MusicKey std::string openid OpenID std::string refresh_key RefreshKey std::string refresh_token RefreshToken std::string str_musicid std::string\u683c\u5f0f\u7684\u8d26\u53f7MusicID, \u4e00\u822c\u662fQQ\u53f7 std::string unionid UnionID"},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#public-functions","title":"Public Functions","text":"Type Name Credential () = default\u9ed8\u8ba4\u7a7a\u521d\u59cb\u5316 Credential (std::string_view cookie) \u4ecelogin api\u83b7\u53d6\u7684\u8fd4\u56de\u7ed3\u679c\u6784\u9020Credential Credential (nlohmann::json &amp; cookie) \u4ecelogin api\u8fd4\u56de\u7684\u7ed3\u679c\u6784\u9020Credential NLOHMANN_DEFINE_TYPE_INTRUSIVE (Credential, openid, refresh_token, access_token, expired_at, musicid, unionid, str_musicid, musickey, refresh_key, encryptUin, loginType)  bool from_cache (std::string_view cache) \u4ece\u5e8f\u5217\u5316\u51fa\u7684cache\u751f\u6210Credential bool from_cache (nlohmann::json &amp; cache) \u4ece\u5e8f\u5217\u5316\u51fa\u7684cache\u751f\u6210Credential qqmusic::Task&lt; qqmusic::Result&lt; bool &gt; &gt; is_expired () \u5224\u65adCredential\u662f\u5426\u8fc7\u671f bool is_valid () const\u5224\u65adCredential\u662f\u5426\u5408\u6cd5, \u5373\u6709\u6ca1\u6709 <code>musicid</code> \u548c<code>musickey</code> \u5b57\u6bb5 qqmusic::Task&lt; qqmusic::Result&lt; void &gt; &gt; refresh () \u5237\u65b0Credential qqmusic::Result&lt; nlohmann::json &gt; to_json () \u5c06Credential\u5e8f\u5217\u5316\u4e3aJson\u5bf9\u8c61 qqmusic::Result&lt; std::string &gt; to_string () \u5c06Credential\u5e8f\u5217\u5316\u4e3aJson\u5b57\u7b26\u4e32"},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#variable-access_token","title":"variable access_token","text":"<p>AccessToken <pre><code>std::string qqmusic::utils::Credential::access_token;\n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#variable-encryptuin","title":"variable encryptUin","text":"<p>\u52a0\u5bc6\u7684euin, euin\u548c\u8d26\u53f7ID\u4e00\u4e00\u5bf9\u5e94 <pre><code>std::string qqmusic::utils::Credential::encryptUin;\n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#variable-expired_at","title":"variable expired_at","text":"<p>\u5230\u671f\u65f6\u95f4, \u79d2\u7ea7\u65f6\u95f4\u6233 <pre><code>uint64_t qqmusic::utils::Credential::expired_at;\n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#variable-extra_fields","title":"variable extra_fields","text":"<p>\u6ca1\u6709\u6536\u5f55\u5728\u4e0a\u9762\u7684\u5b57\u6bb5 <pre><code>nlohmann::json qqmusic::utils::Credential::extra_fields;\n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#variable-logintype","title":"variable loginType","text":"<p>\u767b\u5f55\u6a21\u5f0f <code>1</code> : \u5fae\u4fe1\u767b\u9646<code>2</code> : QQ\u767b\u9646 <pre><code>int qqmusic::utils::Credential::loginType;\n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#variable-musicid","title":"variable musicid","text":"<p>\u8d26\u53f7MusicID, \u4e00\u822c\u662fQQ\u53f7 <pre><code>uint64_t qqmusic::utils::Credential::musicid;\n</code></pre></p> <p>Note:</p> <p>\u5e38\u7528\u5b57\u6bb5 </p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#variable-musickey","title":"variable musickey","text":"<p>\u8d26\u53f7MusicKey <pre><code>std::string qqmusic::utils::Credential::musickey;\n</code></pre></p> <p>Note:</p> <p>\u5e38\u7528 </p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#variable-openid","title":"variable openid","text":"<p>OpenID <pre><code>std::string qqmusic::utils::Credential::openid;\n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#variable-refresh_key","title":"variable refresh_key","text":"<p>RefreshKey <pre><code>std::string qqmusic::utils::Credential::refresh_key;\n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#variable-refresh_token","title":"variable refresh_token","text":"<p>RefreshToken <pre><code>std::string qqmusic::utils::Credential::refresh_token;\n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#variable-str_musicid","title":"variable str_musicid","text":"<p>std::string\u683c\u5f0f\u7684\u8d26\u53f7MusicID, \u4e00\u822c\u662fQQ\u53f7 <pre><code>std::string qqmusic::utils::Credential::str_musicid;\n</code></pre></p> <p>Note:</p> <p>\u5e38\u7528\u5b57\u6bb5 </p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#variable-unionid","title":"variable unionid","text":"<p>UnionID <pre><code>std::string qqmusic::utils::Credential::unionid;\n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#function-credential-13","title":"function Credential [1/3]","text":"<p>\u9ed8\u8ba4\u7a7a\u521d\u59cb\u5316 <pre><code>qqmusic::utils::Credential::Credential () = default\n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#function-credential-23","title":"function Credential [2/3]","text":"<p>\u4ecelogin api\u83b7\u53d6\u7684\u8fd4\u56de\u7ed3\u679c\u6784\u9020Credential <pre><code>explicit qqmusic::utils::Credential::Credential (\n    std::string_view cookie\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cookie</code> Json\u5b57\u7b26\u4e32 </li> </ul>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#function-credential-33","title":"function Credential [3/3]","text":"<p>\u4ecelogin api\u8fd4\u56de\u7684\u7ed3\u679c\u6784\u9020Credential <pre><code>explicit qqmusic::utils::Credential::Credential (\n    nlohmann::json &amp; cookie\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cookie</code> Json\u5bf9\u8c61 </li> </ul>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#function-nlohmann_define_type_intrusive","title":"function NLOHMANN_DEFINE_TYPE_INTRUSIVE","text":"<pre><code>qqmusic::utils::Credential::NLOHMANN_DEFINE_TYPE_INTRUSIVE (\n    Credential,\n    openid,\n    refresh_token,\n    access_token,\n    expired_at,\n    musicid,\n    unionid,\n    str_musicid,\n    musickey,\n    refresh_key,\n    encryptUin,\n    loginType\n) \n</code></pre>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#function-from_cache-12","title":"function from_cache [1/2]","text":"<p>\u4ece\u5e8f\u5217\u5316\u51fa\u7684cache\u751f\u6210Credential <pre><code>bool qqmusic::utils::Credential::from_cache (\n    std::string_view cache\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cache</code> \u7531<code>Credential::to_string()</code>\u548c<code>Credential::to_json()</code> \u751f\u6210\u7684\u5e8f\u5217\u5316\u7ed3\u679c\u5bfc\u5165Credential</li> </ul> <p>Returns:</p> <p><code>true</code>, \u5982\u679c\u5904\u7406\u8fc7\u7a0b\u51fa\u73b0\u95ee\u9898 <code>false</code>, \u5982\u679c\u6b63\u5e38\u5904\u7406\u5b8c\u6bd5 </p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#function-from_cache-22","title":"function from_cache [2/2]","text":"<p>\u4ece\u5e8f\u5217\u5316\u51fa\u7684cache\u751f\u6210Credential <pre><code>bool qqmusic::utils::Credential::from_cache (\n    nlohmann::json &amp; cache\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>cache</code> \u7531<code>Credential::to_string()</code>\u548c<code>Credential::to_json()</code> \u751f\u6210\u7684\u5e8f\u5217\u5316\u7ed3\u679c\u5bfc\u5165Credential</li> </ul> <p>Returns:</p> <p><code>true</code>, \u5982\u679c\u5904\u7406\u8fc7\u7a0b\u51fa\u73b0\u95ee\u9898 <code>false</code>, \u5982\u679c\u6b63\u5e38\u5904\u7406\u5b8c\u6bd5 </p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#function-is_expired","title":"function is_expired","text":"<p>\u5224\u65adCredential\u662f\u5426\u8fc7\u671f <pre><code>qqmusic::Task&lt; qqmusic::Result&lt; bool &gt; &gt; qqmusic::utils::Credential::is_expired () \n</code></pre></p> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;bool&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e \u8fd4\u56de<code>true</code>\u8bf4\u660e\u672a\u8fc7\u671f, <code>false</code>\u8bf4\u660e\u8fc7\u671f, \u9700\u8981\u5237\u65b0</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#function-is_valid","title":"function is_valid","text":"<p>\u5224\u65adCredential\u662f\u5426\u5408\u6cd5, \u5373\u6709\u6ca1\u6709 <code>musicid</code> \u548c<code>musickey</code> \u5b57\u6bb5 <pre><code>bool qqmusic::utils::Credential::is_valid () const\n</code></pre></p> <p>Returns:</p> <p><code>true</code>, \u5408\u6cd5 <code>false</code>, \u4e0d\u5408\u6cd5 </p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#function-refresh","title":"function refresh","text":"<p>\u5237\u65b0Credential <pre><code>qqmusic::Task&lt; qqmusic::Result&lt; void &gt; &gt; qqmusic::utils::Credential::refresh () \n</code></pre></p> <p>Returns:</p> <p>\u5305\u542b\u6b63\u786eJSON\u683c\u5f0f\u7ed3\u679c\u7684<code>Task&lt; Result &lt;void&gt;&gt;</code>. \u5982\u679c\u4ea7\u751f\u9519\u8bef, \u8fd4\u56de\u503c\u5305\u542b\u9519\u8bef\u7ed3\u679c\u548c\u9519\u8bef\u7c7b\u578b\u679a\u4e3e</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#function-to_json","title":"function to_json","text":"<p>\u5c06Credential\u5e8f\u5217\u5316\u4e3aJson\u5bf9\u8c61 <pre><code>qqmusic::Result&lt; nlohmann::json &gt; qqmusic::utils::Credential::to_json () \n</code></pre></p> <p>Returns:</p> <p>\u5305\u542b\u7ed3\u679c\u6216\u9519\u8bef\u7684<code>Result &lt;nlohmann::json&gt;</code> </p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Credential/#function-to_string","title":"function to_string","text":"<p>\u5c06Credential\u5e8f\u5217\u5316\u4e3aJson\u5b57\u7b26\u4e32 <pre><code>qqmusic::Result&lt; std::string &gt; qqmusic::utils::Credential::to_string () \n</code></pre></p> <p>Returns:</p> <p>\u5305\u542b\u7ed3\u679c\u6216\u9519\u8bef\u7684<code>Result &lt;std::string&gt;</code> </p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/credential.h</code></p>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/","title":"Struct qqmusic::utils::Device","text":"<p>ClassList &gt; qqmusic &gt; utils &gt; Device</p> <p>\u8bbe\u5907\u4fe1\u606f </p> <ul> <li><code>#include &lt;device.h&gt;</code></li> </ul>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#public-attributes","title":"Public Attributes","text":"Type Name std::string android_id std::string apn std::string base_band std::string board std::string boot_id std::string bootloader std::string brand std::string device std::string display std::string fingerprint std::string imei std::vector&lt; int &gt; imsi_md5 std::vector&lt; int &gt; ip_address std::string mac_address std::string model std::string os_type std::string proc_version std::string product std::string qimei std::string sim_info std::string vendor_name std::string vendor_os_name struct OSVersion version std::string wifi_bssid std::string wifi_ssid"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#public-functions","title":"Public Functions","text":"Type Name Device ()  NLOHMANN_DEFINE_TYPE_INTRUSIVE (Device, display, product, device, board, model, fingerprint, boot_id, proc_version, imei, brand, bootloader, base_band, version, sim_info, os_type, mac_address, wifi_bssid, wifi_ssid, imsi_md5, android_id, apn, vendor_name, vendor_os_name, qimei)"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#variable-android_id","title":"variable android_id","text":"<pre><code>std::string qqmusic::utils::Device::android_id;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#variable-apn","title":"variable apn","text":"<pre><code>std::string qqmusic::utils::Device::apn;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#variable-base_band","title":"variable base_band","text":"<pre><code>std::string qqmusic::utils::Device::base_band;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#variable-board","title":"variable board","text":"<pre><code>std::string qqmusic::utils::Device::board;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#variable-boot_id","title":"variable boot_id","text":"<pre><code>std::string qqmusic::utils::Device::boot_id;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#variable-bootloader","title":"variable bootloader","text":"<pre><code>std::string qqmusic::utils::Device::bootloader;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#variable-brand","title":"variable brand","text":"<pre><code>std::string qqmusic::utils::Device::brand;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#variable-device","title":"variable device","text":"<pre><code>std::string qqmusic::utils::Device::device;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#variable-display","title":"variable display","text":"<pre><code>std::string qqmusic::utils::Device::display;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#variable-fingerprint","title":"variable fingerprint","text":"<pre><code>std::string qqmusic::utils::Device::fingerprint;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#variable-imei","title":"variable imei","text":"<pre><code>std::string qqmusic::utils::Device::imei;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#variable-imsi_md5","title":"variable imsi_md5","text":"<pre><code>std::vector&lt;int&gt; qqmusic::utils::Device::imsi_md5;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#variable-ip_address","title":"variable ip_address","text":"<pre><code>std::vector&lt;int&gt; qqmusic::utils::Device::ip_address;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#variable-mac_address","title":"variable mac_address","text":"<pre><code>std::string qqmusic::utils::Device::mac_address;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#variable-model","title":"variable model","text":"<pre><code>std::string qqmusic::utils::Device::model;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#variable-os_type","title":"variable os_type","text":"<pre><code>std::string qqmusic::utils::Device::os_type;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#variable-proc_version","title":"variable proc_version","text":"<pre><code>std::string qqmusic::utils::Device::proc_version;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#variable-product","title":"variable product","text":"<pre><code>std::string qqmusic::utils::Device::product;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#variable-qimei","title":"variable qimei","text":"<pre><code>std::string qqmusic::utils::Device::qimei;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#variable-sim_info","title":"variable sim_info","text":"<pre><code>std::string qqmusic::utils::Device::sim_info;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#variable-vendor_name","title":"variable vendor_name","text":"<pre><code>std::string qqmusic::utils::Device::vendor_name;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#variable-vendor_os_name","title":"variable vendor_os_name","text":"<pre><code>std::string qqmusic::utils::Device::vendor_os_name;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#variable-version","title":"variable version","text":"<pre><code>struct OSVersion qqmusic::utils::Device::version;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#variable-wifi_bssid","title":"variable wifi_bssid","text":"<pre><code>std::string qqmusic::utils::Device::wifi_bssid;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#variable-wifi_ssid","title":"variable wifi_ssid","text":"<pre><code>std::string qqmusic::utils::Device::wifi_ssid;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#function-device","title":"function Device","text":"<pre><code>qqmusic::utils::Device::Device () \n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1Device/#function-nlohmann_define_type_intrusive","title":"function NLOHMANN_DEFINE_TYPE_INTRUSIVE","text":"<pre><code>qqmusic::utils::Device::NLOHMANN_DEFINE_TYPE_INTRUSIVE (\n    Device,\n    display,\n    product,\n    device,\n    board,\n    model,\n    fingerprint,\n    boot_id,\n    proc_version,\n    imei,\n    brand,\n    bootloader,\n    base_band,\n    version,\n    sim_info,\n    os_type,\n    mac_address,\n    wifi_bssid,\n    wifi_ssid,\n    imsi_md5,\n    android_id,\n    apn,\n    vendor_name,\n    vendor_os_name,\n    qimei\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/device.h</code></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Exception/","title":"Class qqmusic::utils::Exception","text":"<p>ClassList &gt; qqmusic &gt; utils &gt; Exception</p> <p>\u5168\u5c40\u5f02\u5e38\u7c7b </p> <ul> <li><code>#include &lt;exception.h&gt;</code></li> </ul>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Exception/#public-types","title":"Public Types","text":"Type Name enum Kind \u9519\u8bef\u7c7b\u578b\u679a\u4e3e"},{"location":"dictionary/classqqmusic_1_1utils_1_1Exception/#public-functions","title":"Public Functions","text":"Type Name Exception (Kind kind) \u4ece\u679a\u4e3e\u6784\u9020 Exception (Kind kind, std::string_view reason) \u4ece\u679a\u4e3e\u6784\u9020\u5e76\u7ed9\u51fa\u7406\u7531 Exception (unsigned int http_rc) \u4eceHTTP\u534f\u8bae\u72b6\u6001\u7801\u6784\u9020 unsigned int get_error_enum () const\u83b7\u53d6\u5f53\u524d\u9519\u8bef\u7c7b\u578b\u679a\u4e3e std::string kind () const\u8fd4\u56de\u5f53\u524d\u9519\u8bef\u7c7b\u578b\u63cf\u8ff0 std::string what () const\u8fd4\u56de\u9519\u8bef\u539f\u56e0"},{"location":"dictionary/classqqmusic_1_1utils_1_1Exception/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"dictionary/classqqmusic_1_1utils_1_1Exception/#enum-kind","title":"enum Kind","text":"<p>\u9519\u8bef\u7c7b\u578b\u679a\u4e3e <pre><code>enum qqmusic::utils::Exception::Kind {\n    ResponseCodeError = 0,\n    CredendialExpiredError,\n    CredentialInvalidError,\n    LoginError,\n    SignInvalidError,\n    DataDestroy,\n    RuntimeError,\n    NetworkError,\n    JsonError,\n    OperationOutOfTime,\n    SslError,\n    UnknownError\n};\n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Exception/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/classqqmusic_1_1utils_1_1Exception/#function-exception-13","title":"function Exception [1/3]","text":"<p>\u4ece\u679a\u4e3e\u6784\u9020 <pre><code>inline qqmusic::utils::Exception::Exception (\n    Kind kind\n) \n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Exception/#function-exception-23","title":"function Exception [2/3]","text":"<p>\u4ece\u679a\u4e3e\u6784\u9020\u5e76\u7ed9\u51fa\u7406\u7531 <pre><code>inline qqmusic::utils::Exception::Exception (\n    Kind kind,\n    std::string_view reason\n) \n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Exception/#function-exception-33","title":"function Exception [3/3]","text":"<p>\u4eceHTTP\u534f\u8bae\u72b6\u6001\u7801\u6784\u9020 <pre><code>inline qqmusic::utils::Exception::Exception (\n    unsigned int http_rc\n) \n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Exception/#function-get_error_enum","title":"function get_error_enum","text":"<p>\u83b7\u53d6\u5f53\u524d\u9519\u8bef\u7c7b\u578b\u679a\u4e3e <pre><code>inline unsigned int qqmusic::utils::Exception::get_error_enum () const\n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Exception/#function-kind","title":"function kind","text":"<p>\u8fd4\u56de\u5f53\u524d\u9519\u8bef\u7c7b\u578b\u63cf\u8ff0 <pre><code>inline std::string qqmusic::utils::Exception::kind () const\n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Exception/#function-what","title":"function what","text":"<p>\u8fd4\u56de\u9519\u8bef\u539f\u56e0 <pre><code>inline std::string qqmusic::utils::Exception::what () const\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/exception.h</code></p>"},{"location":"dictionary/structqqmusic_1_1utils_1_1OSVersion/","title":"Struct qqmusic::utils::OSVersion","text":"<p>ClassList &gt; qqmusic &gt; utils &gt; OSVersion</p>"},{"location":"dictionary/structqqmusic_1_1utils_1_1OSVersion/#public-attributes","title":"Public Attributes","text":"Type Name std::string codename std::string incremental std::string release int sdk"},{"location":"dictionary/structqqmusic_1_1utils_1_1OSVersion/#public-functions","title":"Public Functions","text":"Type Name NLOHMANN_DEFINE_TYPE_INTRUSIVE (OSVersion, incremental, release, codename, sdk)  OSVersion ()"},{"location":"dictionary/structqqmusic_1_1utils_1_1OSVersion/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"dictionary/structqqmusic_1_1utils_1_1OSVersion/#variable-codename","title":"variable codename","text":"<pre><code>std::string qqmusic::utils::OSVersion::codename;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1OSVersion/#variable-incremental","title":"variable incremental","text":"<pre><code>std::string qqmusic::utils::OSVersion::incremental;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1OSVersion/#variable-release","title":"variable release","text":"<pre><code>std::string qqmusic::utils::OSVersion::release;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1OSVersion/#variable-sdk","title":"variable sdk","text":"<pre><code>int qqmusic::utils::OSVersion::sdk;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1OSVersion/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/structqqmusic_1_1utils_1_1OSVersion/#function-nlohmann_define_type_intrusive","title":"function NLOHMANN_DEFINE_TYPE_INTRUSIVE","text":"<pre><code>qqmusic::utils::OSVersion::NLOHMANN_DEFINE_TYPE_INTRUSIVE (\n    OSVersion,\n    incremental,\n    release,\n    codename,\n    sdk\n) \n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1OSVersion/#function-osversion","title":"function OSVersion","text":"<pre><code>qqmusic::utils::OSVersion::OSVersion () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/device.h</code></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1PathManager/","title":"Class qqmusic::utils::PathManager","text":"<p>ClassList &gt; qqmusic &gt; utils &gt; PathManager</p> <p>\u8fd4\u56de\u9ed8\u8ba4\u8def\u5f84 </p> <ul> <li><code>#include &lt;paths.h&gt;</code></li> </ul>"},{"location":"dictionary/classqqmusic_1_1utils_1_1PathManager/#public-functions","title":"Public Functions","text":"Type Name fs::path get_cache_path () const\u83b7\u53d6\u7f13\u5b58\u8def\u5f84 fs::path get_download_path () const\u83b7\u53d6\u4e0b\u8f7d\u8def\u5f84 fs::path get_log_path () const\u83b7\u53d6\u65e5\u5fd7\u8def\u5f84 void set_cache_path (std::string_view path) \u8bbe\u7f6e\u7f13\u5b58\u8def\u5f84 void set_cache_path (const fs::path &amp; path)  void set_download_path (std::string_view path) \u8bbe\u7f6e\u4e0b\u8f7d\u8def\u5f84 void set_download_path (const fs::path &amp; path)  void set_log_path (std::string_view path) \u8bbe\u7f6e\u65e5\u5fd7\u8def\u5f84 void set_log_path (const fs::path &amp; path)"},{"location":"dictionary/classqqmusic_1_1utils_1_1PathManager/#public-static-functions","title":"Public Static Functions","text":"Type Name PathManager &amp; get_instance () \u83b7\u53d6\u5b9e\u4f8b\u5f15\u7528"},{"location":"dictionary/classqqmusic_1_1utils_1_1PathManager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/classqqmusic_1_1utils_1_1PathManager/#function-get_cache_path","title":"function get_cache_path","text":"<p>\u83b7\u53d6\u7f13\u5b58\u8def\u5f84 <pre><code>fs::path qqmusic::utils::PathManager::get_cache_path () const\n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1PathManager/#function-get_download_path","title":"function get_download_path","text":"<p>\u83b7\u53d6\u4e0b\u8f7d\u8def\u5f84 <pre><code>fs::path qqmusic::utils::PathManager::get_download_path () const\n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1PathManager/#function-get_log_path","title":"function get_log_path","text":"<p>\u83b7\u53d6\u65e5\u5fd7\u8def\u5f84 <pre><code>fs::path qqmusic::utils::PathManager::get_log_path () const\n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1PathManager/#function-set_cache_path-12","title":"function set_cache_path [1/2]","text":"<p>\u8bbe\u7f6e\u7f13\u5b58\u8def\u5f84 <pre><code>void qqmusic::utils::PathManager::set_cache_path (\n    std::string_view path\n) \n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1PathManager/#function-set_cache_path-22","title":"function set_cache_path [2/2]","text":"<pre><code>void qqmusic::utils::PathManager::set_cache_path (\n    const fs::path &amp; path\n) \n</code></pre>"},{"location":"dictionary/classqqmusic_1_1utils_1_1PathManager/#function-set_download_path-12","title":"function set_download_path [1/2]","text":"<p>\u8bbe\u7f6e\u4e0b\u8f7d\u8def\u5f84 <pre><code>void qqmusic::utils::PathManager::set_download_path (\n    std::string_view path\n) \n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1PathManager/#function-set_download_path-22","title":"function set_download_path [2/2]","text":"<pre><code>void qqmusic::utils::PathManager::set_download_path (\n    const fs::path &amp; path\n) \n</code></pre>"},{"location":"dictionary/classqqmusic_1_1utils_1_1PathManager/#function-set_log_path-12","title":"function set_log_path [1/2]","text":"<p>\u8bbe\u7f6e\u65e5\u5fd7\u8def\u5f84 <pre><code>void qqmusic::utils::PathManager::set_log_path (\n    std::string_view path\n) \n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1PathManager/#function-set_log_path-22","title":"function set_log_path [2/2]","text":"<pre><code>void qqmusic::utils::PathManager::set_log_path (\n    const fs::path &amp; path\n) \n</code></pre>"},{"location":"dictionary/classqqmusic_1_1utils_1_1PathManager/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"dictionary/classqqmusic_1_1utils_1_1PathManager/#function-get_instance","title":"function get_instance","text":"<p>\u83b7\u53d6\u5b9e\u4f8b\u5f15\u7528 <pre><code>static PathManager &amp; qqmusic::utils::PathManager::get_instance () \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/paths.h</code></p>"},{"location":"dictionary/structqqmusic_1_1utils_1_1QimeiResult/","title":"Struct qqmusic::utils::QimeiResult","text":"<p>ClassList &gt; qqmusic &gt; utils &gt; QimeiResult</p>"},{"location":"dictionary/structqqmusic_1_1utils_1_1QimeiResult/#public-attributes","title":"Public Attributes","text":"Type Name std::string q16 std::string q36"},{"location":"dictionary/structqqmusic_1_1utils_1_1QimeiResult/#public-functions","title":"Public Functions","text":"Type Name NLOHMANN_DEFINE_TYPE_INTRUSIVE (QimeiResult, q16, q36)"},{"location":"dictionary/structqqmusic_1_1utils_1_1QimeiResult/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"dictionary/structqqmusic_1_1utils_1_1QimeiResult/#variable-q16","title":"variable q16","text":"<pre><code>std::string qqmusic::utils::QimeiResult::q16;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1QimeiResult/#variable-q36","title":"variable q36","text":"<pre><code>std::string qqmusic::utils::QimeiResult::q36;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1utils_1_1QimeiResult/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/structqqmusic_1_1utils_1_1QimeiResult/#function-nlohmann_define_type_intrusive","title":"function NLOHMANN_DEFINE_TYPE_INTRUSIVE","text":"<pre><code>qqmusic::utils::QimeiResult::NLOHMANN_DEFINE_TYPE_INTRUSIVE (\n    QimeiResult,\n    q16,\n    q36\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/qimei.h</code></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Session/","title":"Class qqmusic::utils::Session","text":"<p>ClassList &gt; qqmusic &gt; utils &gt; Session</p> <p>\u4e0a\u4e0b\u6587 </p> <ul> <li><code>#include &lt;session.h&gt;</code></li> </ul>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Session/#public-functions","title":"Public Functions","text":"Type Name Session () = delete Session (qqmusic::details::NetworkContext &amp; nc, std::shared_ptr&lt; asio::io_context &gt; ioc_ptr, std::shared_ptr&lt; asio::ssl::context &gt; ssl_ctx_ptr, std::mutex &amp; lock) \u6784\u9020\u51fd\u6570, \u6b63\u5e38\u60c5\u51b5\u4e0b\u4e0d\u5e94\u8be5\u4f7f\u7528 qqmusic::details::NetworkContext &amp; get_context_ref () \u83b7\u53d6 <code>session</code> \u5b9e\u4f8b\u7684\u4e0a\u4e0b\u6587\u5f15\u7528 qqmusic::Task&lt; qqmusic::Result&lt; HttpResponse &gt; &gt; perform_request (boost::url_view url, http::request&lt; http::string_body &gt; &amp; req, bool auto_redirecting=true) \u53d1\u9001\u7f51\u7edc\u8bf7\u6c42, \u8fd4\u56de\u56de\u590d\u62a5\u6587 void sync_global () \u5c06\u4e0a\u4e0b\u6587\u7684\u66f4\u6539\u5199\u56de\u5168\u5c40 void update_local () \u5c06\u5168\u5c40\u7684\u66f4\u6539\u540c\u6b65\u5230\u672c\u5b9e\u4f8b"},{"location":"dictionary/classqqmusic_1_1utils_1_1Session/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/classqqmusic_1_1utils_1_1Session/#function-session-12","title":"function Session [1/2]","text":"<pre><code>qqmusic::utils::Session::Session () = delete\n</code></pre>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Session/#function-session-22","title":"function Session [2/2]","text":"<p>\u6784\u9020\u51fd\u6570, \u6b63\u5e38\u60c5\u51b5\u4e0b\u4e0d\u5e94\u8be5\u4f7f\u7528 <pre><code>inline qqmusic::utils::Session::Session (\n    qqmusic::details::NetworkContext &amp; nc,\n    std::shared_ptr&lt; asio::io_context &gt; ioc_ptr,\n    std::shared_ptr&lt; asio::ssl::context &gt; ssl_ctx_ptr,\n    std::mutex &amp; lock\n) \n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Session/#function-get_context_ref","title":"function get_context_ref","text":"<p>\u83b7\u53d6 <code>session</code> \u5b9e\u4f8b\u7684\u4e0a\u4e0b\u6587\u5f15\u7528 <pre><code>qqmusic::details::NetworkContext &amp; qqmusic::utils::Session::get_context_ref () \n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Session/#function-perform_request","title":"function perform_request","text":"<p>\u53d1\u9001\u7f51\u7edc\u8bf7\u6c42, \u8fd4\u56de\u56de\u590d\u62a5\u6587 <pre><code>qqmusic::Task&lt; qqmusic::Result&lt; HttpResponse &gt; &gt; qqmusic::utils::Session::perform_request (\n    boost::url_view url,\n    http::request&lt; http::string_body &gt; &amp; req,\n    bool auto_redirecting=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>url</code> \u8bf7\u6c42url </li> <li><code>req</code> \u8bf7\u6c42\u5bf9\u8c61 </li> <li><code>auto_redirecting</code> \u662f\u5426\u5f00\u542f\u81ea\u52a8\u91cd\u5b9a\u5411, \u9ed8\u8ba4<code>true</code></li> </ul> <p>Returns:</p> <p><code>qqmusic::Task&lt;qqmusic::Result&lt;HttpResponse&gt;&gt;</code>, \u8fd4\u56de\u539f\u59cb\u62a5\u6587</p> <p>Note:</p> <p>\u5f02\u6b65\u51fd\u6570, \u8fd4\u56de<code>Task</code> </p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Session/#function-sync_global","title":"function sync_global","text":"<p>\u5c06\u4e0a\u4e0b\u6587\u7684\u66f4\u6539\u5199\u56de\u5168\u5c40 <pre><code>void qqmusic::utils::Session::sync_global () \n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1Session/#function-update_local","title":"function update_local","text":"<p>\u5c06\u5168\u5c40\u7684\u66f4\u6539\u540c\u6b65\u5230\u672c\u5b9e\u4f8b <pre><code>void qqmusic::utils::Session::update_local () \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/session.h</code></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1SessionGuard/","title":"Class qqmusic::utils::SessionGuard","text":"<p>ClassList &gt; qqmusic &gt; utils &gt; SessionGuard</p> <p>\u4e00\u4e2a <code>RAII</code> \u98ce\u683c\u7684Session\u5207\u6362\u5668</p> <ul> <li><code>#include &lt;session.h&gt;</code></li> </ul>"},{"location":"dictionary/classqqmusic_1_1utils_1_1SessionGuard/#public-functions","title":"Public Functions","text":"Type Name SessionGuard (SessionManager &amp; sm, Session s)  SessionGuard (SessionManager &amp; sm, details::NetworkContext ctx)  ~SessionGuard ()"},{"location":"dictionary/classqqmusic_1_1utils_1_1SessionGuard/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/classqqmusic_1_1utils_1_1SessionGuard/#function-sessionguard-12","title":"function SessionGuard [1/2]","text":"<pre><code>inline qqmusic::utils::SessionGuard::SessionGuard (\n    SessionManager &amp; sm,\n    Session s\n) \n</code></pre>"},{"location":"dictionary/classqqmusic_1_1utils_1_1SessionGuard/#function-sessionguard-22","title":"function SessionGuard [2/2]","text":"<pre><code>inline qqmusic::utils::SessionGuard::SessionGuard (\n    SessionManager &amp; sm,\n    details::NetworkContext ctx\n) \n</code></pre>"},{"location":"dictionary/classqqmusic_1_1utils_1_1SessionGuard/#function-sessionguard","title":"function ~SessionGuard","text":"<pre><code>inline qqmusic::utils::SessionGuard::~SessionGuard () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/session.h</code></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1SessionManager/","title":"Class qqmusic::utils::SessionManager","text":"<p>ClassList &gt; qqmusic &gt; utils &gt; SessionManager</p> <p>\u5168\u5c40\u5355\u4f8b\u7684Session\u7ba1\u7406\u5668, \u8d1f\u8d23\u7ef4\u62a4\u5168\u5c40\u4e0a\u4e0b\u6587\u6808, \u5e76\u8d1f\u8d23 <code>session</code> \u5b9e\u4f8b\u7684\u751f\u6210</p> <ul> <li><code>#include &lt;session.h&gt;</code></li> </ul>"},{"location":"dictionary/classqqmusic_1_1utils_1_1SessionManager/#public-functions","title":"Public Functions","text":"Type Name SessionManager (const SessionManager &amp;) = delete Session get_session () \u83b7\u53d6\u4e00\u4e2a <code>session</code> \u5b9e\u4f8b SessionManager operator= (const SessionManager &amp;) = delete void pop_context () \u4e0a\u4e0b\u6587\u6808\u5f39\u51fa\u6808\u9876\u5143\u7d20 void push_context (qqmusic::details::NetworkContext &amp;&amp; context) \u5c06\u6307\u5b9a\u7684\u4e0a\u4e0b\u6587\u538b\u6808 void set_context (const qqmusic::details::NetworkContext &amp; context) \u66ff\u6362\u4e0a\u4e0b\u6587\u6808\u6808\u9876\u7684\u4e0a\u4e0b\u6587"},{"location":"dictionary/classqqmusic_1_1utils_1_1SessionManager/#public-static-functions","title":"Public Static Functions","text":"Type Name SessionManager &amp; get_instance () \u83b7\u53d6Session\u7ba1\u7406\u5668\u5b9e\u4f8b"},{"location":"dictionary/classqqmusic_1_1utils_1_1SessionManager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/classqqmusic_1_1utils_1_1SessionManager/#function-sessionmanager-12","title":"function SessionManager [1/2]","text":"<pre><code>qqmusic::utils::SessionManager::SessionManager (\n    const SessionManager &amp;\n) = delete\n</code></pre>"},{"location":"dictionary/classqqmusic_1_1utils_1_1SessionManager/#function-get_session","title":"function get_session","text":"<p>\u83b7\u53d6\u4e00\u4e2a <code>session</code> \u5b9e\u4f8b <pre><code>Session qqmusic::utils::SessionManager::get_session () \n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1SessionManager/#function-operator","title":"function operator=","text":"<pre><code>SessionManager qqmusic::utils::SessionManager::operator= (\n    const SessionManager &amp;\n) = delete\n</code></pre>"},{"location":"dictionary/classqqmusic_1_1utils_1_1SessionManager/#function-pop_context","title":"function pop_context","text":"<p>\u4e0a\u4e0b\u6587\u6808\u5f39\u51fa\u6808\u9876\u5143\u7d20 <pre><code>void qqmusic::utils::SessionManager::pop_context () \n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1SessionManager/#function-push_context","title":"function push_context","text":"<p>\u5c06\u6307\u5b9a\u7684\u4e0a\u4e0b\u6587\u538b\u6808 <pre><code>void qqmusic::utils::SessionManager::push_context (\n    qqmusic::details::NetworkContext &amp;&amp; context\n) \n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1SessionManager/#function-set_context","title":"function set_context","text":"<p>\u66ff\u6362\u4e0a\u4e0b\u6587\u6808\u6808\u9876\u7684\u4e0a\u4e0b\u6587 <pre><code>void qqmusic::utils::SessionManager::set_context (\n    const qqmusic::details::NetworkContext &amp; context\n) \n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1SessionManager/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"dictionary/classqqmusic_1_1utils_1_1SessionManager/#function-get_instance","title":"function get_instance","text":"<p>\u83b7\u53d6Session\u7ba1\u7406\u5668\u5b9e\u4f8b <pre><code>static SessionManager &amp; qqmusic::utils::SessionManager::get_instance () \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/session.h</code></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1buffer/","title":"Class qqmusic::utils::buffer","text":"<p>ClassList &gt; qqmusic &gt; utils &gt; buffer</p> <p>\u4e8c\u8fdb\u5236\u7f13\u51b2\u533a\u7684\u7edf\u4e00\u8868\u793a </p> <ul> <li><code>#include &lt;buffer.h&gt;</code></li> </ul> <p>Inherits the following classes: std::vector&lt; uint8_t &gt;</p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1buffer/#public-functions","title":"Public Functions","text":"Type Name void append (const void * src_data_buf, size_t data_buf_size) \u5c06\u4e00\u6bb5\u5185\u5b58\u63d2\u5230\u8fd9\u6bb5buffer\u540e\u9762 buffer () = default\u9ed8\u8ba4\u521d\u59cb\u5316 buffer (size_t size) \u9884\u5148\u5206\u914d\u5f02\u4e01\u9187\u957f\u5ea6 buffer (const uint8_t * src_head, size_t src_size) \u76f4\u63a5\u4ece\u5185\u5b58\u533a\u57df\u8fdb\u884c\u6784\u9020 buffer (std::vector&lt; uint8_t &gt; &amp;&amp; other) noexcept\u4ecestd::vector&lt;uint8_t&gt;\u79fb\u52a8\u6784\u9020 buffer (buffer &amp;&amp; other) noexcept\u79fb\u52a8\u6784\u9020 buffer (size_t size, char c) \u521d\u59cb\u5316\u4e3a\u7279\u5b9a\u5b57\u7b26 buffer (const buffer &amp; other) = default\u62f7\u8d1d\u6784\u9020\u51fd\u6570 buffer operator+ (const buffer &amp; a) \u4e24\u6bb5buffer\u62fc\u63a5, \u5e76\u8fd4\u56de\u6784\u9020\u65b0\u7684buffer buffer operator+= (const buffer &amp; a) \u5c06\u4e00\u6bb5buffer\u63d2\u5165\u672c\u6bb5buffer\u672b\u5c3e buffer &amp; operator= (const buffer &amp; other) = default\u62f7\u8d1d\u6784\u9020\u51fd\u6570, \u91cd\u8f7d <code>=</code> __ ~buffer () = default"},{"location":"dictionary/classqqmusic_1_1utils_1_1buffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/classqqmusic_1_1utils_1_1buffer/#function-append","title":"function append","text":"<p>\u5c06\u4e00\u6bb5\u5185\u5b58\u63d2\u5230\u8fd9\u6bb5buffer\u540e\u9762 <pre><code>inline void qqmusic::utils::buffer::append (\n    const void * src_data_buf,\n    size_t data_buf_size\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>src_data_buf</code> \u5f85\u63d2\u5165\u6570\u636e\u7684\u9996\u5730\u5740 </li> <li><code>data_buf_size</code> \u5f85\u63d2\u5165\u6570\u636e\u7684\u957f\u5ea6 </li> </ul>"},{"location":"dictionary/classqqmusic_1_1utils_1_1buffer/#function-buffer-17","title":"function buffer [1/7]","text":"<p>\u9ed8\u8ba4\u521d\u59cb\u5316 <pre><code>qqmusic::utils::buffer::buffer () = default\n</code></pre></p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1buffer/#function-buffer-27","title":"function buffer [2/7]","text":"<p>\u9884\u5148\u5206\u914d\u5f02\u4e01\u9187\u957f\u5ea6 <pre><code>inline qqmusic::utils::buffer::buffer (\n    size_t size\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>size</code> \u9884\u5148\u5206\u914d\u957f\u5ea6 </li> </ul>"},{"location":"dictionary/classqqmusic_1_1utils_1_1buffer/#function-buffer-37","title":"function buffer [3/7]","text":"<p>\u76f4\u63a5\u4ece\u5185\u5b58\u533a\u57df\u8fdb\u884c\u6784\u9020 <pre><code>inline qqmusic::utils::buffer::buffer (\n    const uint8_t * src_head,\n    size_t src_size\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>src_head</code> \u5185\u5b58\u533a\u57df\u7684\u9996\u5730\u5740 </li> <li><code>src_size</code> \u5185\u5b58\u533a\u57df\u957f\u5ea6</li> </ul> <p>Note:</p> <p>\u662f\u62f7\u8d1d\u521d\u59cb\u5316 </p>"},{"location":"dictionary/classqqmusic_1_1utils_1_1buffer/#function-buffer-47","title":"function buffer [4/7]","text":"<p>\u4ecestd::vector&lt;uint8_t&gt;\u79fb\u52a8\u6784\u9020 <pre><code>inline qqmusic::utils::buffer::buffer (\n    std::vector&lt; uint8_t &gt; &amp;&amp; other\n) noexcept\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>other</code> </li> </ul>"},{"location":"dictionary/classqqmusic_1_1utils_1_1buffer/#function-buffer-57","title":"function buffer [5/7]","text":"<p>\u79fb\u52a8\u6784\u9020 <pre><code>inline qqmusic::utils::buffer::buffer (\n    buffer &amp;&amp; other\n) noexcept\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>other</code> </li> </ul>"},{"location":"dictionary/classqqmusic_1_1utils_1_1buffer/#function-buffer-67","title":"function buffer [6/7]","text":"<p>\u521d\u59cb\u5316\u4e3a\u7279\u5b9a\u5b57\u7b26 <pre><code>inline qqmusic::utils::buffer::buffer (\n    size_t size,\n    char c\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>size</code> \u9884\u5148\u521d\u59cb\u5316\u957f\u5ea6 </li> <li><code>c</code> \u9700\u8981\u586b\u5145\u7684\u5b57\u7b26 </li> </ul>"},{"location":"dictionary/classqqmusic_1_1utils_1_1buffer/#function-buffer-77","title":"function buffer [7/7]","text":"<p>\u62f7\u8d1d\u6784\u9020\u51fd\u6570 <pre><code>qqmusic::utils::buffer::buffer (\n    const buffer &amp; other\n) = default\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>other</code> </li> </ul>"},{"location":"dictionary/classqqmusic_1_1utils_1_1buffer/#function-operator","title":"function operator+","text":"<p>\u4e24\u6bb5buffer\u62fc\u63a5, \u5e76\u8fd4\u56de\u6784\u9020\u65b0\u7684buffer <pre><code>inline buffer qqmusic::utils::buffer::operator+ (\n    const buffer &amp; a\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>a</code> </li> </ul>"},{"location":"dictionary/classqqmusic_1_1utils_1_1buffer/#function-operator_1","title":"function operator+=","text":"<p>\u5c06\u4e00\u6bb5buffer\u63d2\u5165\u672c\u6bb5buffer\u672b\u5c3e <pre><code>inline buffer qqmusic::utils::buffer::operator+= (\n    const buffer &amp; a\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>a</code> </li> </ul>"},{"location":"dictionary/classqqmusic_1_1utils_1_1buffer/#function-operator_2","title":"function operator=","text":"<p>\u62f7\u8d1d\u6784\u9020\u51fd\u6570, \u91cd\u8f7d <code>=</code> __ <pre><code>buffer &amp; qqmusic::utils::buffer::operator= (\n    const buffer &amp; other\n) = default\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>other</code> </li> </ul>"},{"location":"dictionary/classqqmusic_1_1utils_1_1buffer/#function-buffer","title":"function ~buffer","text":"<pre><code>qqmusic::utils::buffer::~buffer () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/buffer.h</code></p>"},{"location":"dictionary/structqqmusic_1_1EncryptedSongFileType_1_1CoreData/","title":"Struct qqmusic::EncryptedSongFileType::CoreData","text":"<p>ClassList &gt; CoreData</p>"},{"location":"dictionary/structqqmusic_1_1EncryptedSongFileType_1_1CoreData/#public-attributes","title":"Public Attributes","text":"Type Name std::string extention std::string start_id"},{"location":"dictionary/structqqmusic_1_1EncryptedSongFileType_1_1CoreData/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"dictionary/structqqmusic_1_1EncryptedSongFileType_1_1CoreData/#variable-extention","title":"variable extention","text":"<pre><code>std::string qqmusic::EncryptedSongFileType::CoreData::extention;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1EncryptedSongFileType_1_1CoreData/#variable-start_id","title":"variable start_id","text":"<pre><code>std::string qqmusic::EncryptedSongFileType::CoreData::start_id;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/song.h</code></p>"},{"location":"dictionary/structqqmusic_1_1SongFileType_1_1CoreData/","title":"Struct qqmusic::SongFileType::CoreData","text":"<p>ClassList &gt; CoreData</p>"},{"location":"dictionary/structqqmusic_1_1SongFileType_1_1CoreData/#public-attributes","title":"Public Attributes","text":"Type Name std::string extention std::string start_id"},{"location":"dictionary/structqqmusic_1_1SongFileType_1_1CoreData/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"dictionary/structqqmusic_1_1SongFileType_1_1CoreData/#variable-extention","title":"variable extention","text":"<pre><code>std::string qqmusic::SongFileType::CoreData::extention;\n</code></pre>"},{"location":"dictionary/structqqmusic_1_1SongFileType_1_1CoreData/#variable-start_id","title":"variable start_id","text":"<pre><code>std::string qqmusic::SongFileType::CoreData::start_id;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/song.h</code></p>"},{"location":"dictionary/structqqmusic_1_1TabType_1_1Tab/","title":"Struct qqmusic::TabType::Tab","text":"<p>ClassList &gt; Tab</p> <p>\u6807\u7b7e\u4fe1\u606f\u7ed3\u6784 </p>"},{"location":"dictionary/structqqmusic_1_1TabType_1_1Tab/#public-attributes","title":"Public Attributes","text":"Type Name std::string tab_id tab ID std::string tab_name tab \u540d\u79f0"},{"location":"dictionary/structqqmusic_1_1TabType_1_1Tab/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"dictionary/structqqmusic_1_1TabType_1_1Tab/#variable-tab_id","title":"variable tab_id","text":"<p>tab ID <pre><code>std::string qqmusic::TabType::Tab::tab_id;\n</code></pre></p>"},{"location":"dictionary/structqqmusic_1_1TabType_1_1Tab/#variable-tab_name","title":"variable tab_name","text":"<p>tab \u540d\u79f0 <pre><code>std::string qqmusic::TabType::Tab::tab_name;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/singer.h</code></p>"},{"location":"dictionary/namespacestd/","title":"Namespace std","text":"<p>Namespace List &gt; std</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"dictionary/namespacetypes/","title":"Namespace types","text":"<p>Namespace List &gt; types</p>"},{"location":"dictionary/namespacetypes/#classes","title":"Classes","text":"Type Name struct Err &lt;typename E&gt; struct Ok &lt;typename T&gt; struct Ok&lt; void &gt; &lt;&gt; <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structtypes_1_1Err/","title":"Struct types::Err","text":"<p>template &lt;typename E&gt;</p> <p>ClassList &gt; types &gt; Err</p>"},{"location":"dictionary/structtypes_1_1Err/#public-attributes","title":"Public Attributes","text":"Type Name E val"},{"location":"dictionary/structtypes_1_1Err/#public-functions","title":"Public Functions","text":"Type Name Err (const E &amp; val)  Err (E &amp;&amp; val)"},{"location":"dictionary/structtypes_1_1Err/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"dictionary/structtypes_1_1Err/#variable-val","title":"variable val","text":"<pre><code>E types::Err&lt; E &gt;::val;\n</code></pre>"},{"location":"dictionary/structtypes_1_1Err/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/structtypes_1_1Err/#function-err-12","title":"function Err [1/2]","text":"<pre><code>inline types::Err::Err (\n    const E &amp; val\n) \n</code></pre>"},{"location":"dictionary/structtypes_1_1Err/#function-err-22","title":"function Err [2/2]","text":"<pre><code>inline types::Err::Err (\n    E &amp;&amp; val\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structtypes_1_1Ok/","title":"Struct types::Ok","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; types &gt; Ok</p>"},{"location":"dictionary/structtypes_1_1Ok/#public-attributes","title":"Public Attributes","text":"Type Name T val"},{"location":"dictionary/structtypes_1_1Ok/#public-functions","title":"Public Functions","text":"Type Name Ok (const T &amp; val)  Ok (T &amp;&amp; val)"},{"location":"dictionary/structtypes_1_1Ok/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"dictionary/structtypes_1_1Ok/#variable-val","title":"variable val","text":"<pre><code>T types::Ok&lt; T &gt;::val;\n</code></pre>"},{"location":"dictionary/structtypes_1_1Ok/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/structtypes_1_1Ok/#function-ok-12","title":"function Ok [1/2]","text":"<pre><code>inline types::Ok::Ok (\n    const T &amp; val\n) \n</code></pre>"},{"location":"dictionary/structtypes_1_1Ok/#function-ok-22","title":"function Ok [2/2]","text":"<pre><code>inline types::Ok::Ok (\n    T &amp;&amp; val\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/structtypes_1_1Ok_3_01void_01_4/","title":"Struct types::Ok&lt; void &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; types &gt; Ok&lt; void &gt;</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/dir_d44c64559bbebec7f509842c48db8b23/","title":"Dir include","text":"<p>FileList &gt; include</p>"},{"location":"dictionary/dir_d44c64559bbebec7f509842c48db8b23/#directories","title":"Directories","text":"Type Name dir qqmusic <p>The documentation for this class was generated from the following file <code>include/</code></p>"},{"location":"dictionary/dir_d63c0418b33b823a308efea67b8f3df2/","title":"Dir qqmusic","text":"<p>FileList &gt; include &gt; qqmusic</p>"},{"location":"dictionary/dir_d63c0418b33b823a308efea67b8f3df2/#files","title":"Files","text":"Type Name file album.h \u4e13\u8f91\u76f8\u5173Api file login.h \u767b\u9646\u76f8\u5173Api, \u5305\u542b\u4e09\u79cd\u767b\u9646\u65b9\u5f0f QQ\u626b\u7801, \u5fae\u4fe1\u626b\u7801, \u624b\u673a\u53f7\u767b\u9646 file lyric.h file mv.h \u5173\u4e8eMV\u7684Api file result.h \u63d0\u4f9b\u8fd4\u56de\u503c\u7c7b\u578b\u7684\u5c01\u88c5 file search.h \u641c\u7d22\u76f8\u5173Api file singer.h \u6b4c\u624b\u76f8\u5173API file song.h \u6b4c\u66f2\u76f8\u5173API file songlist.h file toplist.h file user.h \u7528\u6237\u76f8\u5173Api"},{"location":"dictionary/dir_d63c0418b33b823a308efea67b8f3df2/#directories","title":"Directories","text":"Type Name dir crypto dir details dir utils <p>The documentation for this class was generated from the following file <code>include/qqmusic/</code></p>"},{"location":"dictionary/album_8h/","title":"File album.h","text":"<p>FileList &gt; include &gt; qqmusic &gt; album.h</p> <p>Go to the source code of this file</p> <p>\u4e13\u8f91\u76f8\u5173Api More...</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;nlohmann/json.hpp&gt;</code></li> <li><code>#include &lt;qqmusic/details/api.h&gt;</code></li> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;string_view&gt;</code></li> </ul>"},{"location":"dictionary/album_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic"},{"location":"dictionary/album_8h/#detailed-description","title":"Detailed Description","text":"<p>-----------------------------------qqmusic/album.h-----------------------------------------</p> <p>Date:</p> <p>2025-4-2</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/album.h</code></p>"},{"location":"dictionary/album_8h_source/","title":"File album.h","text":"<p>File List &gt; include &gt; qqmusic &gt; album.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QQMUSIC_ALBUM_H\n#define QQMUSIC_ALBUM_H\n\n#include &lt;cstdint&gt;\n#include &lt;nlohmann/json.hpp&gt;\n#include &lt;qqmusic/details/api.h&gt;\n#include &lt;qqmusic/result.h&gt;\n#include &lt;string&gt;\n#include &lt;string_view&gt;\n\nnamespace qqmusic {\n\nenum class CoverSize : int { SMALL = 150, DEFAULT = 300, MIDIUM = 500, LARGE = 800 };\n\nstd::string get_album_cover_url(std::string_view mid, CoverSize size);\n\nqqmusic::Task&lt;qqmusic::Result&lt;nlohmann::json&gt;&gt; get_album_detail(std::string_view album_mid);\n\nqqmusic::Task&lt;qqmusic::Result&lt;nlohmann::json&gt;&gt; get_album_detail(uint64_t album_id);\n\nqqmusic::Task&lt;qqmusic::Result&lt;nlohmann::json&gt;&gt; get_album_songs(std::string_view album_mid,\n                                                               unsigned int num = 10,\n                                                               unsigned int page = 1);\n\nqqmusic::Task&lt;qqmusic::Result&lt;nlohmann::json&gt;&gt; get_album_songs(uint64_t album_id,\n                                                               unsigned int num = 10,\n                                                               unsigned int page = 1);\n\n} // namespace qqmusic\n\n#endif // !QQMUSIC_ALBUM_H\n</code></pre>"},{"location":"dictionary/dir_544e59fdeba566aba49a0802b8225c84/","title":"Dir crypto","text":"<p>FileList &gt; crypto</p>"},{"location":"dictionary/dir_544e59fdeba566aba49a0802b8225c84/#files","title":"Files","text":"Type Name file cipher.h cipher \u7684\u57fa\u7c7b file cipher_map.h cipher_map file cipher_rc4.h cipher_rc4 file cipher_tea.h TEA\u7b97\u6cd5\u89e3\u5bc6\u5b9e\u73b0 file key_derive.h QQ\u97f3\u4e50\u5bc6\u94a5\u89e3\u5bc6\u7b97\u6cd5\u5b9e\u73b0 file qmc.h QQ\u97f3\u4e50\u52a0\u5bc6\u6587\u4ef6\u89e3\u7801\u5668\u6838\u5fc3\u6a21\u5757 <p>The documentation for this class was generated from the following file <code>include/qqmusic/crypto/</code></p>"},{"location":"dictionary/cipher_8h/","title":"File cipher.h","text":"<p>FileList &gt; crypto &gt; cipher.h</p> <p>Go to the source code of this file</p> <p>cipher \u7684\u57fa\u7c7b More...</p> <ul> <li><code>#include &lt;qqmusic/utils/buffer.h&gt;</code></li> </ul>"},{"location":"dictionary/cipher_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace crypto"},{"location":"dictionary/cipher_8h/#classes","title":"Classes","text":"Type Name class Cipher"},{"location":"dictionary/cipher_8h/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>kingpoem </p> <p>Version:</p> <p>0.1 </p> <p>Date:</p> <p>2025-04-02</p> <p>Copyright:</p> <p>Copyright (c) 2025 </p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/crypto/cipher.h</code></p>"},{"location":"dictionary/cipher_8h_source/","title":"File cipher.h","text":"<p>File List &gt; crypto &gt; cipher.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QQMUSIC_CRYPTO_CIPHER_H\n#define QQMUSIC_CRYPTO_CIPHER_H\n\n#include &lt;qqmusic/utils/buffer.h&gt;\n\nnamespace qqmusic::crypto {\nclass Cipher {\npublic:\n    virtual ~Cipher() = default;\n    virtual void decrypt(qqmusic::utils::buffer&amp; buf, size_t offset) = 0;\n};\n\n} // namespace qqmusic::crypto\n\n#endif // !QQMUSIC_CRYPTO_CIPHER_H\n</code></pre>"},{"location":"dictionary/cipher__map_8h/","title":"File cipher_map.h","text":"<p>FileList &gt; crypto &gt; cipher_map.h</p> <p>Go to the source code of this file</p> <p>cipher_map More...</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;qqmusic/crypto/cipher.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/buffer.h&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"dictionary/cipher__map_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace crypto"},{"location":"dictionary/cipher__map_8h/#classes","title":"Classes","text":"Type Name class MapCipher"},{"location":"dictionary/cipher__map_8h/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>kingpoem </p> <p>Version:</p> <p>0.1 </p> <p>Date:</p> <p>2025-03-15 \u89e3\u5bc6\u7b97\u6cd5\u4e2d\u7684\u4e00\u79cd\uff0c\u9002\u7528\u4e8eQQ\u97f3\u4e50\u7684\u65e9\u671f\u52a0\u5bc6 </p> <p>Copyright:</p> <p>Copyright (c) 2025 </p> <p>See also: https://git.unlock-music.dev/um/cli/src/branch/main/algo/qmc/cipher_map.go <pre><code>qqmusic::crypto::MapCipher cipher(key);\ncipher.decrypt(buf, 0);\n</code></pre></p> <p>Note:</p> <p>\u8be5\u63a5\u53e3\u672a\u6d4b\u8bd5\uff0c\u6682\u4e0d\u53ef\u7528 </p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/crypto/cipher_map.h</code></p>"},{"location":"dictionary/cipher__map_8h_source/","title":"File cipher_map.h","text":"<p>File List &gt; crypto &gt; cipher_map.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QQ_MUSIC_CIPHER_MAP_H\n#define QQ_MUSIC_CIPHER_MAP_H\n\n#include &lt;cstdint&gt;\n#include &lt;qqmusic/crypto/cipher.h&gt;\n#include &lt;qqmusic/utils/buffer.h&gt;\n#include &lt;vector&gt;\n\nnamespace qqmusic::crypto {\n\nclass MapCipher : public Cipher {\npublic:\n    explicit MapCipher(const std::vector&lt;uint8_t&gt;&amp; key);\n\n    void decrypt(qqmusic::utils::buffer&amp; buf, size_t offset) override;\n\nprivate:\n    std::vector&lt;uint8_t&gt; key;\n};\n\n} // namespace qqmusic::crypto\n\n#endif // !QQ_MUSIC_CIPHER_MAP_H\n</code></pre>"},{"location":"dictionary/cipher__rc4_8h/","title":"File cipher_rc4.h","text":"<p>FileList &gt; crypto &gt; cipher_rc4.h</p> <p>Go to the source code of this file</p> <p>cipher_rc4 More...</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;qqmusic/crypto/cipher.h&gt;</code></li> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/buffer.h&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"dictionary/cipher__rc4_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace crypto"},{"location":"dictionary/cipher__rc4_8h/#classes","title":"Classes","text":"Type Name class RC4Cipher"},{"location":"dictionary/cipher__rc4_8h/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>kingpoem </p> <p>Version:</p> <p>0.1 </p> <p>Date:</p> <p>2025-03-16 </p> <p>Copyright:</p> <p>Copyright (c) 2025 </p> <p>See also: https://git.unlock-music.dev/um/cli/src/branch/main/algo/qmc/cipher_rc4.go <pre><code>qqmusic::crypto::RC4Cipher cipher(key);\ncipher.decrypt(buf, 0);\n</code></pre></p> <p>Note:</p> <p>\u8be5\u63a5\u53e3\u672a\u6d4b\u8bd5\uff0c\u6682\u4e0d\u53ef\u7528 </p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/crypto/cipher_rc4.h</code></p>"},{"location":"dictionary/cipher__rc4_8h_source/","title":"File cipher_rc4.h","text":"<p>File List &gt; crypto &gt; cipher_rc4.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QQMUSIC_CRYPTO_CIPHER_RC4_H\n#define QQMUSIC_CRYPTO_CIPHER_RC4_H\n\n#include &lt;cstdint&gt;\n#include &lt;qqmusic/crypto/cipher.h&gt;\n#include &lt;qqmusic/result.h&gt;\n#include &lt;qqmusic/utils/buffer.h&gt;\n#include &lt;vector&gt;\n\nnamespace qqmusic::crypto {\n\nclass RC4Cipher : public Cipher {\npublic:\n    explicit RC4Cipher(const std::vector&lt;uint8_t&gt;&amp; key);\n\n    void decrypt(qqmusic::utils::buffer&amp; buf, size_t offset) override;\n\nprivate:\n    std::vector&lt;uint8_t&gt; key;\n};\n\n} // namespace qqmusic::crypto\n\n#endif // !QQMUSIC_CRYPTO_CIPHER_RC4_H\n</code></pre>"},{"location":"dictionary/cipher__tea_8h/","title":"File cipher_tea.h","text":"<p>FileList &gt; crypto &gt; cipher_tea.h</p> <p>Go to the source code of this file</p> <p>TEA\u7b97\u6cd5\u89e3\u5bc6\u5b9e\u73b0 More...</p> <ul> <li><code>#include &lt;botan/secmem.h&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;qqmusic/utils/buffer.h&gt;</code></li> </ul>"},{"location":"dictionary/cipher__tea_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace crypto namespace TeaCipher"},{"location":"dictionary/cipher__tea_8h/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>kingpoem </p> <p>Version:</p> <p>0.1 </p> <p>Date:</p> <p>2025-03-22 \u5b9e\u73b0QQ\u97f3\u4e50\u52a0\u5bc6\u683c\u5f0f\u4f7f\u7528\u7684TEA\u53d8\u79cd\u7b97\u6cd5\uff0c\u652f\u630132\u8f6e\u89e3\u5bc6\uff0c\u6bcf\u6b21\u89e3\u5bc68\u5b57\u8282 </p> <p>Copyright:</p> <p>Copyright (c) 2025 </p> <p>See also: https://pkg.go.dev/golang.org/x/crypto/tea <pre><code>for (size_t offset = 0; offset &lt; buf.size(); offset += 8) {\n    qqmusic::crypto::TeaCipher::decrypt(buf, offset, key);\n}\n</code></pre></p> <p>Note:</p> <p>\u8be5\u63a5\u53e3\u672a\u6d4b\u8bd5\uff0c\u6682\u4e0d\u53ef\u7528 </p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/crypto/cipher_tea.h</code></p>"},{"location":"dictionary/cipher__tea_8h_source/","title":"File cipher_tea.h","text":"<p>File List &gt; crypto &gt; cipher_tea.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QQ_MUSIC_CIPHER_TEA_H\n#define QQ_MUSIC_CIPHER_TEA_H\n\n#include &lt;botan/secmem.h&gt;\n#include &lt;cstdint&gt;\n#include &lt;qqmusic/utils/buffer.h&gt;\n\nnamespace qqmusic::crypto::TeaCipher {\n\nvoid decrypt(qqmusic::utils::buffer&amp; buf, size_t offset, const std::vector&lt;uint8_t&gt;&amp; key);\n\n} // namespace qqmusic::crypto::TeaCipher\n\n#endif // QQ_MUSIC_CIPHER_TEA_H\n</code></pre>"},{"location":"dictionary/key__derive_8h/","title":"File key_derive.h","text":"<p>FileList &gt; crypto &gt; key_derive.h</p> <p>Go to the source code of this file</p> <p>QQ\u97f3\u4e50\u5bc6\u94a5\u89e3\u5bc6\u7b97\u6cd5\u5b9e\u73b0 More...</p> <ul> <li><code>#include &lt;botan/secmem.h&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/buffer.h&gt;</code></li> </ul>"},{"location":"dictionary/key__derive_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace crypto"},{"location":"dictionary/key__derive_8h/#classes","title":"Classes","text":"Type Name class KeyDerive"},{"location":"dictionary/key__derive_8h/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>kingpoem </p> <p>Version:</p> <p>0.1 </p> <p>Date:</p> <p>2025-03-16 \u8be5\u6587\u4ef6\u5b9e\u73b0QQ\u97f3\u4e50\u52a0\u5bc6\u683c\u5f0f\u7684\u5bc6\u94a5\u6d3e\u751f\u4f53\u7cfb\uff0c\u901a\u8fc7\u89e3\u6790Base64\u7f16\u7801\u7684\u8f93\u5165\u5bc6\u94a5\uff0c\u533a\u5206V1/V2\u4e24\u79cd\u52a0\u5bc6\u7248\u672c\uff0c \u4f7f\u7528TEA\u7b97\u6cd5\u8fdb\u884c\u591a\u5c42\u89e3\u5bc6\uff08V2\u9700\u4e24\u6b21TEA+Base64\u5d4c\u5957\u89e3\u5bc6\uff09\uff0c\u6700\u7ec8\u751f\u6210\u7528\u4e8eRC4/mapCipher\u7b49\u97f3\u9891\u89e3\u5bc6\u7b97\u6cd5\u7684\u6709\u6548\u5bc6\u94a5\u3002 \u5185\u90e8\u5305\u542b\u6570\u5b66\u53d8\u6362\u5bc6\u94a5\u751f\u6210\u3001\u5757\u89e3\u5bc6\u65f6\u76d0\u503c\u5904\u7406\uff082\u5b57\u8282\u968f\u673a\u76d0+7\u5b57\u8282\u96f6\u6821\u9a8c\uff09\u3001\u4ee5\u53ca\u8de8\u5e73\u53f0\u517c\u5bb9\u7684\u5b57\u8282\u5e8f\u5904\u7406\u7b49\u5b89\u5168\u673a\u5236\u3002</p> <p>\u4f20\u5165\u7684\u662f\u4eceekey\u63d0\u53d6\u7684Base64\u7f16\u7801\u7684\u5bc6\u94a5\u5b57\u7b26\u4e32 \u8f93\u51fa\u7684\u5bc6\u94a5\u76f4\u63a5\u7528\u4e8e\u521d\u59cb\u5316\u97f3\u9891\u89e3\u7801\u5668</p> <p>\u539f\u59cb\u8f93\u5165ekey \u2192 rawKey (base64\u7f16\u7801) \u2193 \u89e3\u7801 \u4e2d\u95f4\u6570\u636e \u2192 rawKeyDec (\u53ef\u80fd\u542bV2\u5934) \u2193 \u53bb\u5934\u5904\u7406\uff08\u5982\u679c\u662fV2\uff09 \u6838\u5fc3\u5bc6\u6587 \u2192 raw (V2\u89e3\u5bc6\u8f93\u5165) \u2193 \u53cc\u91cdTEA\u89e3\u5bc6 \u6700\u7ec8\u6570\u636e \u2192 \u518d\u6b21base64\u89e3\u7801 \u2192 \u6700\u7ec8\u5bc6\u94a5 </p> <p>Copyright:</p> <p>Copyright (c) 2025 </p> <p>See also: https://git.unlock-music.dev/um/cli/src/branch/main/algo/qmc/key_derive.go <pre><code>std::vector&lt;uint8_t&gt; encrypted_key = {...}; // \u539f\u59cb\u52a0\u5bc6\u5bc6\u94a5\nqqmusic::crypto::Decoder Decoder(ekey); // \u7528ekey\u521d\u59cb\u5316\u89e3\u7801\u5668\uff0cekey\u5b58\u53d6\u4e3a\u89e3\u7801\u5668\u7684\u516c\u6709\u53d8\u91cf\nauto key = qqmusic::crypto::KeyDrive::derive(Decoder.ekey);\n</code></pre></p> <p>Note:</p> <p>\u8be5\u63a5\u53e3\u672a\u6d4b\u8bd5\uff0c\u6682\u4e0d\u53ef\u7528 </p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/crypto/key_derive.h</code></p>"},{"location":"dictionary/key__derive_8h_source/","title":"File key_derive.h","text":"<p>File List &gt; crypto &gt; key_derive.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QQMUSIC_CRYPTO_KEY_DERIVE_H\n#define QQMUSIC_CRYPTO_KEY_DERIVE_H\n\n#include &lt;botan/secmem.h&gt;\n#include &lt;cstdint&gt;\n#include &lt;qqmusic/result.h&gt;\n#include &lt;qqmusic/utils/buffer.h&gt;\n\nnamespace qqmusic::crypto {\n\nclass KeyDerive {\npublic:\n    static qqmusic::utils::buffer derive(qqmusic::utils::buffer&amp;&amp; raw_key);\n\nprivate:\n    static qqmusic::utils::buffer derive_V1(qqmusic::utils::buffer&amp;&amp; raw_key_dec);\n\n    static qqmusic::utils::buffer derive_V2(qqmusic::utils::buffer raw);\n\n    static qqmusic::utils::buffer decrypt_tencent_tea(qqmusic::utils::buffer&amp;&amp; in_buf,\n                                                      const std::vector&lt;uint8_t&gt;&amp; key);\n\n    inline static std::vector&lt;uint8_t&gt; makeSimpleKey(uint8_t salt, size_t len) {\n        std::vector&lt;uint8_t&gt; key(len);\n        std::ranges::generate(key, [=, i = 0]() mutable {\n            const double tmp = std::tan(salt + i++ * 0.1);\n            return static_cast&lt;uint8_t&gt;(std::abs(tmp) * 100.0);\n        });\n        return key;\n    }\n\n    inline static const std::vector&lt;uint8_t&gt; DeriveV2Key1 = {{0x33,\n                                                              0x38,\n                                                              0x36,\n                                                              0x5A,\n                                                              0x4A,\n                                                              0x59,\n                                                              0x21,\n                                                              0x40,\n                                                              0x23,\n                                                              0x2A,\n                                                              0x24,\n                                                              0x25,\n                                                              0x5E,\n                                                              0x26,\n                                                              0x29,\n                                                              0x28}};\n\n    inline static const std::vector&lt;uint8_t&gt; DeriveV2Key2 = {{0x2A,\n                                                              0x2A,\n                                                              0x23,\n                                                              0x21,\n                                                              0x28,\n                                                              0x23,\n                                                              0x24,\n                                                              0x25,\n                                                              0x26,\n                                                              0x5E,\n                                                              0x61,\n                                                              0x31,\n                                                              0x63,\n                                                              0x5A,\n                                                              0x2C,\n                                                              0x54}};\n};\n\n} // namespace qqmusic::crypto\n\n#endif // !QQMUSIC_CRYPTO_KEY_DERIVE_H\n</code></pre>"},{"location":"dictionary/qmc_8h/","title":"File qmc.h","text":"<p>FileList &gt; crypto &gt; qmc.h</p> <p>Go to the source code of this file</p> <p>QQ\u97f3\u4e50\u52a0\u5bc6\u6587\u4ef6\u89e3\u7801\u5668\u6838\u5fc3\u6a21\u5757 More...</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;qqmusic/crypto/cipher_map.h&gt;</code></li> <li><code>#include &lt;qqmusic/crypto/cipher_rc4.h&gt;</code></li> <li><code>#include &lt;qqmusic/crypto/cipher_tea.h&gt;</code></li> <li><code>#include &lt;qqmusic/crypto/key_derive.h&gt;</code></li> <li><code>#include &lt;qqmusic/details/result.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/buffer.h&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"dictionary/qmc_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace crypto"},{"location":"dictionary/qmc_8h/#classes","title":"Classes","text":"Type Name class Decoder"},{"location":"dictionary/qmc_8h/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>kingpoem </p> <p>Version:</p> <p>0.1 </p> <p>Date:</p> <p>2025-03-26 \u5c06API\u8bf7\u6c42\u5f97\u5230\u7684ekey\u5b58\u53d6\u5230\u89e3\u7801\u5668\u7684ekey\u4e2d\uff0c\u6839\u636e\u957f\u5ea6\u9009\u62e9\u89e3\u5bc6\u7b97\u6cd5\uff08&gt;300\u5b57\u8282\u4e3aRC4,\u5176\u4ed6\u4e3aMapCipher\uff09 \u5c06\u89e3\u5bc6\u540e\u7684\u5bc6\u94a5\u5b58\u53d6\u5230key\u4e2d\uff0c\u5b8c\u6210\u89e3\u5bc6\u8fc7\u7a0b \u9700\u8981\u89e3\u5bc6\u7684\u6570\u636e\u5b58\u53d6\u5230buf_in\u4e2d\uff0c\u89e3\u5bc6\u5b8c\u6210\u7684\u6570\u636e\u5b58\u53d6\u5230buf_out\u4e2d </p> <p>Copyright:</p> <p>Copyright (c) 2025 </p> <p>See also: https://git.unlock-music.dev/um/cli/src/branch/main/algo/qmc/qmc.go <pre><code>SongInfo song = ...;\nif (song.ekey.has_value()) {\n     qqmusic::crypto::Decoder decoder(*song.ekey);\n     if (read2buf(buf)) {\n         if (decoder.decrypt()) {\n             std::cout &lt;&lt; \"decrypt successful\" &lt;&lt; std::endl;\n         }\n     }\n} else {\n     // throw error\n}\n// then can use `buf_out`\n</code></pre></p> <p>Note:</p> <p>\u8be5\u63a5\u53e3\u672a\u6d4b\u8bd5\uff0c\u6682\u4e0d\u53ef\u7528 </p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/crypto/qmc.h</code></p>"},{"location":"dictionary/qmc_8h_source/","title":"File qmc.h","text":"<p>File List &gt; crypto &gt; qmc.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QQMUSIC_CRYPTO_QMC_H\n#define QQMUSIC_CRYPTO_QMC_H\n\n#include &lt;cstdint&gt;\n#include &lt;memory&gt;\n#include &lt;qqmusic/crypto/cipher_map.h&gt;\n#include &lt;qqmusic/crypto/cipher_rc4.h&gt;\n#include &lt;qqmusic/crypto/cipher_tea.h&gt;\n#include &lt;qqmusic/crypto/key_derive.h&gt;\n#include &lt;qqmusic/details/result.h&gt;\n#include &lt;qqmusic/utils/buffer.h&gt;\n#include &lt;vector&gt;\n\nnamespace qqmusic::crypto {\n\nclass Decoder {\npublic:\n    explicit Decoder(std::string&amp;&amp; ekey);\n\n    bool decrypt();\n\n    bool read2buf(qqmusic::utils::buffer&amp;&amp; buf);\n\nprivate:\n    qqmusic::utils::buffer ekey;                     \n    std::vector&lt;uint8_t&gt; key;                        \n    qqmusic::utils::buffer buf_in{1024};             \n    qqmusic::utils::buffer buf_out{1024};            \n    std::unique_ptr&lt;qqmusic::crypto::Cipher&gt; cipher; \n};\n} // namespace qqmusic::crypto\n\n#endif // !QQMUSIC_CRYPTO_QMC_H\n</code></pre>"},{"location":"dictionary/dir_6e6556f41d7f85330fbda245682a6a39/","title":"Dir details","text":"<p>FileList &gt; details</p>"},{"location":"dictionary/dir_6e6556f41d7f85330fbda245682a6a39/#files","title":"Files","text":"Type Name file api.h Api\u7c7b, \u7b80\u5316\u8bf7\u6c42\u548c\u8fd4\u56de\u62a5\u6587\u89e3\u6790\u8fc7\u7a0b file context.h Api\u4e0a\u4e0b\u6587\u5b9a\u4e49 file result.h file tripledes.h <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/</code></p>"},{"location":"dictionary/api_8h/","title":"File api.h","text":"<p>FileList &gt; details &gt; api.h</p> <p>Go to the source code of this file</p> <p>Api\u7c7b, \u7b80\u5316\u8bf7\u6c42\u548c\u8fd4\u56de\u62a5\u6587\u89e3\u6790\u8fc7\u7a0b More...</p> <ul> <li><code>#include &lt;boost/beast/http.hpp&gt;</code></li> <li><code>#include &lt;boost/beast/http/message.hpp&gt;</code></li> <li><code>#include &lt;boost/url.hpp&gt;</code></li> <li><code>#include &lt;boost/url/param.hpp&gt;</code></li> <li><code>#include &lt;nlohmann/json.hpp&gt;</code></li> <li><code>#include &lt;qqmusic/details/context.h&gt;</code></li> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/buffer.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/credential.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/session.h&gt;</code></li> </ul>"},{"location":"dictionary/api_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace details"},{"location":"dictionary/api_8h/#classes","title":"Classes","text":"Type Name class Api Api\u7c7b, \u7b80\u5316\u8bf7\u6c42\u62a5\u6587\u7ec4\u88c5\u548c\u8fd4\u56de\u62a5\u6587\u89e3\u6790\u8fc7\u7a0b struct RequestParam \u5305\u88c5\u8bf7\u6c42\u6240\u9700\u7684\u53c2\u6570"},{"location":"dictionary/api_8h/#detailed-description","title":"Detailed Description","text":"<p>---------------------------------qqmusic/details/api.h-------------------------------------</p> <p>Date:</p> <p>2025-3-21</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/api.h</code></p>"},{"location":"dictionary/api_8h_source/","title":"File api.h","text":"<p>File List &gt; details &gt; api.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QQMUSIC_DETIALS_API_H\n#define QQMUSIC_DETIALS_API_H\n\n#include &lt;boost/beast/http.hpp&gt;\n#include &lt;boost/beast/http/message.hpp&gt;\n#include &lt;boost/url.hpp&gt;\n#include &lt;boost/url/param.hpp&gt;\n#include &lt;nlohmann/json.hpp&gt;\n#include &lt;qqmusic/details/context.h&gt;\n#include &lt;qqmusic/result.h&gt;\n#include &lt;qqmusic/utils/buffer.h&gt;\n#include &lt;qqmusic/utils/credential.h&gt;\n#include &lt;qqmusic/utils/session.h&gt;\n\nnamespace qqmusic::details {\n\nnamespace http = boost::beast::http;\nnamespace asio = boost::asio;\n\nstruct RequestParam {\n    boost::url url;\n    http::request&lt;http::string_body&gt; req;\n};\n\nclass Api {\npublic:\n    Api(utils::Session&amp; session,\n        std::string module,\n        std::string method,\n        utils::Credential credential = {},\n        nlohmann::json common = {{}})\n        : session(session)\n        , module(std::move(module))\n        , method(std::move(method)) {\n        if (credential.is_valid()) {\n            this-&gt;credential = credential;\n        } else if (session.get_context_ref().credential.is_valid()) {\n            this-&gt;credential = session.get_context_ref().credential;\n        }\n    };\n\n    qqmusic::Task&lt;qqmusic::Result&lt;RequestParam&gt;&gt; prepare_request(const nlohmann::json&amp; params,\n                                                                 bool verify = false);\n\n    qqmusic::Result&lt;nlohmann::json&gt; parse_response(utils::buffer&amp;&amp; response);\n\nprivate:\n    utils::Session&amp; session;\n    std::string module;\n    std::string method;\n    nlohmann::json common;\n    utils::Credential credential;\n};\n\n} // namespace qqmusic::details\n\n#endif // !QQMUSIC_DETIALS_API_H\n</code></pre>"},{"location":"dictionary/context_8h/","title":"File context.h","text":"<p>FileList &gt; details &gt; context.h</p> <p>Go to the source code of this file</p> <p>Api\u4e0a\u4e0b\u6587\u5b9a\u4e49 More...</p> <ul> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;format&gt;</code></li> <li><code>#include &lt;qqmusic/utils/cookie.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/credential.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/device.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/qimei.h&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> </ul>"},{"location":"dictionary/context_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace details"},{"location":"dictionary/context_8h/#classes","title":"Classes","text":"Type Name struct ApiConfig Api\u76f8\u5173\u5e38\u91cf struct NetworkContext \u6253\u5305\u7684\u4e0a\u4e0b\u6587"},{"location":"dictionary/context_8h/#detailed-description","title":"Detailed Description","text":"<p>-------------------------------qqmusic/details/context.h-----------------------------------</p> <p>Date:</p> <p>2025-3-25</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/context.h</code></p>"},{"location":"dictionary/context_8h_source/","title":"File context.h","text":"<p>File List &gt; details &gt; context.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QQMUSIC_DETAILS_CONTEXT_H\n#define QQMUSIC_DETAILS_CONTEXT_H\n\n#include &lt;chrono&gt;\n#include &lt;format&gt;\n#include &lt;qqmusic/utils/cookie.h&gt;\n#include &lt;qqmusic/utils/credential.h&gt;\n#include &lt;qqmusic/utils/device.h&gt;\n#include &lt;qqmusic/utils/qimei.h&gt;\n#include &lt;stdexcept&gt;\n\nnamespace qqmusic::details {\n\nconst char VERSION[] = \"13.2.5.8\";\n\nconst uint64_t VERSION_CODE = 13020508;\n\nstruct ApiConfig {\n    std::string version = VERSION;\n    uint64_t version_code = VERSION_CODE;\n\n    bool enable_sign = false;\n\n    std::string endpoint = \"https://u.y.qq.com/cgi-bin/musicu.fcg\";\n\n    std::string enc_endpoint = \"https://u.y.qq.com/cgi-bin/musics.fcg\";\n};\n\nstruct NetworkContext {\n    /*Globally shared vars*/\n    qqmusic::utils::CookieJar cookies;\n    qqmusic::utils::Credential credential;\n    ApiConfig api_config;\n    qqmusic::utils::Device device;\n    qqmusic::utils::QimeiResult qimei;\n    bool ignore_ssl_error;\n    std::chrono::seconds timeout;\n\n    /*constructor*/\n    NetworkContext()\n        : ignore_ssl_error(false)\n        , timeout(20) {\n        api_config = ApiConfig();\n        auto device_res = qqmusic::utils::get_device_info();\n        if (device_res.isErr()) {\n            throw std::runtime_error(\n                std::format(\"[NetworkContext::NetworkContext] -- Cannot get device: {}\",\n                            device_res.unwrapErr().what()));\n        }\n        device = device_res.unwrap();\n        auto qimei_res = get_qimei(device, api_config.version);\n        if (qimei_res.isErr()) {\n            throw std::runtime_error(\n                std::format(\"[NetworkContext::NetworkContext] -- Cannot get qimei: {}\",\n                            qimei_res.unwrapErr().what()));\n        }\n        qimei = qimei_res.unwrap();\n        device.qimei = qimei.q36;\n        qqmusic::utils::cache_device(device);\n    }\n};\n\n} // namespace qqmusic::details\n\n#endif // !QQMUSIC_DETAILS_CONTEXT_H\n</code></pre>"},{"location":"dictionary/details_2result_8h/","title":"File details/result.h","text":"<p>FileList &gt; details &gt; result.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> </ul>"},{"location":"dictionary/details_2result_8h/#namespaces","title":"Namespaces","text":"Type Name namespace concepts namespace details namespace And namespace impl namespace Or namespace impl namespace Other namespace impl namespace err namespace impl namespace impl namespace ok namespace impl namespace types"},{"location":"dictionary/details_2result_8h/#classes","title":"Classes","text":"Type Name struct Result &lt;typename T, typename E&gt; struct EqualityComparable &lt;typename T, typename&gt; struct EqualityComparable&lt; T, typename std::enable_if&lt; true, typename details::void_t&lt; decltype(std::declval&lt; T &gt;()==std::declval&lt; T &gt;())&gt;::type &gt;::type &gt; &lt;typename T&gt; struct Then &lt;typename Func&gt; struct Then&lt; Ret(*)(Args...)&gt; &lt;typename Ret, Args&gt; struct Then&lt; Ret(Cls::*)(Args...) const &gt; &lt;typename Ret, typename Cls, Args&gt; struct Then&lt; Ret(Cls::*)(Args...)&gt; &lt;typename Ret, typename Cls, Args&gt; struct Then&lt; Ret(*)(Args...)&gt; &lt;typename Ret, Args&gt; struct Then&lt; Ret(Arg)&gt; &lt;typename Ret, typename Arg&gt; struct Then&lt; Ret(Cls::*)(Args...) const &gt; &lt;typename Ret, typename Cls, Args&gt; struct Then&lt; Ret(Cls::*)(Args...)&gt; &lt;typename Ret, typename Cls, Args&gt; struct Then&lt; Ret(void)&gt; &lt;typename Ret&gt; struct Constructor &lt;typename T, typename E&gt; struct Constructor&lt; void, E &gt; &lt;typename E&gt; struct IsResult &lt;typename R&gt; struct IsResult&lt; Result&lt; T, E &gt; &gt; &lt;typename T, typename E&gt; struct Else &lt;typename Func&gt; struct Else&lt; Ret(*)(Args...)&gt; &lt;typename Ret, Args&gt; struct Else&lt; Ret(Cls::*)(Args...) const &gt; &lt;typename Ret, typename Cls, Args&gt; struct Else&lt; Ret(Cls::*)(Args...)&gt; &lt;typename Ret, typename Cls, Args&gt; struct Else&lt; Result&lt; T, F &gt;(Arg)&gt; &lt;typename T, typename F, typename Arg&gt; struct Else&lt; Result&lt; T, F &gt;(void)&gt; &lt;typename T, typename F&gt; struct Else&lt; Ret(*)(Args...)&gt; &lt;typename Ret, Args&gt; struct Else&lt; Ret(Cls::*)(Args...) const &gt; &lt;typename Ret, typename Cls, Args&gt; struct Else&lt; Ret(Cls::*)(Args...)&gt; &lt;typename Ret, typename Cls, Args&gt; struct Wise &lt;typename Func&gt; struct Wise&lt; Ret(*)(Args...)&gt; &lt;typename Ret, Args&gt; struct Wise&lt; Ret(Cls::*)(Args...) const &gt; &lt;typename Ret, typename Cls, Args&gt; struct Wise&lt; Ret(Cls::*)(Args...)&gt; &lt;typename Ret, typename Cls, Args&gt; struct Wise&lt; Ret(*)(Args...)&gt; &lt;typename Ret, Args&gt; struct Wise&lt; Ret(Arg)&gt; &lt;typename Ret, typename Arg&gt; struct Wise&lt; Ret(Cls::*)(Args...) const &gt; &lt;typename Ret, typename Cls, Args&gt; struct Wise&lt; Ret(Cls::*)(Args...)&gt; &lt;typename Ret, typename Cls, Args&gt; struct ResultErrType &lt;typename R&gt; struct ResultErrType&lt; Result&lt; T, E &gt; &gt; &lt;typename T, typename E&gt; struct ResultOkType &lt;typename R&gt; struct ResultOkType&lt; Result&lt; T, E &gt; &gt; &lt;typename T, typename E&gt; struct Storage &lt;typename T, typename E&gt; struct Storage&lt; void, E &gt; &lt;typename E&gt; struct Map &lt;typename Func&gt; struct Map&lt; Ret(Cls::*)(Arg) const &gt; &lt;typename Ret, typename Cls, typename Arg&gt; struct err_tag struct result_of&lt; Ret(Args...)&gt; &lt;typename Ret, Args&gt; struct result_of&lt; Ret(Cls::*)(Args...)&gt; &lt;typename Ret, typename Cls, Args&gt; struct Map &lt;typename Func&gt; struct Map&lt; Ret(*)(Args...)&gt; &lt;typename Ret, Args&gt; struct Map&lt; Ret(Cls::*)(Args...) const &gt; &lt;typename Ret, typename Cls, Args&gt; struct Map&lt; Ret(Cls::*)(Args...)&gt; &lt;typename Ret, typename Cls, Args&gt; struct Map&lt; std::function&lt; Ret(Args...)&gt; &gt; &lt;typename Ret, Args&gt; struct Map&lt; Result&lt; U, E &gt;(Arg)&gt; &lt;typename U, typename E, typename Arg&gt; struct Map&lt; Result&lt; U, E &gt;(void)&gt; &lt;typename U, typename E&gt; struct Map&lt; Ret(Arg)&gt; &lt;typename Ret, typename Arg&gt; struct Map&lt; Ret(Cls::*)(Arg) const &gt; &lt;typename Ret, typename Cls, typename Arg&gt; struct Map&lt; Ret(Cls::*)(Arg)&gt; &lt;typename Ret, typename Cls, typename Arg&gt; struct Map&lt; Ret(void)&gt; &lt;typename Ret&gt; struct Map&lt; void(Arg)&gt; &lt;typename Arg&gt; struct Map&lt; void(void)&gt; &lt;&gt; struct ok_tag struct result_of &lt;typename Func&gt; struct result_of&lt; Ret(*)(Args...)&gt; &lt;typename Ret, Args&gt; struct result_of&lt; Ret(Cls::*)(Args...) const &gt; &lt;typename Ret, typename Cls, Args&gt; struct void_t &lt;typename...&gt; struct Err &lt;typename E&gt; struct Ok &lt;typename T&gt; struct Ok&lt; void &gt; &lt;&gt;"},{"location":"dictionary/details_2result_8h/#public-functions","title":"Public Functions","text":"Type Name types::Err&lt; CleanE &gt; Err (E &amp;&amp; val)  types::Ok&lt; CleanT &gt; Ok (T &amp;&amp; val)  types::Ok&lt; void &gt; Ok ()  bool operator== (const Result&lt; T, E &gt; &amp; lhs, const Result&lt; T, E &gt; &amp; rhs)  bool operator== (const Result&lt; T, E &gt; &amp; lhs, types::Ok&lt; T &gt; ok)  bool operator== (const Result&lt; void, E &gt; &amp; lhs, types::Ok&lt; void &gt;)  bool operator== (const Result&lt; T, E &gt; &amp; lhs, types::Err&lt; E &gt; err)"},{"location":"dictionary/details_2result_8h/#macros","title":"Macros","text":"Type Name define TRY (...) <code>/* multi line expression */</code>"},{"location":"dictionary/details_2result_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"dictionary/details_2result_8h/#function-err","title":"function Err","text":"<pre><code>template&lt;typename E, typename CleanE&gt;\ntypes::Err &lt; CleanE &gt; Err (\n    E &amp;&amp; val\n) \n</code></pre>"},{"location":"dictionary/details_2result_8h/#function-ok","title":"function Ok","text":"<pre><code>template&lt;typename T, typename CleanT&gt;\ntypes::Ok &lt; CleanT &gt; Ok (\n    T &amp;&amp; val\n) \n</code></pre>"},{"location":"dictionary/details_2result_8h/#function-ok_1","title":"function Ok","text":"<pre><code>inline types::Ok &lt; void &gt; Ok () \n</code></pre>"},{"location":"dictionary/details_2result_8h/#function-operator","title":"function operator==","text":"<pre><code>template&lt;typename T, typename E&gt;\nbool operator== (\n    const Result &lt; T, E &gt; &amp; lhs,\n    const Result &lt; T, E &gt; &amp; rhs\n) \n</code></pre>"},{"location":"dictionary/details_2result_8h/#function-operator_1","title":"function operator==","text":"<pre><code>template&lt;typename T, typename E&gt;\nbool operator== (\n    const Result &lt; T, E &gt; &amp; lhs,\n    types::Ok &lt; T &gt; ok\n) \n</code></pre>"},{"location":"dictionary/details_2result_8h/#function-operator_2","title":"function operator==","text":"<pre><code>template&lt;typename E&gt;\nbool operator== (\n    const Result &lt; void, E &gt; &amp; lhs,\n    types::Ok &lt; void &gt;\n) \n</code></pre>"},{"location":"dictionary/details_2result_8h/#function-operator_3","title":"function operator==","text":"<pre><code>template&lt;typename T, typename E&gt;\nbool operator== (\n    const Result &lt; T, E &gt; &amp; lhs,\n    types::Err &lt; E &gt; err\n) \n</code></pre>"},{"location":"dictionary/details_2result_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"dictionary/details_2result_8h/#define-try","title":"define TRY","text":"<pre><code>#define TRY (\n    ...\n) `/* multi line expression */`\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/result.h</code></p>"},{"location":"dictionary/details_2result_8h_source/","title":"File details/result.h","text":"<p>File List &gt; details &gt; result.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n   Mathieu Stefani, 03 mai 2016\n\n   This header provides a Result type that can be used to replace exceptions in code\n   that has to handle error.\n\n   Result&lt;T, E&gt; can be used to return and propagate an error to the caller. Result&lt;T, E&gt; is an\n   algebraic data type that can either Ok(T) to represent success or Err(E) to represent an error.\n*/\n\n#pragma once\n\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nnamespace types {\ntemplate&lt;typename T&gt;\nstruct Ok {\n    Ok(const T&amp; val)\n        : val(val) {}\n\n    Ok(T&amp;&amp; val)\n        : val(std::move(val)) {}\n\n    T val;\n};\n\ntemplate&lt;&gt;\nstruct Ok&lt;void&gt; {};\n\ntemplate&lt;typename E&gt;\nstruct Err {\n    Err(const E&amp; val)\n        : val(val) {}\n\n    Err(E&amp;&amp; val)\n        : val(std::move(val)) {}\n\n    E val;\n};\n} // namespace types\n\ntemplate&lt;typename T, typename CleanT = typename std::decay&lt;T&gt;::type&gt;\ntypes::Ok&lt;CleanT&gt; Ok(T&amp;&amp; val) {\n    return types::Ok&lt;CleanT&gt;(std::forward&lt;T&gt;(val));\n}\n\ninline types::Ok&lt;void&gt; Ok() {\n    return types::Ok&lt;void&gt;();\n}\n\ntemplate&lt;typename E, typename CleanE = typename std::decay&lt;E&gt;::type&gt;\ntypes::Err&lt;CleanE&gt; Err(E&amp;&amp; val) {\n    return types::Err&lt;CleanE&gt;(std::forward&lt;E&gt;(val));\n}\n\ntemplate&lt;typename T, typename E&gt;\nstruct Result;\n\nnamespace details {\n\ntemplate&lt;typename...&gt;\nstruct void_t {\n    typedef void type;\n};\n\nnamespace impl {\ntemplate&lt;typename Func&gt;\nstruct result_of;\n\ntemplate&lt;typename Ret, typename Cls, typename... Args&gt;\nstruct result_of&lt;Ret (Cls::*)(Args...)&gt; : public result_of&lt;Ret(Args...)&gt; {};\n\ntemplate&lt;typename Ret, typename... Args&gt;\nstruct result_of&lt;Ret(Args...)&gt; {\n    typedef Ret type;\n};\n} // namespace impl\n\ntemplate&lt;typename Func&gt;\nstruct result_of : public impl::result_of&lt;decltype(&amp;Func::operator())&gt; {};\n\ntemplate&lt;typename Ret, typename Cls, typename... Args&gt;\nstruct result_of&lt;Ret (Cls::*)(Args...) const&gt; {\n    typedef Ret type;\n};\n\ntemplate&lt;typename Ret, typename... Args&gt;\nstruct result_of&lt;Ret (*)(Args...)&gt; {\n    typedef Ret type;\n};\n\ntemplate&lt;typename R&gt;\nstruct ResultOkType {\n    typedef typename std::decay&lt;R&gt;::type type;\n};\n\ntemplate&lt;typename T, typename E&gt;\nstruct ResultOkType&lt;Result&lt;T, E&gt;&gt; {\n    typedef T type;\n};\n\ntemplate&lt;typename R&gt;\nstruct ResultErrType {\n    typedef R type;\n};\n\ntemplate&lt;typename T, typename E&gt;\nstruct ResultErrType&lt;Result&lt;T, E&gt;&gt; {\n    typedef typename std::remove_reference&lt;E&gt;::type type;\n};\n\ntemplate&lt;typename R&gt;\nstruct IsResult : public std::false_type {};\n\ntemplate&lt;typename T, typename E&gt;\nstruct IsResult&lt;Result&lt;T, E&gt;&gt; : public std::true_type {};\n\nnamespace ok {\n\nnamespace impl {\n\ntemplate&lt;typename T&gt;\nstruct Map;\n\ntemplate&lt;typename Ret, typename Cls, typename Arg&gt;\nstruct Map&lt;Ret (Cls::*)(Arg) const&gt; : public Map&lt;Ret(Arg)&gt; {};\n\ntemplate&lt;typename Ret, typename Cls, typename Arg&gt;\nstruct Map&lt;Ret (Cls::*)(Arg)&gt; : public Map&lt;Ret(Arg)&gt; {};\n\n// General implementation\ntemplate&lt;typename Ret, typename Arg&gt;\nstruct Map&lt;Ret(Arg)&gt; {\n    static_assert(!IsResult&lt;Ret&gt;::value,\n                  \"Can not map a callback returning a Result, use andThen instead\");\n\n    template&lt;typename T, typename E, typename Func&gt;\n    static Result&lt;Ret, E&gt; map(const Result&lt;T, E&gt;&amp; result, Func func) {\n        static_assert(std::is_same&lt;T, Arg&gt;::value || std::is_convertible&lt;T, Arg&gt;::value,\n                      \"Incompatible types detected\");\n\n        if (result.isOk()) {\n            auto res = func(result.storage().template get&lt;T&gt;());\n            return types::Ok&lt;Ret&gt;(std::move(res));\n        }\n\n        return types::Err&lt;E&gt;(result.storage().template get&lt;E&gt;());\n    }\n};\n\n// Specialization for callback returning void\ntemplate&lt;typename Arg&gt;\nstruct Map&lt;void(Arg)&gt; {\n    template&lt;typename T, typename E, typename Func&gt;\n    static Result&lt;void, E&gt; map(const Result&lt;T, E&gt;&amp; result, Func func) {\n        if (result.isOk()) {\n            func(result.storage().template get&lt;T&gt;());\n            return types::Ok&lt;void&gt;();\n        }\n\n        return types::Err&lt;E&gt;(result.storage().template get&lt;E&gt;());\n    }\n};\n\n// Specialization for a void Result\ntemplate&lt;typename Ret&gt;\nstruct Map&lt;Ret(void)&gt; {\n    template&lt;typename T, typename E, typename Func&gt;\n    static Result&lt;Ret, E&gt; map(const Result&lt;T, E&gt;&amp; result, Func func) {\n        static_assert(std::is_same&lt;T, void&gt;::value,\n                      \"Can not map a void callback on a non-void Result\");\n\n        if (result.isOk()) {\n            auto ret = func();\n            return types::Ok&lt;Ret&gt;(std::move(ret));\n        }\n\n        return types::Err&lt;E&gt;(result.storage().template get&lt;E&gt;());\n    }\n};\n\n// Specialization for callback returning void on a void Result\ntemplate&lt;&gt;\nstruct Map&lt;void(void)&gt; {\n    template&lt;typename T, typename E, typename Func&gt;\n    static Result&lt;void, E&gt; map(const Result&lt;T, E&gt;&amp; result, Func func) {\n        static_assert(std::is_same&lt;T, void&gt;::value,\n                      \"Can not map a void callback on a non-void Result\");\n\n        if (result.isOk()) {\n            func();\n            return types::Ok&lt;void&gt;();\n        }\n\n        return types::Err&lt;E&gt;(result.storage().template get&lt;E&gt;());\n    }\n};\n\n// General specialization for a callback returning a Result\ntemplate&lt;typename U, typename E, typename Arg&gt;\nstruct Map&lt;Result&lt;U, E&gt;(Arg)&gt; {\n    template&lt;typename T, typename Func&gt;\n    static Result&lt;U, E&gt; map(const Result&lt;T, E&gt;&amp; result, Func func) {\n        static_assert(std::is_same&lt;T, Arg&gt;::value || std::is_convertible&lt;T, Arg&gt;::value,\n                      \"Incompatible types detected\");\n\n        if (result.isOk()) {\n            auto res = func(result.storage().template get&lt;T&gt;());\n            return res;\n        }\n\n        return types::Err&lt;E&gt;(result.storage().template get&lt;E&gt;());\n    }\n};\n\n// Specialization for a void callback returning a Result\ntemplate&lt;typename U, typename E&gt;\nstruct Map&lt;Result&lt;U, E&gt;(void)&gt; {\n    template&lt;typename T, typename Func&gt;\n    static Result&lt;U, E&gt; map(const Result&lt;T, E&gt;&amp; result, Func func) {\n        static_assert(std::is_same&lt;T, void&gt;::value,\n                      \"Can not call a void-callback on a non-void Result\");\n\n        if (result.isOk()) {\n            auto res = func();\n            return res;\n        }\n\n        return types::Err&lt;E&gt;(result.storage().template get&lt;E&gt;());\n    }\n};\n\n} // namespace impl\n\ntemplate&lt;typename Func&gt;\nstruct Map : public impl::Map&lt;decltype(&amp;Func::operator())&gt; {};\n\ntemplate&lt;typename Ret, typename... Args&gt;\nstruct Map&lt;Ret (*)(Args...)&gt; : public impl::Map&lt;Ret(Args...)&gt; {};\n\ntemplate&lt;typename Ret, typename Cls, typename... Args&gt;\nstruct Map&lt;Ret (Cls::*)(Args...)&gt; : public impl::Map&lt;Ret(Args...)&gt; {};\n\ntemplate&lt;typename Ret, typename Cls, typename... Args&gt;\nstruct Map&lt;Ret (Cls::*)(Args...) const&gt; : public impl::Map&lt;Ret(Args...)&gt; {};\n\ntemplate&lt;typename Ret, typename... Args&gt;\nstruct Map&lt;std::function&lt;Ret(Args...)&gt;&gt; : public impl::Map&lt;Ret(Args...)&gt; {};\n\n} // namespace ok\n\nnamespace err {\n\nnamespace impl {\n\ntemplate&lt;typename T&gt;\nstruct Map;\n\ntemplate&lt;typename Ret, typename Cls, typename Arg&gt;\nstruct Map&lt;Ret (Cls::*)(Arg) const&gt; {\n    static_assert(!IsResult&lt;Ret&gt;::value,\n                  \"Can not map a callback returning a Result, use orElse instead\");\n\n    template&lt;typename T, typename E, typename Func&gt;\n    static Result&lt;T, Ret&gt; map(const Result&lt;T, E&gt;&amp; result, Func func) {\n        if (result.isErr()) {\n            auto res = func(result.storage().template get&lt;E&gt;());\n            return types::Err&lt;Ret&gt;(res);\n        }\n\n        return types::Ok&lt;T&gt;(result.storage().template get&lt;T&gt;());\n    }\n\n    template&lt;typename E, typename Func&gt;\n    static Result&lt;void, Ret&gt; map(const Result&lt;void, E&gt;&amp; result, Func func) {\n        if (result.isErr()) {\n            auto res = func(result.storage().template get&lt;E&gt;());\n            return types::Err&lt;Ret&gt;(res);\n        }\n\n        return types::Ok&lt;void&gt;();\n    }\n};\n\n} // namespace impl\n\ntemplate&lt;typename Func&gt;\nstruct Map : public impl::Map&lt;decltype(&amp;Func::operator())&gt; {};\n\n} // namespace err\n\nnamespace And {\n\nnamespace impl {\n\ntemplate&lt;typename Func&gt;\nstruct Then;\n\ntemplate&lt;typename Ret, typename... Args&gt;\nstruct Then&lt;Ret (*)(Args...)&gt; : public Then&lt;Ret(Args...)&gt; {};\n\ntemplate&lt;typename Ret, typename Cls, typename... Args&gt;\nstruct Then&lt;Ret (Cls::*)(Args...)&gt; : public Then&lt;Ret(Args...)&gt; {};\n\ntemplate&lt;typename Ret, typename Cls, typename... Args&gt;\nstruct Then&lt;Ret (Cls::*)(Args...) const&gt; : public Then&lt;Ret(Args...)&gt; {};\n\ntemplate&lt;typename Ret, typename Arg&gt;\nstruct Then&lt;Ret(Arg)&gt; {\n    static_assert(std::is_same&lt;Ret, void&gt;::value,\n                  \"then() should not return anything, use map() instead\");\n\n    template&lt;typename T, typename E, typename Func&gt;\n    static Result&lt;T, E&gt; then(const Result&lt;T, E&gt;&amp; result, Func func) {\n        if (result.isOk()) {\n            func(result.storage().template get&lt;T&gt;());\n        }\n        return result;\n    }\n};\n\ntemplate&lt;typename Ret&gt;\nstruct Then&lt;Ret(void)&gt; {\n    static_assert(std::is_same&lt;Ret, void&gt;::value,\n                  \"then() should not return anything, use map() instead\");\n\n    template&lt;typename T, typename E, typename Func&gt;\n    static Result&lt;T, E&gt; then(const Result&lt;T, E&gt;&amp; result, Func func) {\n        static_assert(std::is_same&lt;T, void&gt;::value,\n                      \"Can not call a void-callback on a non-void Result\");\n\n        if (result.isOk()) {\n            func();\n        }\n\n        return result;\n    }\n};\n\n} // namespace impl\n\ntemplate&lt;typename Func&gt;\nstruct Then : public impl::Then&lt;decltype(&amp;Func::operator())&gt; {};\n\ntemplate&lt;typename Ret, typename... Args&gt;\nstruct Then&lt;Ret (*)(Args...)&gt; : public impl::Then&lt;Ret(Args...)&gt; {};\n\ntemplate&lt;typename Ret, typename Cls, typename... Args&gt;\nstruct Then&lt;Ret (Cls::*)(Args...)&gt; : public impl::Then&lt;Ret(Args...)&gt; {};\n\ntemplate&lt;typename Ret, typename Cls, typename... Args&gt;\nstruct Then&lt;Ret (Cls::*)(Args...) const&gt; : public impl::Then&lt;Ret(Args...)&gt; {};\n\n} // namespace And\n\nnamespace Or {\n\nnamespace impl {\n\ntemplate&lt;typename Func&gt;\nstruct Else;\n\ntemplate&lt;typename Ret, typename... Args&gt;\nstruct Else&lt;Ret (*)(Args...)&gt; : public Else&lt;Ret(Args...)&gt; {};\n\ntemplate&lt;typename Ret, typename Cls, typename... Args&gt;\nstruct Else&lt;Ret (Cls::*)(Args...)&gt; : public Else&lt;Ret(Args...)&gt; {};\n\ntemplate&lt;typename Ret, typename Cls, typename... Args&gt;\nstruct Else&lt;Ret (Cls::*)(Args...) const&gt; : public Else&lt;Ret(Args...)&gt; {};\n\ntemplate&lt;typename T, typename F, typename Arg&gt;\nstruct Else&lt;Result&lt;T, F&gt;(Arg)&gt; {\n    template&lt;typename E, typename Func&gt;\n    static Result&lt;T, F&gt; orElse(const Result&lt;T, E&gt;&amp; result, Func func) {\n        static_assert(std::is_same&lt;E, Arg&gt;::value || std::is_convertible&lt;E, Arg&gt;::value,\n                      \"Incompatible types detected\");\n\n        if (result.isErr()) {\n            auto res = func(result.storage().template get&lt;E&gt;());\n            return res;\n        }\n\n        return types::Ok&lt;T&gt;(result.storage().template get&lt;T&gt;());\n    }\n\n    template&lt;typename E, typename Func&gt;\n    static Result&lt;void, F&gt; orElse(const Result&lt;void, E&gt;&amp; result, Func func) {\n        if (result.isErr()) {\n            auto res = func(result.storage().template get&lt;E&gt;());\n            return res;\n        }\n\n        return types::Ok&lt;void&gt;();\n    }\n};\n\ntemplate&lt;typename T, typename F&gt;\nstruct Else&lt;Result&lt;T, F&gt;(void)&gt; {\n    template&lt;typename E, typename Func&gt;\n    static Result&lt;T, F&gt; orElse(const Result&lt;T, E&gt;&amp; result, Func func) {\n        static_assert(std::is_same&lt;T, void&gt;::value,\n                      \"Can not call a void-callback on a non-void Result\");\n\n        if (result.isErr()) {\n            auto res = func();\n            return res;\n        }\n\n        return types::Ok&lt;T&gt;(result.storage().template get&lt;T&gt;());\n    }\n\n    template&lt;typename E, typename Func&gt;\n    static Result&lt;void, F&gt; orElse(const Result&lt;void, E&gt;&amp; result, Func func) {\n        if (result.isErr()) {\n            auto res = func();\n            return res;\n        }\n\n        return types::Ok&lt;void&gt;();\n    }\n};\n\n} // namespace impl\n\ntemplate&lt;typename Func&gt;\nstruct Else : public impl::Else&lt;decltype(&amp;Func::operator())&gt; {};\n\ntemplate&lt;typename Ret, typename... Args&gt;\nstruct Else&lt;Ret (*)(Args...)&gt; : public impl::Else&lt;Ret(Args...)&gt; {};\n\ntemplate&lt;typename Ret, typename Cls, typename... Args&gt;\nstruct Else&lt;Ret (Cls::*)(Args...)&gt; : public impl::Else&lt;Ret(Args...)&gt; {};\n\ntemplate&lt;typename Ret, typename Cls, typename... Args&gt;\nstruct Else&lt;Ret (Cls::*)(Args...) const&gt; : public impl::Else&lt;Ret(Args...)&gt; {};\n\n} // namespace Or\n\nnamespace Other {\n\nnamespace impl {\n\ntemplate&lt;typename Func&gt;\nstruct Wise;\n\ntemplate&lt;typename Ret, typename... Args&gt;\nstruct Wise&lt;Ret (*)(Args...)&gt; : public Wise&lt;Ret(Args...)&gt; {};\n\ntemplate&lt;typename Ret, typename Cls, typename... Args&gt;\nstruct Wise&lt;Ret (Cls::*)(Args...)&gt; : public Wise&lt;Ret(Args...)&gt; {};\n\ntemplate&lt;typename Ret, typename Cls, typename... Args&gt;\nstruct Wise&lt;Ret (Cls::*)(Args...) const&gt; : public Wise&lt;Ret(Args...)&gt; {};\n\ntemplate&lt;typename Ret, typename Arg&gt;\nstruct Wise&lt;Ret(Arg)&gt; {\n    template&lt;typename T, typename E, typename Func&gt;\n    static Result&lt;T, E&gt; otherwise(const Result&lt;T, E&gt;&amp; result, Func func) {\n        static_assert(std::is_same&lt;E, Arg&gt;::value || std::is_convertible&lt;E, Arg&gt;::value,\n                      \"Incompatible types detected\");\n\n        static_assert(std::is_same&lt;Ret, void&gt;::value,\n                      \"callback should not return anything, use mapError() for that\");\n\n        if (result.isErr()) {\n            func(result.storage().template get&lt;E&gt;());\n        }\n        return result;\n    }\n};\n\n} // namespace impl\n\ntemplate&lt;typename Func&gt;\nstruct Wise : public impl::Wise&lt;decltype(&amp;Func::operator())&gt; {};\n\ntemplate&lt;typename Ret, typename... Args&gt;\nstruct Wise&lt;Ret (*)(Args...)&gt; : public impl::Wise&lt;Ret(Args...)&gt; {};\n\ntemplate&lt;typename Ret, typename Cls, typename... Args&gt;\nstruct Wise&lt;Ret (Cls::*)(Args...)&gt; : public impl::Wise&lt;Ret(Args...)&gt; {};\n\ntemplate&lt;typename Ret, typename Cls, typename... Args&gt;\nstruct Wise&lt;Ret (Cls::*)(Args...) const&gt; : public impl::Wise&lt;Ret(Args...)&gt; {};\n\n} // namespace Other\n\ntemplate&lt;typename T,\n         typename E,\n         typename Func,\n         typename Ret\n         = Result&lt;typename details::ResultOkType&lt;typename details::result_of&lt;Func&gt;::type&gt;::type, E&gt;&gt;\nRet map(const Result&lt;T, E&gt;&amp; result, Func func) {\n    return ok::Map&lt;Func&gt;::map(result, func);\n}\n\ntemplate&lt;typename T,\n         typename E,\n         typename Func,\n         typename Ret\n         = Result&lt;T, typename details::ResultErrType&lt;typename details::result_of&lt;Func&gt;::type&gt;::type&gt;&gt;\nRet mapError(const Result&lt;T, E&gt;&amp; result, Func func) {\n    return err::Map&lt;Func&gt;::map(result, func);\n}\n\ntemplate&lt;typename T, typename E, typename Func&gt;\nResult&lt;T, E&gt; then(const Result&lt;T, E&gt;&amp; result, Func func) {\n    return And::Then&lt;Func&gt;::then(result, func);\n}\n\ntemplate&lt;typename T, typename E, typename Func&gt;\nResult&lt;T, E&gt; otherwise(const Result&lt;T, E&gt;&amp; result, Func func) {\n    return Other::Wise&lt;Func&gt;::otherwise(result, func);\n}\n\ntemplate&lt;typename T,\n         typename E,\n         typename Func,\n         typename Ret\n         = Result&lt;T, typename details::ResultErrType&lt;typename details::result_of&lt;Func&gt;::type&gt;::type&gt;&gt;\nRet orElse(const Result&lt;T, E&gt;&amp; result, Func func) {\n    return Or::Else&lt;Func&gt;::orElse(result, func);\n}\n\nstruct ok_tag {};\n\nstruct err_tag {};\n\ntemplate&lt;typename T, typename E&gt;\nstruct Storage {\n    constexpr static size_t Size = sizeof(T) &gt; sizeof(E) ? sizeof(T) : sizeof(E);\n    constexpr static size_t Align = sizeof(T) &gt; sizeof(E) ? alignof(T) : alignof(E);\n\n    typedef typename std::aligned_storage&lt;Size, Align&gt;::type type;\n\n    Storage()\n        : initialized_(false) {}\n\n    void construct(types::Ok&lt;T&gt; ok) {\n        new (&amp;storage_) T(ok.val);\n        initialized_ = true;\n    }\n\n    void construct(types::Err&lt;E&gt; err) {\n        new (&amp;storage_) E(err.val);\n        initialized_ = true;\n    }\n\n    template&lt;typename U&gt;\n    void rawConstruct(U&amp;&amp; val) {\n        typedef typename std::decay&lt;U&gt;::type CleanU;\n\n        new (&amp;storage_) CleanU(std::forward&lt;U&gt;(val));\n        initialized_ = true;\n    }\n\n    template&lt;typename U&gt;\n    const U&amp; get() const {\n        return *reinterpret_cast&lt;const U*&gt;(&amp;storage_);\n    }\n\n    template&lt;typename U&gt;\n    U&amp; get() {\n        return *reinterpret_cast&lt;U*&gt;(&amp;storage_);\n    }\n\n    void destroy(ok_tag) {\n        if (initialized_) {\n            get&lt;T&gt;().~T();\n            initialized_ = false;\n        }\n    }\n\n    void destroy(err_tag) {\n        if (initialized_) {\n            get&lt;E&gt;().~E();\n            initialized_ = false;\n        }\n    }\n\n    type storage_;\n    bool initialized_;\n};\n\ntemplate&lt;typename E&gt;\nstruct Storage&lt;void, E&gt; {\n    typedef typename std::aligned_storage&lt;sizeof(E), alignof(E)&gt;::type type;\n\n    void construct(types::Ok&lt;void&gt;) { initialized_ = true; }\n\n    void construct(types::Err&lt;E&gt; err) {\n        new (&amp;storage_) E(err.val);\n        initialized_ = true;\n    }\n\n    template&lt;typename U&gt;\n    void rawConstruct(U&amp;&amp; val) {\n        typedef typename std::decay&lt;U&gt;::type CleanU;\n\n        new (&amp;storage_) CleanU(std::forward&lt;U&gt;(val));\n        initialized_ = true;\n    }\n\n    void destroy(ok_tag) { initialized_ = false; }\n\n    void destroy(err_tag) {\n        if (initialized_) {\n            get&lt;E&gt;().~E();\n            initialized_ = false;\n        }\n    }\n\n    template&lt;typename U&gt;\n    const U&amp; get() const {\n        return *reinterpret_cast&lt;const U*&gt;(&amp;storage_);\n    }\n\n    template&lt;typename U&gt;\n    U&amp; get() {\n        return *reinterpret_cast&lt;U*&gt;(&amp;storage_);\n    }\n\n    type storage_;\n    bool initialized_;\n};\n\ntemplate&lt;typename T, typename E&gt;\nstruct Constructor {\n    static void move(Storage&lt;T, E&gt;&amp;&amp; src, Storage&lt;T, E&gt;&amp; dst, ok_tag) {\n        dst.rawConstruct(std::move(src.template get&lt;T&gt;()));\n        src.destroy(ok_tag());\n    }\n\n    static void copy(const Storage&lt;T, E&gt;&amp; src, Storage&lt;T, E&gt;&amp; dst, ok_tag) {\n        dst.rawConstruct(src.template get&lt;T&gt;());\n    }\n\n    static void move(Storage&lt;T, E&gt;&amp;&amp; src, Storage&lt;T, E&gt;&amp; dst, err_tag) {\n        dst.rawConstruct(std::move(src.template get&lt;E&gt;()));\n        src.destroy(err_tag());\n    }\n\n    static void copy(const Storage&lt;T, E&gt;&amp; src, Storage&lt;T, E&gt;&amp; dst, err_tag) {\n        dst.rawConstruct(src.template get&lt;E&gt;());\n    }\n};\n\ntemplate&lt;typename E&gt;\nstruct Constructor&lt;void, E&gt; {\n    static void move(Storage&lt;void, E&gt;&amp;&amp; src, Storage&lt;void, E&gt;&amp; dst, ok_tag) {}\n\n    static void copy(const Storage&lt;void, E&gt;&amp; src, Storage&lt;void, E&gt;&amp; dst, ok_tag) {}\n\n    static void move(Storage&lt;void, E&gt;&amp;&amp; src, Storage&lt;void, E&gt;&amp; dst, err_tag) {\n        dst.rawConstruct(std::move(src.template get&lt;E&gt;()));\n        src.destroy(err_tag());\n    }\n\n    static void copy(const Storage&lt;void, E&gt;&amp; src, Storage&lt;void, E&gt;&amp; dst, err_tag) {\n        dst.rawConstruct(src.template get&lt;E&gt;());\n    }\n};\n\n} // namespace details\n\nnamespace concepts {\n\ntemplate&lt;typename T, typename = void&gt;\nstruct EqualityComparable : std::false_type {};\n\ntemplate&lt;typename T&gt;\nstruct EqualityComparable&lt;\n    T,\n    typename std::enable_if&lt;\n        true,\n        typename details::void_t&lt;decltype(std::declval&lt;T&gt;() == std::declval&lt;T&gt;())&gt;::type&gt;::type&gt;\n    : std::true_type {};\n\n} // namespace concepts\n\ntemplate&lt;typename T, typename E&gt;\nstruct Result {\n    static_assert(!std::is_same&lt;E, void&gt;::value, \"void error type is not allowed\");\n\n    typedef details::Storage&lt;T, E&gt; storage_type;\n\n    Result(types::Ok&lt;T&gt; ok)\n        : ok_(true) {\n        storage_.construct(std::move(ok));\n    }\n\n    Result(types::Err&lt;E&gt; err)\n        : ok_(false) {\n        storage_.construct(std::move(err));\n    }\n\n    Result(Result&amp;&amp; other) {\n        if (other.isOk()) {\n            details::Constructor&lt;T, E&gt;::move(std::move(other.storage_), storage_, details::ok_tag());\n            ok_ = true;\n        } else {\n            details::Constructor&lt;T, E&gt;::move(std::move(other.storage_),\n                                             storage_,\n                                             details::err_tag());\n            ok_ = false;\n        }\n    }\n\n    Result(const Result&amp; other) {\n        if (other.isOk()) {\n            details::Constructor&lt;T, E&gt;::copy(other.storage_, storage_, details::ok_tag());\n            ok_ = true;\n        } else {\n            details::Constructor&lt;T, E&gt;::copy(other.storage_, storage_, details::err_tag());\n            ok_ = false;\n        }\n    }\n\n    ~Result() {\n        if (ok_)\n            storage_.destroy(details::ok_tag());\n        else\n            storage_.destroy(details::err_tag());\n    }\n\n    bool isOk() const { return ok_; }\n\n    bool isErr() const { return !ok_; }\n\n    T expect(const char* str) const {\n        if (!isOk()) {\n            std::fprintf(stderr, \"%s\\n\", str);\n            std::terminate();\n        }\n        return expect_impl(std::is_same&lt;T, void&gt;());\n    }\n\n    template&lt;\n        typename Func,\n        typename Ret\n        = Result&lt;typename details::ResultOkType&lt;typename details::result_of&lt;Func&gt;::type&gt;::type, E&gt;&gt;\n    Ret map(Func func) const {\n        return details::map(*this, func);\n    }\n\n    template&lt;\n        typename Func,\n        typename Ret\n        = Result&lt;T, typename details::ResultErrType&lt;typename details::result_of&lt;Func&gt;::type&gt;::type&gt;&gt;\n    Ret mapError(Func func) const {\n        return details::mapError(*this, func);\n    }\n\n    template&lt;typename Func&gt;\n    Result&lt;T, E&gt; then(Func func) const {\n        return details::then(*this, func);\n    }\n\n    template&lt;typename Func&gt;\n    Result&lt;T, E&gt; otherwise(Func func) const {\n        return details::otherwise(*this, func);\n    }\n\n    template&lt;\n        typename Func,\n        typename Ret\n        = Result&lt;T, typename details::ResultErrType&lt;typename details::result_of&lt;Func&gt;::type&gt;::type&gt;&gt;\n    Ret orElse(Func func) const {\n        return details::orElse(*this, func);\n    }\n\n    storage_type&amp; storage() { return storage_; }\n\n    const storage_type&amp; storage() const { return storage_; }\n\n    template&lt;typename U = T&gt;\n    typename std::enable_if&lt;!std::is_same&lt;U, void&gt;::value, U&gt;::type unwrapOr(\n        const U&amp; defaultValue) const {\n        if (isOk()) {\n            return storage().template get&lt;U&gt;();\n        }\n        return defaultValue;\n    }\n\n    template&lt;typename U = T&gt;\n    typename std::enable_if&lt;!std::is_same&lt;U, void&gt;::value, U&gt;::type unwrap() const {\n        if (isOk()) {\n            return storage().template get&lt;U&gt;();\n        }\n\n        std::fprintf(stderr, \"Attempting to unwrap an error Result\\n\");\n        std::terminate();\n    }\n\n    E unwrapErr() const {\n        if (isErr()) {\n            return storage().template get&lt;E&gt;();\n        }\n\n        std::fprintf(stderr, \"Attempting to unwrapErr an ok Result\\n\");\n        std::terminate();\n    }\n\nprivate:\n    T expect_impl(std::true_type) const {}\n\n    T expect_impl(std::false_type) const { return storage_.template get&lt;T&gt;(); }\n\n    bool ok_;\n    storage_type storage_;\n};\n\ntemplate&lt;typename T, typename E&gt;\nbool operator==(const Result&lt;T, E&gt;&amp; lhs, const Result&lt;T, E&gt;&amp; rhs) {\n    static_assert(concepts::EqualityComparable&lt;T&gt;::value,\n                  \"T must be EqualityComparable for Result to be comparable\");\n    static_assert(concepts::EqualityComparable&lt;E&gt;::value,\n                  \"E must be EqualityComparable for Result to be comparable\");\n\n    if (lhs.isOk() &amp;&amp; rhs.isOk()) {\n        return lhs.storage().template get&lt;T&gt;() == rhs.storage().template get&lt;T&gt;();\n    }\n    if (lhs.isErr() &amp;&amp; rhs.isErr()) {\n        return lhs.storage().template get&lt;E&gt;() == rhs.storage().template get&lt;E&gt;();\n    }\n}\n\ntemplate&lt;typename T, typename E&gt;\nbool operator==(const Result&lt;T, E&gt;&amp; lhs, types::Ok&lt;T&gt; ok) {\n    static_assert(concepts::EqualityComparable&lt;T&gt;::value,\n                  \"T must be EqualityComparable for Result to be comparable\");\n\n    if (!lhs.isOk())\n        return false;\n\n    return lhs.storage().template get&lt;T&gt;() == ok.val;\n}\n\ntemplate&lt;typename E&gt;\nbool operator==(const Result&lt;void, E&gt;&amp; lhs, types::Ok&lt;void&gt;) {\n    return lhs.isOk();\n}\n\ntemplate&lt;typename T, typename E&gt;\nbool operator==(const Result&lt;T, E&gt;&amp; lhs, types::Err&lt;E&gt; err) {\n    static_assert(concepts::EqualityComparable&lt;E&gt;::value,\n                  \"E must be EqualityComparable for Result to be comparable\");\n    if (!lhs.isErr())\n        return false;\n\n    return lhs.storage().template get&lt;E&gt;() == err.val;\n}\n\n#define TRY(...) \\\n    __extension__({ \\\n        auto res = __VA_ARGS__; \\\n        if (!res.isOk()) { \\\n            typedef details::ResultErrType&lt;decltype(res)&gt;::type E; \\\n            return types::Err&lt;E&gt;(res.storage().get&lt;E&gt;()); \\\n        } \\\n        typedef details::ResultOkType&lt;decltype(res)&gt;::type T; \\\n        res.storage().get&lt;T&gt;(); \\\n    })\n</code></pre>"},{"location":"dictionary/tripledes_8h/","title":"File tripledes.h","text":"<p>FileList &gt; details &gt; tripledes.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;qqmusic/utils/buffer.h&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"dictionary/tripledes_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace details <p>The documentation for this class was generated from the following file <code>include/qqmusic/details/tripledes.h</code></p>"},{"location":"dictionary/tripledes_8h_source/","title":"File tripledes.h","text":"<p>File List &gt; details &gt; tripledes.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QQMUSIC_DETAILS_TRIPLEDES_H\n#define QQMUSIC_DETAILS_TRIPLEDES_H\n\n#include &lt;cstdint&gt;\n#include &lt;qqmusic/utils/buffer.h&gt;\n#include &lt;vector&gt;\n\nnamespace qqmusic::details {\nenum class tripledes_crypt_mode { encrypt, decrypt };\n\nusing tripledes_key_schedule = std::vector&lt;std::vector&lt;std::vector&lt;uint32_t&gt;&gt;&gt;;\n\n// decrypt buf_in and append the result to the end of buf_out\nvoid tripledes_crypt(qqmusic::utils::buffer&amp; buf_in,\n                     qqmusic::utils::buffer&amp; buf_out,\n                     tripledes_key_schedule key_schedule);\n\ntripledes_key_schedule tripledes_key_setup(const uint8_t* key,\n                                           size_t key_size,\n                                           tripledes_crypt_mode mode);\n\n} // namespace qqmusic::details\n\n#endif // !QQMUSIC_DETAILS_TRIPLEDES_H\n</code></pre>"},{"location":"dictionary/login_8h/","title":"File login.h","text":"<p>FileList &gt; include &gt; qqmusic &gt; login.h</p> <p>Go to the source code of this file</p> <p>\u767b\u9646\u76f8\u5173Api, \u5305\u542b\u4e09\u79cd\u767b\u9646\u65b9\u5f0f QQ\u626b\u7801, \u5fae\u4fe1\u626b\u7801, \u624b\u673a\u53f7\u767b\u9646More...</p> <ul> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/buffer.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/credential.h&gt;</code></li> </ul>"},{"location":"dictionary/login_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic"},{"location":"dictionary/login_8h/#classes","title":"Classes","text":"Type Name struct PhoneLoginResult struct QRCode \u4e8c\u7ef4\u7801\u4fe1\u606f class QRCodeLoginEvent \u4e8c\u7ef4\u7801\u767b\u9646\u4e8b\u4ef6 struct QRCodeLoginResult \u4e8c\u7ef4\u7801\u767b\u9646\u7ed3\u679c\u5c01\u88c5"},{"location":"dictionary/login_8h/#detailed-description","title":"Detailed Description","text":"<p>----------------------------------qqmusic/login.h------------------------------------------</p> <p>Warning:</p> <p>\u624b\u673a\u53f7\u767b\u9646\u7684Api\u4ecd\u7136\u6709\u95ee\u9898, \u4e0d\u80fd\u4f7f\u7528.</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/login.h</code></p>"},{"location":"dictionary/login_8h_source/","title":"File login.h","text":"<p>File List &gt; include &gt; qqmusic &gt; login.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QQMUSIC_LOGIN_H\n#define QQMUSIC_LOGIN_H\n\n#include &lt;qqmusic/result.h&gt;\n#include &lt;qqmusic/utils/buffer.h&gt;\n#include &lt;qqmusic/utils/credential.h&gt;\n\nnamespace qqmusic {\n\nenum class QRLoginType { QQ, WX };\n\nenum class PhoneLoginEvent : int { \n    SEND = 0,           \n    CAPTCHA = 20276,    \n    FREQUENCY = 100001, \n    OTHER = -1          \n};\n\nstruct PhoneLoginResult {\n    PhoneLoginEvent event;\n    std::string msg;\n};\n\nstruct QRCode {\n    QRLoginType qr_type;         \n    std::string identifier;      \n    std::string mimie_type;      \n    qqmusic::utils::buffer data; \n};\n\nclass QRCodeLoginEvent {\npublic:\n\n    enum class Status { \n        DONE,    \n        SCAN,    \n        CONF,    \n        REFUSE,  \n        TIMEOUT, \n        OTHER    \n    };\n\n    QRCodeLoginEvent(Status stat) { status = stat; }\n\n    QRCodeLoginEvent(unsigned int code) {\n        switch (code) {\n        case 0:\n        case 405:\n            status = Status::DONE;\n            break;\n        case 66:\n        case 408:\n            status = Status::SCAN;\n            break;\n        case 67:\n        case 404:\n            status = Status::CONF;\n            break;\n        case 65:\n            status = Status::TIMEOUT;\n            break;\n        case 68:\n        case 403:\n            status = Status::REFUSE;\n            break;\n        default:\n            status = Status::OTHER;\n        }\n    };\n\n    inline bool operator==(const QRCodeLoginEvent&amp; e) { return this-&gt;status == e.status; }\n\n    inline bool operator!=(const QRCodeLoginEvent&amp; e) { return this-&gt;status != e.status; }\n\n    inline bool operator==(Status stat) { return status == stat; }\n\n    inline bool operator!=(Status stat) { return status != stat; }\n\n    inline std::string_view name() const { return name_map.at(status); }\n\nprivate:\n    Status status;\n    inline static const std::map&lt;Status, std::string&gt; name_map = {\n        {Status::DONE, \"DONE\"},\n        {Status::SCAN, \"SCAN\"},\n        {Status::CONF, \"CONF\"},\n        {Status::TIMEOUT, \"TIMEOUT\"},\n        {Status::REFUSE, \"REFUSE\"},\n        {Status::OTHER, \"OTHER\"},\n    };\n};\n\nstruct QRCodeLoginResult {\n    QRCodeLoginEvent status{QRCodeLoginEvent::Status::OTHER};\n    std::optional&lt;utils::Credential&gt; credential;\n};\n\nqqmusic::Task&lt;qqmusic::Result&lt;QRCode&gt;&gt; get_qrcode(QRLoginType login_type);\n\nqqmusic::Task&lt;qqmusic::Result&lt;QRCodeLoginResult&gt;&gt; check_qq_qr(QRCode&amp; qrc);\n\nqqmusic::Task&lt;qqmusic::Result&lt;QRCodeLoginResult&gt;&gt; check_wx_qr(QRCode&amp; qrc);\n\nqqmusic::Task&lt;qqmusic::Result&lt;PhoneLoginResult&gt;&gt; send_authcode(\n    std::string_view phone, std::string_view country_code = \"86\");\n\nqqmusic::Task&lt;qqmusic::Result&lt;utils::Credential&gt;&gt; phone_authorize(\n    std::string_view phone, std::string_view auth_code, std::string_view country_code = \"86\");\n\n} // namespace qqmusic\n\n#endif // !QQMUSIC_LOGIN_H\n</code></pre>"},{"location":"dictionary/lyric_8h/","title":"File lyric.h","text":"<p>FileList &gt; include &gt; qqmusic &gt; lyric.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> </ul>"},{"location":"dictionary/lyric_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic"},{"location":"dictionary/lyric_8h/#classes","title":"Classes","text":"Type Name struct Lyric \u6b4c\u8bcd <p>The documentation for this class was generated from the following file <code>include/qqmusic/lyric.h</code></p>"},{"location":"dictionary/lyric_8h_source/","title":"File lyric.h","text":"<p>File List &gt; include &gt; qqmusic &gt; lyric.h</p> <p>Go to the documentation of this file</p> <pre><code>/*-------------------------------------qqmusic/lyric.h----------------------------------------------\n * Lyric utils -- get and decrypt lyrics \n *\n * Get lyric and parse them to strings\n *\n * QRC lyric is an xml string, which starts with `&lt;?xml`, and has time stamp for\n * single character:\n *\n * &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n * &lt;QrcInfos&gt;\n * &lt;QrcHeadInfo SaveTime=\"253\" Version=\"100\"/&gt;\n * &lt;LyricInfo LyricCount=\"1\"&gt;\n * &lt;Lyric_1 LyricType=\"1\" LyricContent=\"[ti:\u5618\u3064\u304d\u306f\u604b\u306e\u306f\u3058\u307e\u308a]\n * [ar:\u6d1b\u5929\u4f9d]\n * [al:\u5618\u3064\u304d\u306f\u604b\u306e\u59cb\u307e\u308a]\n * [by:]\n * [offset:0]\n * [kana:1\u3046\u305d1\u3053\u30441111\u3057...1\u30421\u308f\u30891\u3053\u305f1\u3046\u305d1\u307b\u30931\u3068\u30461\u30441\u3042\u30811\u30721\u304b\u305c1\u30721\u304a]\n * [0,4690]\u5618(0,293)\u3064(293,293)\u304d(586,293)\u306f(879,293)\u604b(1172,293)\u306e(1465,293)\n * \u306f(1758,293)\u3058(2051,293)\u307e(2344,293)\u308a(2637,293) (2930,293)-(3223,293) \n * (3516,293)\u6d1b(3809,293)\u5929(4102,293)\n * \u4f9d(4395,293)\n * [4690,4690]\u8bcd(4690,1563)\uff1a(6253,1563)\uff14\uff10(7816,781)mP(8597,782)\n * [9380,4690]\u66f2(9380,1563)\uff1a(10943,1563)\uff14\uff10(12506,781)mP(13287,782)\n * [14070,4690]\u7f16(14070,1172)\u66f2(15242,1172)\uff1a(16414,1172)\uff14\uff10(17586,586)\n * mP(18172,586)\n * [18770,677]\u300c(18770,151)\u306d(18921,151)\u3048(19072,375)\n * [19538,5596]\u597d(19538,207)\u304d(19745,207)\u306a(19952,527)\u4eba(20479,1759)\n * \u3044(22238,559)\u308b(22797,223)\u306e(23020,175)\uff1f(23195,191)\u300d(23386,135)\n * \u306a(23521,200)\u3093(23721,182)\u3066(23903,1231)\n * [25394,4879]\u541b(25394,471)\u304c(25865,391)\u554f(26256,311)\u3044(26567,247)\n * \u304b(26814,567)\u3051(27381,407)\u3066(27788,383)\u304d(28171,335)\u305f(28506,1767)\n * [31434,6158]\u98a8(31434,784)\u304c(32218,254)\u5439(32472,263)\u3044(32735,303)\u3066(33038,1655)\n * \u9aea(34693,520)\u304c(35213,318)\u63fa(35531,319)\u308c(35850,327)\u3066(36177,1415)\n * [37930,6632]\u6559(37930,471)\u5ba4(38401,503)\u306e(38904,495)\u6642(39399,543)\u304c(39942,351)\n * \u6b62(40293,359)\u307e(40652,415)\u308b(41067,1807)\n * [44562,5977]\u6d88(44562,688)\u3057(45250,592)\u30b4(45842,440)\u30e0(46282,388)\u304c(46670,689)\n * \u5e8a(47359,980)\u306b(48339,624)\u843d(48963,340)\u3061(49303,416)\u3066(49719,820)\n * [50642,3569]\u3059(50642,559)\u3050(51201,711)\u306b(51912,599)\u62fe(52511,535)\n * \u3044(53046,271)\u4e0a(53317,183)\u3052(53500,159)\u3066(53659,552)\n * [54330,3584]\u7b11(54330,263)\u3044(54593,255)\u306a(54848,191)\u304c(55039,207)\n * \u3089(55246,607)\u7b54(55853,336)\u3048(56189,310)\u308b(56499,1415)\n * ...\n *\n * Normal lyric format only has time stamp for each line:\n *\n * [ti:\u5618\u3064\u304d\u306f\u604b\u306e\u306f\u3058\u307e\u308a]\n * [ar:\u6d1b\u5929\u4f9d]\n * [al:\u5618\u3064\u304d\u306f\u604b\u306e\u59cb\u307e\u308a]\n * [by:]\n * [offset:0]\n * [kana:1\u3046\u305d1\u3053....\u30461\u30441\u3042\u30811\u30721\u304b\u305c1\u30721\u304a\u30821\u3064\u30651\u3072\u30681\u30811\u307e\u30481]\n * [00:00.00]\u5618\u3064\u304d\u306f\u604b\u306e\u306f\u3058\u307e\u308a - \u6d1b\u5929\u4f9d\n * [00:04.69]\u8bcd\uff1a\uff14\uff10mP\n * [00:09.38]\u66f2\uff1a\uff14\uff10mP\n * [00:14.07]\u7f16\u66f2\uff1a\uff14\uff10mP\n * [00:18.77]\u300c\u306d\u3048\n * [00:19.53]\u597d\u304d\u306a\u4eba\u3044\u308b\u306e\uff1f\u300d\u306a\u3093\u3066\n * [00:25.39]\u541b\u304c\u554f\u3044\u304b\u3051\u3066\u304d\u305f\n * [00:30.27]\n * [00:31.43]\u98a8\u304c\u5439\u3044\u3066\u9aea\u304c\u63fa\u308c\u3066\n * [00:37.93]\u6559\u5ba4\u306e\u6642\u304c\u6b62\u307e\u308b\n * [00:44.56]\u6d88\u3057\u30b4\u30e0\u304c\u5e8a\u306b\u843d\u3061\u3066\n * [00:50.64]\u3059\u3050\u306b\u62fe\u3044\u4e0a\u3052\u3066\n * [00:54.33]\u7b11\u3044\u306a\u304c\u3089\u7b54\u3048\u308b\n * [00:58.10]\u300c\u3044\u306a\u3044\u3088\u300d\n * [01:00.71]\u307b\u3093\u306e\u3061\u3087\u3063\u3068\u5618\u3092\u3064\u3044\u305f\n * [01:03.71]\u30d0\u30ec\u308b\u306e\u304c\u3053\u308f\u304f\u3066\n * ...\n *------------------------------------------------------------------------------------------------*/\n#ifndef QQMUSIC_LYRIC_H\n#define QQMUSIC_LYRIC_H\n\n#include &lt;qqmusic/result.h&gt;\n\nnamespace qqmusic {\n\nstruct Lyric {\n    std::string lyric; \n    std::string trans; \n    std::string roma;  \n};\n\nTask&lt;Result&lt;Lyric&gt;&gt; get_lyric(std::string_view mid,\n                              bool qrc = false,\n                              bool trans = false,\n                              bool roma = false);\n\nTask&lt;Result&lt;Lyric&gt;&gt; get_lyric(uint64_t id, bool qrc = false, bool trans = false, bool roma = false);\n\n} // namespace qqmusic\n\n#endif // !QQMUSIC_LYRIC_H\n</code></pre>"},{"location":"dictionary/mv_8h/","title":"File mv.h","text":"<p>FileList &gt; include &gt; qqmusic &gt; mv.h</p> <p>Go to the source code of this file</p> <p>\u5173\u4e8eMV\u7684Api More...</p> <ul> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/async-executor.h&gt;</code></li> </ul>"},{"location":"dictionary/mv_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic"},{"location":"dictionary/mv_8h/#classes","title":"Classes","text":"Type Name struct MvUrl Mv url\u5c01\u88dd"},{"location":"dictionary/mv_8h/#detailed-description","title":"Detailed Description","text":"<p>--------------------------------------qqmusic/mv.h-----------------------------------------</p> <p>Date:</p> <p>2025-4-2</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/mv.h</code></p>"},{"location":"dictionary/mv_8h_source/","title":"File mv.h","text":"<p>File List &gt; include &gt; qqmusic &gt; mv.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QQMUSIC_MV_H\n#define QQMUSIC_MV_H\n\n#include &lt;qqmusic/result.h&gt;\n#include &lt;qqmusic/utils/async-executor.h&gt;\n\nnamespace qqmusic {\n\nstruct MvUrl {\n    std::string vid;                        \n    std::map&lt;std::string, std::string&gt; mp4; \n    std::map&lt;std::string, std::string&gt; hls; \n};\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_mv_detail(std::span&lt;std::string&gt; vids);\n\nTask&lt;Result&lt;std::vector&lt;MvUrl&gt;&gt;&gt; get_mv_urls(std::span&lt;std::string&gt; vids);\n\n} // namespace qqmusic\n\n#endif // !QQMUSIC_MV_H\n</code></pre>"},{"location":"dictionary/result_8h/","title":"File result.h","text":"<p>FileList &gt; include &gt; qqmusic &gt; result.h</p> <p>Go to the source code of this file</p> <p>\u63d0\u4f9b\u8fd4\u56de\u503c\u7c7b\u578b\u7684\u5c01\u88c5 More...</p> <ul> <li><code>#include &lt;boost/asio/awaitable.hpp&gt;</code></li> <li><code>#include &lt;nlohmann/json.hpp&gt;</code></li> <li><code>#include &lt;qqmusic/details/result.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/exception.h&gt;</code></li> </ul>"},{"location":"dictionary/result_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic"},{"location":"dictionary/result_8h/#detailed-description","title":"Detailed Description","text":"<p>-----------------------------------qqmusic/result.h----------------------------------------</p> <p>@detail <code>Result &lt;&gt;</code>\u57fa\u4e8eResult.h\u8bbe\u8ba1, \u91c7\u7528Rust\u98ce\u683c\u7684\u8fd4\u56de\u503c, \u540c\u65f6 \u5c01\u88c5\u6b63\u786e\u7684\u8fd4\u56de\u7ed3\u679c\u548c\u5f02\u5e38\u7c7b\u578b.</p> <p><code>Task&lt;&gt;</code>\u662f\u57fa\u4e8e<code>boost::asio</code>\u7684\u901a\u7528\u534f\u7a0b\u5f02\u6b65\u4efb\u52a1, \u4f5c\u4e3a\u534f\u7a0b\u5f02\u6b65\u51fd\u6570\u7684\u8fd4\u56de\u503c</p> <p>Date:</p> <p>2025-4-2</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/result.h</code></p>"},{"location":"dictionary/result_8h_source/","title":"File result.h","text":"<p>File List &gt; include &gt; qqmusic &gt; result.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QQMUSIC_RESULT_H\n#define QQMUSIC_RESULT_H\n\n#include &lt;boost/asio/awaitable.hpp&gt;\n#include &lt;nlohmann/json.hpp&gt;\n#include &lt;qqmusic/details/result.h&gt;\n#include &lt;qqmusic/utils/exception.h&gt;\n\nnamespace qqmusic {\n\ntemplate&lt;typename T&gt;\nusing Result = Result&lt;T, qqmusic::utils::Exception&gt;;\n\ntemplate&lt;typename T&gt;\nusing Task = boost::asio::awaitable&lt;T&gt;;\n\n} // namespace qqmusic\n\n#endif // !QQMUSIC_RESULT_H\n</code></pre>"},{"location":"dictionary/search_8h/","title":"File search.h","text":"<p>FileList &gt; include &gt; qqmusic &gt; search.h</p> <p>Go to the source code of this file</p> <p>\u641c\u7d22\u76f8\u5173Api More...</p> <ul> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;string_view&gt;</code></li> </ul>"},{"location":"dictionary/search_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic"},{"location":"dictionary/search_8h/#detailed-description","title":"Detailed Description","text":"<p>-----------------------------------qqmusic/search.h----------------------------------------</p> <p>Date:</p> <p>2025-4-4</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/search.h</code></p>"},{"location":"dictionary/search_8h_source/","title":"File search.h","text":"<p>File List &gt; include &gt; qqmusic &gt; search.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QQMUSIC_SEARCH_H\n#define QQMUSIC_SEARCH_H\n\n#include &lt;qqmusic/result.h&gt;\n#include &lt;string_view&gt;\n\nnamespace qqmusic {\n\nenum class SearchType : unsigned {\n    SONG = 0,         \n    SINGER = 1,       \n    ALBUM = 2,        \n    SONG_LIST = 3,    \n    MV = 4,           \n    LYRIC = 7,        \n    USER = 8,         \n    AUDIO_ALBUM = 15, \n    AUDIO = 18,       \n};\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; hotkey();\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; keyword_complete(std::string_view keyword);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; quick_search(std::string_view keyword);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; general_search(std::string_view keyword,\n                                            unsigned num = 15,\n                                            unsigned page = 1,\n                                            bool highlight = true);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; search_by_type(std::string_view keyword,\n                                            SearchType type = SearchType::SONG,\n                                            unsigned num_per_page = 10,\n                                            unsigned page = 1,\n                                            bool highlight = true);\n\n} // namespace qqmusic\n\n#endif // !QQMUSIC_SEARCH_H\n</code></pre>"},{"location":"dictionary/singer_8h/","title":"File singer.h","text":"<p>FileList &gt; include &gt; qqmusic &gt; singer.h</p> <p>Go to the source code of this file</p> <p>\u6b4c\u624b\u76f8\u5173API More...</p> <ul> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> </ul>"},{"location":"dictionary/singer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic"},{"location":"dictionary/singer_8h/#classes","title":"Classes","text":"Type Name class TabType \u6807\u7b7e\u7c7b"},{"location":"dictionary/singer_8h/#detailed-description","title":"Detailed Description","text":"<p>------------------------------------qqmusic/singer.h---------------------------------------</p> <p>\u6309\u533a\u57df, \u98ce\u683c, \u6027\u522b\u548c\u7d22\u5f15\u4ee5\u53caTab\u6765\u7b5b\u9009\u6b4c\u624b, \u83b7\u53d6\u6b4c\u5355, \u4e13\u8f91, </p>"},{"location":"dictionary/singer_8h/#_1","title":"\u6b4c\u66f2\u7b49\u4fe1\u606f","text":"<p>The documentation for this class was generated from the following file <code>include/qqmusic/singer.h</code></p>"},{"location":"dictionary/singer_8h_source/","title":"File singer.h","text":"<p>File List &gt; include &gt; qqmusic &gt; singer.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QQMUSIC_SINGER_H\n#define QQMUSIC_SINGER_H\n\n#include &lt;qqmusic/result.h&gt;\n#include &lt;stdexcept&gt;\n#include &lt;unordered_map&gt;\n\nnamespace qqmusic {\n\nenum class AreaType : int {\n    ALL = -100,\n    CHINA = 200,\n    TAIWAN = 2,\n    AMERICA = 5,\n    JAPAN = 4,\n    KOREA = 3\n};\n\nenum class GenreType : int {\n    ALL = -100,\n    POP = 7,\n    RAP = 3,\n    CHINESE_STYLE = 19,\n    ROCK = 4,\n    ELECTRONIC = 2,\n    FOLK = 8,\n    R_AND_B = 11,\n    ETHNIC = 37,\n    LIGHT_MUSIC = 93,\n    JAZZ = 14,\n    CLASSICAL = 33,\n    COUNTRY = 13,\n    BLUES = 10\n};\n\nenum class GenderType : int {\n    ALL = -100,\n    MALE = 0,\n    FEMALE = 1,\n    GROUP = 2,\n};\n\nenum class IndexType : int {\n    A = 1,\n    B,\n    C,\n    D,\n    E,\n    F,\n    G,\n    H,\n    I,\n    J,\n    K,\n    L,\n    M,\n    N,\n    O,\n    P,\n    Q,\n    R,\n    S,\n    T,\n    U,\n    V,\n    W,\n    X,\n    Y,\n    Z,\n    HASH,\n    ALL = -100\n};\n\nclass TabType {\npublic:\n    enum Type {\n        WIKI,     \n        ALBUM,    \n        COMPOSER, \n        LYRICIST, \n        PRODUCER, \n        ARRANGER,\n        MUSICIAN, \n        SONG,     \n        VIDEO     \n    };\n\n    TabType() = delete;\n    TabType(Type type) {\n        auto it = tab_data.find(type);\n        if (it == tab_data.end()) {\n            throw std::runtime_error(\"Unexpected TabType enum\");\n        }\n        this-&gt;inner = it-&gt;second;\n    }\n\n    std::string get_id() const { return inner.tab_id; }\n\n    std::string get_name() const { return inner.tab_name; }\n\nprivate:\n    struct Tab {\n        std::string tab_id;   \n        std::string tab_name; \n    } inner;\n\n    inline static const std::unordered_map&lt;TabType::Type, TabType::Tab&gt; tab_data = {\n        {TabType::WIKI, {\"wiki\", \"IntroductionTab\"}},\n        {TabType::ALBUM, {\"album\", \"AlbumTab\"}},\n        {TabType::COMPOSER, {\"song_composing\", \"SongTab\"}},\n        {TabType::LYRICIST, {\"song_lyric\", \"SongTab\"}},\n        {TabType::PRODUCER, {\"producer\", \"SongTab\"}},\n        {TabType::ARRANGER, {\"arranger\", \"SongTab\"}},\n        {TabType::MUSICIAN, {\"musician\", \"SongTab\"}},\n        {TabType::SONG, {\"song_sing\", \"SongTab\"}},\n        {TabType::VIDEO, {\"video\", \"VideoTab\"}},\n    };\n};\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_singer_list(AreaType area = AreaType::ALL,\n                                             GenderType gender = GenderType::ALL,\n                                             GenreType genre = GenreType::ALL);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_singer_list_index(AreaType area = AreaType::ALL,\n                                                   GenderType gender = GenderType::ALL,\n                                                   GenreType genre = GenreType::ALL,\n                                                   IndexType index = IndexType::ALL,\n                                                   unsigned sin = 0,\n                                                   unsigned cur_page = 1);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_singer_list_index_all(AreaType area = AreaType::ALL,\n                                                       GenderType gender = GenderType::ALL,\n                                                       GenreType genre = GenreType::ALL,\n                                                       IndexType index = IndexType::ALL);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_singer_info(std::string_view mid);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_tab_detail(std::string_view mid,\n                                            TabType type,\n                                            unsigned page = 1,\n                                            unsigned num = 10);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_singer_desc(std::span&lt;std::string&gt; mids, unsigned number = 10);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_similar_singers(std::string_view mid, unsigned number = 10);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_songs_list(std::string_view mid,\n                                            unsigned num = 10,\n                                            unsigned begin = 0);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_songs_list_all(std::string_view mid);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_album_list(std::string_view mid,\n                                            unsigned number = 10,\n                                            unsigned begin = 0);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_album_list_all(std::string_view mid);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_mv_list(std::string_view mid,\n                                         unsigned number = 10,\n                                         unsigned begin = 0);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_mv_list_all(std::string_view mid);\n\n} // namespace qqmusic\n\n#endif // !QQMUSIC_SINGER_H\n</code></pre>"},{"location":"dictionary/song_8h/","title":"File song.h","text":"<p>FileList &gt; include &gt; qqmusic &gt; song.h</p> <p>Go to the source code of this file</p> <p>\u6b4c\u66f2\u76f8\u5173API More...</p> <ul> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/credential.h&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> </ul>"},{"location":"dictionary/song_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic"},{"location":"dictionary/song_8h/#classes","title":"Classes","text":"Type Name class BaseMediaFileType \u5a92\u4f53\u6587\u4ef6\u7c7b\u578b\u57fa\u7c7b class EncryptedSongFileType \u52a0\u5bc6\u6b4c\u66f2\u6587\u4ef6\u7c7b\u578b class SongFileType \u672a\u52a0\u5bc6\u7684\u6b4c\u66f2\u6587\u4ef6\u7c7b\u679a\u4e3e struct SongInfo"},{"location":"dictionary/song_8h/#detailed-description","title":"Detailed Description","text":"<p>------------------------------------qqmusic/song.h-----------------------------------------</p>"},{"location":"dictionary/song_8h/#details-mid-id","title":"@details \u6839\u636emid, id\u83b7\u53d6\u6b4c\u66f2\u4fe1\u606f\u548c\u4e0b\u8f7d\u94fe\u63a5","text":"<p>The documentation for this class was generated from the following file <code>include/qqmusic/song.h</code></p>"},{"location":"dictionary/song_8h_source/","title":"File song.h","text":"<p>File List &gt; include &gt; qqmusic &gt; song.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QQMUSIC_SONG_H\n#define QQMUSIC_SONG_H\n\n#include &lt;map&gt;\n#include &lt;qqmusic/result.h&gt;\n#include &lt;qqmusic/utils/credential.h&gt;\n#include &lt;stdexcept&gt;\n\nnamespace qqmusic {\n\nclass BaseMediaFileType {\npublic:\n    virtual std::string_view prefix() = 0;\n\n    virtual std::string_view expandation() = 0;\n\n    virtual bool encrypted() = 0;\n\n    virtual ~BaseMediaFileType() = default;\n};\n\nclass SongFileType : public BaseMediaFileType {\npublic:\n    enum Type {\n        MASTER,   \n        ATMOS_2,  \n        ATMOS_51, \n        FLAC,     \n        OGG_640,  \n        OGG_320,  \n        OGG_192,  \n        OGG_96,   \n        MP3_320,  \n        MP3_128,  \n        ACC_192,  \n        ACC_96,   \n        ACC_48,   \n    };\n\n    SongFileType(Type type) {\n        if (!table.contains(type)) {\n            throw std::runtime_error(\"Unexpected SongFileType enum\");\n        }\n        inner = table.at(type);\n    };\n\n    SongFileType()\n        : qqmusic::SongFileType(MP3_128) {};\n\n    ~SongFileType() override = default;\n\n    std::string_view prefix() override { return inner.start_id; };\n\n    std::string_view expandation() override { return inner.extention; };\n\n    bool encrypted() override { return false; };\n\nprivate:\n    struct CoreData {\n        std::string start_id;\n        std::string extention;\n    } inner;\n\n    inline static const std::map&lt;Type, CoreData&gt; table = {{MASTER, {\"AI00\", \".flac\"}},\n                                                          {ATMOS_2, {\"Q000\", \".flac\"}},\n                                                          {ATMOS_51, {\"Q001\", \".flac\"}},\n                                                          {FLAC, {\"F000\", \".flac\"}},\n                                                          {OGG_640, {\"O801\", \".ogg\"}},\n                                                          {OGG_320, {\"O800\", \".ogg\"}},\n                                                          {OGG_192, {\"O600\", \".ogg\"}},\n                                                          {OGG_96, {\"O400\", \".ogg\"}},\n                                                          {MP3_320, {\"M800\", \".mp3\"}},\n                                                          {MP3_128, {\"M500\", \".mp3\"}},\n                                                          {ACC_192, {\"C600\", \".m4a\"}},\n                                                          {ACC_96, {\"C400\", \".m4a\"}},\n                                                          {ACC_48, {\"C200\", \".m4a\"}}};\n};\n\nclass EncryptedSongFileType : public BaseMediaFileType {\npublic:\n    enum Type {\n        MASTER,   //&lt; MASTER: \u81fb\u54c1\u6bcd\u5e262.0,24Bit 192kHz,size_new[0]\n        ATMOS_2,  //&lt; ATMOS_2: \u81fb\u54c1\u5168\u666f\u58f02.0,16Bit 44.1kHz,size_new[1]\n        ATMOS_51, //&lt; ATMOS_51: \u81fb\u54c1\u97f3\u8d282.0,16Bit 44.1kHz,size_new[2]\n        FLAC,     //&lt; FLAC: mflac \u683c\u5f0f,16Bit 44.1kHz~24Bit 48kHz,size_flac\n        OGG_640,  //&lt; OGG_640: mgg \u683c\u5f0f,640kbps,size_new[5]\n        OGG_320,  //&lt; OGG_320: mgg \u683c\u5f0f,320kbps,size_new[3]\n        OGG_192,  //&lt; OGG_192: mgg \u683c\u5f0f,192kbps,size_192ogg\n        OGG_96,   //&lt; OGG_96: mgg \u683c\u5f0f,96kbps,size_96ogg\n    };\n\n    EncryptedSongFileType(Type type) {\n        if (!table.contains(type)) {\n            throw std::runtime_error(\"SongFileType -- Ilegal enum type\");\n        }\n        inner = table.at(type);\n    };\n\n    EncryptedSongFileType()\n        : EncryptedSongFileType(FLAC) {};\n\n    ~EncryptedSongFileType() override = default;\n\n    std::string_view prefix() override { return inner.start_id; };\n\n    std::string_view expandation() override { return inner.extention; };\n\n    bool encrypted() override { return true; };\n\nprivate:\n    struct CoreData {\n        std::string start_id;\n        std::string extention;\n    } inner;\n\n    inline static const std::map&lt;Type, CoreData&gt; table = {\n        {MASTER, {\"AIM0\", \".mflac\"}},\n        {ATMOS_2, {\"Q0M0\", \".mflac\"}},\n        {ATMOS_51, {\"Q0M1\", \".mflac\"}},\n        {FLAC, {\"F0M0\", \".mflac\"}},\n        {OGG_640, {\"O801\", \".mgg\"}},\n        {OGG_320, {\"O800\", \".mgg\"}},\n        {OGG_192, {\"O6M0\", \".mgg\"}},\n        {OGG_96, {\"O4M0\", \".mgg\"}},\n    };\n};\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; query_song(std::span&lt;std::string&gt; mids);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; query_song(std::span&lt;uint64_t&gt; ids);\n\nstruct SongInfo {\n    std::string mid;\n    std::optional&lt;std::string&gt; url = std::nullopt;\n    std::optional&lt;std::string&gt; ekey = std::nullopt;\n};\n\nTask&lt;Result&lt;std::vector&lt;SongInfo&gt;&gt;&gt; get_song_urls(\n    std::span&lt;std::string&gt; mids,\n    std::unique_ptr&lt;BaseMediaFileType&gt; file_type = std::make_unique&lt;SongFileType&gt;(),\n    std::optional&lt;utils::Credential&gt; credential = std::nullopt);\n\nTask&lt;Result&lt;std::string&gt;&gt; get_try_url(std::string_view mid, std::string_view vs);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_song_detail(std::string_view mid);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_song_detail(uint64_t id);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_similar_songs(uint64_t songid);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_labels(uint64_t songid);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_related_songlist(uint64_t songid);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_related_mv(uint64_t songid,\n                                            std::optional&lt;std::string&gt; last_mvid = std::nullopt);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_other_version(std::string_view mid);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_other_version(uint64_t id);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_producer_info(std::string_view mid);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_producer_info(uint64_t id);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_sheet(std::string_view mid);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_fav_num(std::span&lt;uint64_t&gt; id_list, bool readable = true);\n\n} // namespace qqmusic\n\n#endif // !QQMUSIC_SONG_H\n</code></pre>"},{"location":"dictionary/songlist_8h/","title":"File songlist.h","text":"<p>FileList &gt; include &gt; qqmusic &gt; songlist.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/credential.h&gt;</code></li> </ul>"},{"location":"dictionary/songlist_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic <p>The documentation for this class was generated from the following file <code>include/qqmusic/songlist.h</code></p>"},{"location":"dictionary/songlist_8h_source/","title":"File songlist.h","text":"<p>File List &gt; include &gt; qqmusic &gt; songlist.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QQMUSIC_SONG_LIST_H\n#define QQMUSIC_SONG_LIST_H\n\n#include &lt;cstdint&gt;\n#include &lt;qqmusic/result.h&gt;\n#include &lt;qqmusic/utils/credential.h&gt;\n\nnamespace qqmusic {\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_songlist_detail(uint64_t dissid,\n                                                 unsigned dirid = 0,\n                                                 unsigned num = 10,\n                                                 unsigned page = 1,\n                                                 bool only_song = false,\n                                                 bool tag = true,\n                                                 bool user_info = true);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_songlist(uint64_t dissid, unsigned dirid = 0);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; songlist_create(\n    std::string_view dirname, std::optional&lt;utils::Credential&gt; credential = std::nullopt);\n\nTask&lt;Result&lt;bool&gt;&gt; songlist_delete(uint64_t dirid,\n                                   std::optional&lt;utils::Credential&gt; credential = std::nullopt);\n\nTask&lt;Result&lt;bool&gt;&gt; songlist_add_songs(uint64_t dirid,\n                                      std::span&lt;uint64_t&gt; song_ids,\n                                      std::optional&lt;utils::Credential&gt; credential = std::nullopt);\n\nTask&lt;Result&lt;bool&gt;&gt; songlist_delete_songs(uint64_t dirid,\n                                         std::span&lt;uint64_t&gt; song_ids,\n                                         std::optional&lt;utils::Credential&gt; credential = std::nullopt);\n} // namespace qqmusic\n\n#endif // !QQMUSIC_SONG_LIST_H\n</code></pre>"},{"location":"dictionary/toplist_8h/","title":"File toplist.h","text":"<p>FileList &gt; include &gt; qqmusic &gt; toplist.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> </ul>"},{"location":"dictionary/toplist_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic <p>The documentation for this class was generated from the following file <code>include/qqmusic/toplist.h</code></p>"},{"location":"dictionary/toplist_8h_source/","title":"File toplist.h","text":"<p>File List &gt; include &gt; qqmusic &gt; toplist.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QQMUSIC_TOP_H\n#define QQMUSIC_TOP_H\n\n#include &lt;qqmusic/result.h&gt;\n\nnamespace qqmusic {\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_toplist_category();\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_toplist_item_detail(unsigned top_id,\n                                                     unsigned num = 10,\n                                                     unsigned page = 1,\n                                                     bool tag = true);\n\n} // namespace qqmusic\n\n#endif // !QQMUSIC_TOP_H\n</code></pre>"},{"location":"dictionary/user_8h/","title":"File user.h","text":"<p>FileList &gt; include &gt; qqmusic &gt; user.h</p> <p>Go to the source code of this file</p> <p>\u7528\u6237\u76f8\u5173Api More...</p> <ul> <li><code>#include &lt;nlohmann/json.hpp&gt;</code></li> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/credential.h&gt;</code></li> <li><code>#include &lt;string_view&gt;</code></li> </ul>"},{"location":"dictionary/user_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic"},{"location":"dictionary/user_8h/#detailed-description","title":"Detailed Description","text":"<p>------------------------------------qqmusic/user.h-----------------------------------------</p> <p>Date:</p> <p>2025-4-5</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/user.h</code></p>"},{"location":"dictionary/user_8h_source/","title":"File user.h","text":"<p>File List &gt; include &gt; qqmusic &gt; user.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QQMUSIC_USER_H\n#define QQMUSIC_USER_H\n\n#include &lt;nlohmann/json.hpp&gt;\n#include &lt;qqmusic/result.h&gt;\n#include &lt;qqmusic/utils/credential.h&gt;\n#include &lt;string_view&gt;\n\nnamespace qqmusic {\n\nTask&lt;Result&lt;std::string&gt;&gt; get_euin(uint64_t musicid);\n\nTask&lt;Result&lt;uint64_t&gt;&gt; get_musicid(std::string_view euin);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_homepage(\n    std::string_view euin, std::optional&lt;utils::Credential&gt; credential = std::nullopt);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_vip_info(std::optional&lt;utils::Credential&gt; credential = std::nullopt);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_follow_singers(\n    std::string_view euin,\n    unsigned page = 1,\n    unsigned num = 10,\n    std::optional&lt;utils::Credential&gt; credential = std::nullopt);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_fans(std::string_view euin,\n                                      unsigned page = 1,\n                                      unsigned num = 10,\n                                      std::optional&lt;utils::Credential&gt; credential = std::nullopt);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_friend_list(\n    unsigned page = 1,\n    unsigned num = 10,\n    std::optional&lt;utils::Credential&gt; credential = std::nullopt);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_follow_usr(\n    std::string_view euin,\n    unsigned page = 1,\n    unsigned num = 10,\n    std::optional&lt;utils::Credential&gt; credential = std::nullopt);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_created_songlist(\n    uint64_t musicid, std::optional&lt;utils::Credential&gt; credential = std::nullopt);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_fav_song(std::string_view euin,\n                                          unsigned page = 1,\n                                          unsigned num = 10,\n                                          std::optional&lt;utils::Credential&gt; credential = std::nullopt);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_fav_songlist(\n    std::string_view euin,\n    unsigned page = 1,\n    unsigned num = 10,\n    std::optional&lt;utils::Credential&gt; credential = std::nullopt);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_fav_album(\n    std::string_view euin,\n    unsigned page = 1,\n    unsigned num = 10,\n    std::optional&lt;utils::Credential&gt; credential = std::nullopt);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_fav_mv(std::string_view euin,\n                                        unsigned page = 1,\n                                        unsigned num = 10,\n                                        std::optional&lt;utils::Credential&gt; credential = std::nullopt);\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_music_gene(\n    std::string_view euin, std::optional&lt;utils::Credential&gt; credential = std::nullopt);\n\n} // namespace qqmusic\n\n#endif // !QQMUSIC_USER_H\n</code></pre>"},{"location":"dictionary/dir_478616d8952f43e793f28d8ded6e3463/","title":"Dir utils","text":"<p>FileList &gt; include &gt; qqmusic &gt; utils</p>"},{"location":"dictionary/dir_478616d8952f43e793f28d8ded6e3463/#files","title":"Files","text":"Type Name file async-executor.h \u63d0\u4f9b\u4e86\u4e00\u4e2a\u9ed8\u8ba4\u7684\u7b80\u5355\u534f\u7a0b\u8c03\u5ea6\u5668, \u4ee5\u53ca\u540c\u6b65\u6267\u884c\u5f02\u6b65\u51fd\u6570\u7684\u65b9\u6cd5. file buffer.h \u4e8c\u8fdb\u5236\u7f13\u51b2\u533a\u7c7b file common.h file cookie.h file credential.h file device.h file exception.h file paths.h file qimei.h file session.h <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/</code></p>"},{"location":"dictionary/async-executor_8h/","title":"File async-executor.h","text":"<p>FileList &gt; include &gt; qqmusic &gt; utils &gt; async-executor.h</p> <p>Go to the source code of this file</p> <p>\u63d0\u4f9b\u4e86\u4e00\u4e2a\u9ed8\u8ba4\u7684\u7b80\u5355\u534f\u7a0b\u8c03\u5ea6\u5668, \u4ee5\u53ca\u540c\u6b65\u6267\u884c\u5f02\u6b65\u51fd\u6570\u7684\u65b9\u6cd5. More...</p> <ul> <li><code>#include &lt;boost/asio/co_spawn.hpp&gt;</code></li> <li><code>#include &lt;boost/asio/detached.hpp&gt;</code></li> <li><code>#include &lt;boost/asio/io_context.hpp&gt;</code></li> <li><code>#include &lt;boost/asio/steady_timer.hpp&gt;</code></li> <li><code>#include &lt;boost/asio/use_future.hpp&gt;</code></li> <li><code>#include &lt;exception&gt;</code></li> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"dictionary/async-executor_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace utils \u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027"},{"location":"dictionary/async-executor_8h/#classes","title":"Classes","text":"Type Name class AsyncExecutor \u5168\u5c40\u8c03\u5ea6\u5668\u7c7b"},{"location":"dictionary/async-executor_8h/#detailed-description","title":"Detailed Description","text":"<p>-------------------------------qqmusic/utils/async-executor.h------------------------------</p> <p>Date:</p> <p>2025-3-21</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/async-executor.h</code></p>"},{"location":"dictionary/async-executor_8h_source/","title":"File async-executor.h","text":"<p>File List &gt; include &gt; qqmusic &gt; utils &gt; async-executor.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QQMUSIC_UTILS_ASYNC_EXECUTOR_H\n#define QQMUSIC_UTILS_ASYNC_EXECUTOR_H\n\n#include &lt;boost/asio/co_spawn.hpp&gt;\n#include &lt;boost/asio/detached.hpp&gt;\n#include &lt;boost/asio/io_context.hpp&gt;\n#include &lt;boost/asio/steady_timer.hpp&gt;\n#include &lt;boost/asio/use_future.hpp&gt;\n#include &lt;exception&gt;\n#include &lt;qqmusic/result.h&gt;\n#include &lt;stdexcept&gt;\n#include &lt;thread&gt;\n#include &lt;utility&gt;\n\nnamespace qqmusic::utils {\n\n/*custom co_spawn entry point to avoid using deleted default Result&lt;T&gt; constructor*/\ntemplate&lt;typename T, typename Executor&gt;\nboost::asio::awaitable&lt;void&gt; custom_co_spawn_entry_point(\n    boost::asio::awaitable&lt;T, Executor&gt; aw,\n    std::function&lt;void(std::exception_ptr, std::optional&lt;T&gt;)&gt; handler) {\n    try {\n        T result = co_await std::move(aw);\n        handler(nullptr, std::move(result));\n    } catch (...) {\n        handler(std::current_exception(), std::optional&lt;T&gt;());\n    }\n}\n\ntemplate&lt;typename T&gt;\nT sync_exec(boost::asio::io_context&amp; ioc, qqmusic::Task&lt;T&gt; task) {\n    /*synchronously execute the task and get reslt, need io_context*/\n    std::optional&lt;T&gt; result;\n    std::exception_ptr exception;\n\n    std::function&lt;void(std::exception_ptr, std::optional&lt;T&gt;)&gt; handler =\n        [&amp;](std::exception_ptr e, std::optional&lt;T&gt; value) {\n            if (e) {\n                exception = e;\n            } else {\n                result.emplace(std::move(*value));\n            }\n        };\n\n    boost::asio::co_spawn(ioc,\n                          custom_co_spawn_entry_point(std::move(task), handler),\n                          boost::asio::detached);\n\n    ioc.run();\n\n    if (exception) {\n        std::rethrow_exception(exception);\n    }\n\n    if (!result.has_value()) {\n        throw std::runtime_error(\"Expect result has a value\");\n    }\n\n    return std::move(*result);\n}\n\ntemplate&lt;typename T&gt;\nT sync_exec(qqmusic::Task&lt;T&gt; task) {\n    /*sync get result*/\n    boost::asio::io_context ioc;\n    return sync_exec(ioc, std::move(task));\n}\n\nclass AsyncExecutor {\n    /*Global AsyncExecutor class*/\npublic:\n    AsyncExecutor(const AsyncExecutor&amp;) = delete;\n    AsyncExecutor&amp; operator=(const AsyncExecutor&amp;) = delete;\n\n    static AsyncExecutor&amp; get_instance();\n\n    template&lt;typename T, BOOST_ASIO_COMPLETION_TOKEN_FOR(void(T&amp;&amp;)) CompletionCallback&gt;\n    void async_exec(qqmusic::Task&lt;T&gt; task, CompletionCallback&amp;&amp; callback) {\n        std::optional&lt;T&gt; result;\n        std::exception_ptr exception;\n\n        std::function&lt;void(std::exception_ptr, std::optional&lt;T&gt;)&gt; handler =\n            [&amp;](std::exception_ptr e, std::optional&lt;T&gt; value) {\n                if (e) {\n                    exception = e;\n                } else {\n                    result.emplace(std::move(*value));\n                }\n            };\n\n        boost::asio::co_spawn(ioc,\n                              custom_co_spawn_entry_point(std::move(task), handler),\n                              boost::asio::detached);\n\n        callback(std::move(result.value()));\n    }\n\n    template&lt;BOOST_ASIO_COMPLETION_TOKEN_FOR(void()) CompletionCallback&gt;\n    void async_exec(qqmusic::Task&lt;void&gt; task, CompletionCallback&amp;&amp; callback) {\n        boost::asio::co_spawn(ioc,\n                              std::move(task),\n                              [callback = std::forward&lt;CompletionCallback&gt;(callback)](\n                                  std::exception_ptr e) {\n                                  if (!e) {\n                                      callback();\n                                  } else {\n                                      try {\n                                          std::rethrow_exception(e);\n                                      } catch (const std::exception&amp; ex) {\n                                          /* TODO: get a logger*/\n                                          std::cout &lt;&lt; std::format(\"Exception in async task: {}\",\n                                                                   ex.what())\n                                                    &lt;&lt; std::endl;\n                                      }\n                                  }\n                              });\n    }\n\n    template&lt;typename T,\n             BOOST_ASIO_COMPLETION_TOKEN_FOR(void(T&amp;&amp;)) CompletionCallback,\n             BOOST_ASIO_COMPLETION_TOKEN_FOR(void()) TimeoutCallback&gt;\n    void async_exec(qqmusic::Task&lt;T&gt; task,\n                    CompletionCallback&amp;&amp; callback,\n                    std::chrono::steady_clock::duration timeout,\n                    TimeoutCallback&amp;&amp; timeout_callback) {\n        auto timer = std::make_shared&lt;boost::asio::steady_timer&gt;(ioc, timeout);\n        auto task_ptr = std::make_shared&lt;boost::asio::awaitable&lt;void&gt;&gt;(std::move(task));\n\n        boost::asio::co_spawn(ioc,\n                              std::move(*task_ptr),\n                              [callback = std::forward&lt;CompletionCallback&gt;(callback),\n                               timer](std::exception_ptr e, T value) {\n                                  timer-&gt;cancel();\n                                  if (!e) {\n                                      callback(std::move(value));\n                                  } else {\n                                      try {\n                                          std::rethrow_exception(e);\n                                      } catch (const std::exception&amp; ex) {\n                                          std::cout &lt;&lt; std::format(\"Exception in async task: {}\",\n                                                                   ex.what())\n                                                    &lt;&lt; std::endl;\n                                      }\n                                  }\n                              });\n\n        /*if timeout*/\n        timer-&gt;async_wait([timeout_callback = std::forward&lt;TimeoutCallback&gt;(timeout_callback),\n                           task_ptr](boost::system::error_code&amp; ec) {\n            if (!ec) {\n                timeout_callback();\n            } else {\n                std::cout &lt;&lt; std::format(\"Exception in async task: {}\", ec.what()) &lt;&lt; std::endl;\n            }\n        });\n    }\n\n    template&lt;BOOST_ASIO_COMPLETION_TOKEN_FOR(void()) CompletionCallback,\n             BOOST_ASIO_COMPLETION_TOKEN_FOR(void()) TimeoutCallback&gt;\n    void async_exec(qqmusic::Task&lt;void&gt; task,\n                    CompletionCallback&amp;&amp; callback,\n                    std::chrono::steady_clock::duration timeout,\n                    TimeoutCallback&amp;&amp; timeout_callback) {\n        auto timer = std::make_shared&lt;boost::asio::steady_timer&gt;(ioc, timeout);\n        auto task_ptr = std::make_shared&lt;boost::asio::awaitable&lt;void&gt;&gt;(std::move(task));\n\n        boost::asio::co_spawn(ioc,\n                              std::move(*task_ptr),\n                              [callback = std::forward&lt;CompletionCallback&gt;(callback),\n                               timer](std::exception_ptr e) {\n                                  timer-&gt;cancel();\n                                  if (!e) {\n                                      callback();\n                                  } else {\n                                      try {\n                                          std::rethrow_exception(e);\n                                      } catch (const std::exception&amp; ex) {\n                                          std::cout &lt;&lt; std::format(\"Exception in async task: {}\",\n                                                                   ex.what())\n                                                    &lt;&lt; std::endl;\n                                      }\n                                  }\n                              });\n\n        /*if timeout*/\n        timer-&gt;async_wait([timeout_callback = std::forward&lt;TimeoutCallback&gt;(timeout_callback),\n                           task_ptr](boost::system::error_code&amp; ec) {\n            if (!ec) {\n                timeout_callback();\n            } else {\n                std::cout &lt;&lt; std::format(\"Exception in async task: {}\", ec.what()) &lt;&lt; std::endl;\n            }\n        });\n    }\n\n    template&lt;typename T&gt;\n    auto when_all(std::vector&lt;boost::asio::awaitable&lt;T&gt;&gt; tasks)\n        -&gt; boost::asio::awaitable&lt;std::vector&lt;T&gt;&gt; {\n        std::vector&lt;std::shared_ptr&lt;std::promise&lt;T&gt;&gt;&gt; promises;\n        std::vector&lt;std::future&lt;T&gt;&gt; futures;\n\n        promises.reserve(tasks.size());\n        futures.reserve(tasks.size());\n\n        for (auto&amp; task : tasks) {\n            auto promise = std::make_shared&lt;std::promise&lt;T&gt;&gt;();\n            futures.push_back(promise-&gt;get_future());\n\n            boost::asio::co_spawn(\n                ioc,\n                [task = std::move(task), promise]() mutable -&gt; boost::asio::awaitable&lt;void&gt; {\n                    try {\n                        T result = co_await std::move(task);\n                        promise-&gt;set_value(std::move(result));\n                    } catch (...) {\n                        promise-&gt;set_exception(std::current_exception());\n                    }\n                },\n                boost::asio::detached);\n\n            promises.push_back(std::move(promise));\n        }\n\n        std::vector&lt;T&gt; results;\n        results.reserve(tasks.size());\n        for (auto&amp; fut : futures) {\n            results.push_back(std::move(fut.get()));\n        }\n\n        co_return results;\n    }\n\n    void shutdown();\n\nprivate:\n    AsyncExecutor();\n    ~AsyncExecutor();\n    boost::asio::io_context ioc;\n    std::thread ioc_thread;\n};\n\n} // namespace qqmusic::utils\n\n#endif // !QQMUSIC_UTILS_ASYNC_EXECUTOR_H\n</code></pre>"},{"location":"dictionary/buffer_8h/","title":"File buffer.h","text":"<p>FileList &gt; include &gt; qqmusic &gt; utils &gt; buffer.h</p> <p>Go to the source code of this file</p> <p>\u4e8c\u8fdb\u5236\u7f13\u51b2\u533a\u7c7b More...</p> <ul> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;cstdlib&gt;</code></li> <li><code>#include &lt;cstring&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"dictionary/buffer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace utils \u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027"},{"location":"dictionary/buffer_8h/#classes","title":"Classes","text":"Type Name class buffer \u4e8c\u8fdb\u5236\u7f13\u51b2\u533a\u7684\u7edf\u4e00\u8868\u793a"},{"location":"dictionary/buffer_8h/#detailed-description","title":"Detailed Description","text":"<p>---------------------------------qqmusic/utils/buffer.h------------------------------------</p> <p>Date:</p> <p>2025-3-21</p> <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/buffer.h</code></p>"},{"location":"dictionary/buffer_8h_source/","title":"File buffer.h","text":"<p>File List &gt; include &gt; qqmusic &gt; utils &gt; buffer.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QQMUSIC_UTILS_BUFFER_HPP\n#define QQMUSIC_UTILS_BUFFER_HPP\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstring&gt;\n#include &lt;vector&gt;\n\nnamespace qqmusic::utils {\n\nclass buffer : public std::vector&lt;uint8_t&gt; {\npublic:\n\n    buffer() = default;\n\n    buffer(size_t size)\n        : std::vector&lt;uint8_t&gt;(size){};\n\n    buffer(const uint8_t* src_head, size_t src_size)\n        : std::vector&lt;uint8_t&gt;(src_head, src_head + src_size){};\n\n    buffer(std::vector&lt;uint8_t&gt;&amp;&amp; other) noexcept\n        : std::vector&lt;uint8_t&gt;(std::move(other)) {}\n\n    buffer(buffer&amp;&amp; other) noexcept\n        : std::vector&lt;uint8_t&gt;(std::move(other)) {}\n\n    buffer(size_t size, char c)\n        : std::vector&lt;uint8_t&gt;(size, c) {}\n\n    ~buffer() = default;\n\n    void append(const void* src_data_buf, size_t data_buf_size) {\n        this-&gt;insert(this-&gt;end(), (uint8_t*) src_data_buf, (uint8_t*) src_data_buf + data_buf_size);\n    };\n\n    buffer(const buffer&amp; other) = default;\n\n    buffer&amp; operator=(const buffer&amp; other) = default;\n\n    buffer operator+=(const buffer&amp; a) {\n        this-&gt;insert(this-&gt;end(), a.begin(), a.end());\n        return *this;\n    }\n\n    buffer operator+(const buffer&amp; a) {\n        buffer res = *this;\n        return res += a;\n    }\n};\n\n} // namespace qqmusic::utils\n\n#endif // !QQMUSIC_UTILS_BUFFER_HPP\n</code></pre>"},{"location":"dictionary/common_8h/","title":"File common.h","text":"<p>FileList &gt; include &gt; qqmusic &gt; utils &gt; common.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/beast.hpp&gt;</code></li> <li><code>#include &lt;boost/beast/http/message.hpp&gt;</code></li> <li><code>#include &lt;nlohmann/json.hpp&gt;</code></li> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/buffer.h&gt;</code></li> </ul>"},{"location":"dictionary/common_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace utils \u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027 <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/common.h</code></p>"},{"location":"dictionary/common_8h_source/","title":"File common.h","text":"<p>File List &gt; include &gt; qqmusic &gt; utils &gt; common.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QQMUSIC_UTILS_COMMON_H\n#define QQMUSIC_UTILS_COMMON_H\n\n#include &lt;boost/beast.hpp&gt;\n#include &lt;boost/beast/http/message.hpp&gt;\n#include &lt;nlohmann/json.hpp&gt;\n#include &lt;qqmusic/result.h&gt;\n#include &lt;qqmusic/utils/buffer.h&gt;\n\nnamespace qqmusic::utils {\n\nnamespace http = boost::beast::http;\n\nstd::string sign(const nlohmann::json&amp; params);\n\nbuffer resp2buf(http::response&lt;http::dynamic_body&gt;&amp;&amp; resp);\n\nbuffer hex2buf(std::string_view hex);\n\nenum class qrc_type { cloud, local };\n\nqqmusic::Result&lt;std::string&gt; qrc_decode(const qqmusic::utils::buffer&amp; src,\n                                        qqmusic::utils::qrc_type type);\n\nuint64_t hash33(std::string_view str, uint64_t prev = 0);\n\nstd::string get_search_id();\n\n} // namespace qqmusic::utils\n\n#endif // !QQMUSIC_UTILS_COMMON_H\n</code></pre>"},{"location":"dictionary/cookie_8h/","title":"File cookie.h","text":"<p>FileList &gt; include &gt; qqmusic &gt; utils &gt; cookie.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;nlohmann/json.hpp&gt;</code></li> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;string_view&gt;</code></li> </ul>"},{"location":"dictionary/cookie_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace utils \u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027"},{"location":"dictionary/cookie_8h/#classes","title":"Classes","text":"Type Name struct Cookie \u4ee3\u8868\u4e00\u6761Cookie class CookieJar \u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027 <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/cookie.h</code></p>"},{"location":"dictionary/cookie_8h_source/","title":"File cookie.h","text":"<p>File List &gt; include &gt; qqmusic &gt; utils &gt; cookie.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QQMUSIC_UTILS_COOKIE_H\n#define QQMUSIC_UTILS_COOKIE_H\n\n#include &lt;nlohmann/json.hpp&gt;\n#include &lt;qqmusic/result.h&gt;\n#include &lt;string_view&gt;\n\nnamespace qqmusic::utils {\n\nstruct Cookie {\n    std::string domain;\n\n    std::string path = \"/\"; /*for each site use '/' as default path*/\n\n    std::string key;\n\n    std::string value;\n};\n\nqqmusic::Result&lt;nlohmann::json&gt; parse_cookie(std::string_view cookie_str);\n\nclass CookieJar {\npublic:\n\n    CookieJar()\n        : content({{\"\", {{\"/\", nlohmann::json::object()}}}}) {};\n\n    CookieJar(std::string_view cache)\n        : content(nlohmann::json::parse(cache)) {};\n\n    CookieJar(std::string_view cookie_str, std::string_view domain, std::string_view path = \"/\");\n\n    qqmusic::Result&lt;void&gt; set(const Cookie&amp; cookie);\n\n    qqmusic::Result&lt;std::string&gt; get(std::string_view key,\n                                     std::optional&lt;std::string&gt; domain = std::nullopt,\n                                     std::optional&lt;std::string&gt; path = std::nullopt);\n\n    qqmusic::Result&lt;void&gt; del(std::string_view key,\n                              std::optional&lt;std::string&gt; domain = std::nullopt,\n                              std::optional&lt;std::string&gt; path = std::nullopt);\n\n    qqmusic::Result&lt;std::string&gt; dump();\n\n    qqmusic::Result&lt;std::string&gt; serialize(std::string_view domain, std::string_view path = \"/\");\n\n\n    qqmusic::Result&lt;void&gt; clear(std::optional&lt;std::string&gt; domain = std::nullopt,\n                                std::optional&lt;std::string&gt; path = std::nullopt,\n                                std::optional&lt;std::string&gt; key = std::nullopt);\n\n    qqmusic::Result&lt;void&gt; update(const CookieJar&amp; cookies);\n\n    qqmusic::Result&lt;void&gt; merge(const CookieJar&amp; cookies);\n\nprivate:\n    nlohmann::json content;\n};\n\n} // namespace qqmusic::utils\n\n#endif // !QQMUSIC_UTILS_COOKIE_H\n</code></pre>"},{"location":"dictionary/credential_8h/","title":"File credential.h","text":"<p>FileList &gt; include &gt; qqmusic &gt; utils &gt; credential.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;nlohmann/detail/macro_scope.hpp&gt;</code></li> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"dictionary/credential_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace utils \u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027"},{"location":"dictionary/credential_8h/#classes","title":"Classes","text":"Type Name class Credential \u51ed\u636e\u4fe1\u606f\u7c7b <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/credential.h</code></p>"},{"location":"dictionary/credential_8h_source/","title":"File credential.h","text":"<p>File List &gt; include &gt; qqmusic &gt; utils &gt; credential.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QQMUSIC_UTILS_CREDENTIAL_H\n#define QQMUSIC_UTILS_CREDENTIAL_H\n\n#include &lt;cstdint&gt;\n#include &lt;nlohmann/detail/macro_scope.hpp&gt;\n#include &lt;qqmusic/result.h&gt;\n#include &lt;string&gt;\n\nnamespace qqmusic::utils {\n\nclass Credential {\npublic:\n    Credential() = default;\n\n    explicit Credential(std::string_view cookie);\n\n    explicit Credential(nlohmann::json&amp; cookie);\n\n    bool from_cache(std::string_view cache);\n\n    bool from_cache(nlohmann::json&amp; cache);\n\n    bool is_valid() const;\n\n    qqmusic::Task&lt;qqmusic::Result&lt;bool&gt;&gt; is_expired();\n\n    qqmusic::Task&lt;qqmusic::Result&lt;void&gt;&gt; refresh();\n\n    qqmusic::Result&lt;std::string&gt; to_string();\n\n    qqmusic::Result&lt;nlohmann::json&gt; to_json();\n\n    std::string openid;\n\n    std::string refresh_token;\n\n    std::string access_token;\n\n    uint64_t expired_at = 0;\n\n    uint64_t musicid = 0;\n\n    std::string musickey;\n\n    std::string unionid;\n\n    std::string str_musicid;\n\n    std::string refresh_key;\n\n    std::string encryptUin;\n\n    int loginType = 2;\n\n    nlohmann::json extra_fields;\n\n    NLOHMANN_DEFINE_TYPE_INTRUSIVE(Credential,\n                                   openid,\n                                   refresh_token,\n                                   access_token,\n                                   expired_at,\n                                   musicid,\n                                   unionid,\n                                   str_musicid,\n                                   musickey,\n                                   refresh_key,\n                                   encryptUin,\n                                   loginType);\n};\n\n} // namespace qqmusic::utils\n\n#endif // !QQMUSIC_UTILS_CREDENTIAL_H\n</code></pre>"},{"location":"dictionary/device_8h/","title":"File device.h","text":"<p>FileList &gt; include &gt; qqmusic &gt; utils &gt; device.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;nlohmann/detail/macro_scope.hpp&gt;</code></li> <li><code>#include &lt;nlohmann/json.hpp&gt;</code></li> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> </ul>"},{"location":"dictionary/device_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace utils \u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027"},{"location":"dictionary/device_8h/#classes","title":"Classes","text":"Type Name struct Device \u8bbe\u5907\u4fe1\u606f struct OSVersion <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/device.h</code></p>"},{"location":"dictionary/device_8h_source/","title":"File device.h","text":"<p>File List &gt; include &gt; qqmusic &gt; utils &gt; device.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QQMUSIC_UTILS_DEVICE_H\n#define QQMUSIC_UTILS_DEVICE_H\n\n#include &lt;nlohmann/detail/macro_scope.hpp&gt;\n#include &lt;nlohmann/json.hpp&gt;\n#include &lt;qqmusic/result.h&gt;\n\nnamespace qqmusic::utils {\n\nstruct OSVersion {\n    OSVersion();\n\n    std::string incremental;\n    std::string release;\n    std::string codename;\n    int sdk;\n\n    NLOHMANN_DEFINE_TYPE_INTRUSIVE(OSVersion, incremental, release, codename, sdk);\n};\n\nstruct Device {\n    Device();\n\n    std::string display;\n    std::string product;\n    std::string device;\n    std::string board;\n    std::string model;\n    std::string fingerprint;\n    std::string boot_id;\n    std::string proc_version;\n    std::string imei;\n    std::string brand;\n    std::string bootloader;\n    std::string base_band;\n    struct OSVersion version;\n    std::string sim_info;\n    std::string os_type;\n    std::string mac_address;\n    std::vector&lt;int&gt; ip_address;\n    std::string wifi_bssid;\n    std::string wifi_ssid;\n    std::vector&lt;int&gt; imsi_md5;\n    std::string android_id;\n    std::string apn;\n    std::string vendor_name;\n    std::string vendor_os_name;\n    std::string qimei;\n\n    NLOHMANN_DEFINE_TYPE_INTRUSIVE(Device,\n                                   display,\n                                   product,\n                                   device,\n                                   board,\n                                   model,\n                                   fingerprint,\n                                   boot_id,\n                                   proc_version,\n                                   imei,\n                                   brand,\n                                   bootloader,\n                                   base_band,\n                                   version,\n                                   sim_info,\n                                   os_type,\n                                   mac_address,\n                                   wifi_bssid,\n                                   wifi_ssid,\n                                   imsi_md5,\n                                   android_id,\n                                   apn,\n                                   vendor_name,\n                                   vendor_os_name,\n                                   qimei);\n};\n\nqqmusic::Result&lt;Device&gt; get_device_info();\n\nqqmusic::Result&lt;void&gt; cache_device(const Device&amp; device);\n\n} // namespace qqmusic::utils\n\n#endif // !QQMUSIC_UTILS_DEVICE_H\n</code></pre>"},{"location":"dictionary/exception_8h/","title":"File exception.h","text":"<p>FileList &gt; include &gt; qqmusic &gt; utils &gt; exception.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> </ul>"},{"location":"dictionary/exception_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace utils \u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027"},{"location":"dictionary/exception_8h/#classes","title":"Classes","text":"Type Name class Exception \u5168\u5c40\u5f02\u5e38\u7c7b <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/exception.h</code></p>"},{"location":"dictionary/exception_8h_source/","title":"File exception.h","text":"<p>File List &gt; include &gt; qqmusic &gt; utils &gt; exception.h</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n\nnamespace qqmusic::utils {\n\nclass Exception {\npublic:\n\n    enum Kind {\n        ResponseCodeError = 0,  //&lt; Api returns an error response code\n        CredendialExpiredError, //&lt; Credential is out dated\n        CredentialInvalidError, //&lt; Credential is invalid\n        LoginError,             //&lt; Login failure\n        SignInvalidError,       //&lt; Request signature is invalid\n        DataDestroy,            //&lt; Data destroy during crypto, serialization, deserialization or decoding\n        RuntimeError,           //&lt; Any runtime error including exceptions thrown by 3rd libs\n        NetworkError,           //&lt; Unknown network error\n        JsonError,              //&lt; Error when handling json\n        OperationOutOfTime,     //&lt; Out of Time\n        SslError,               //&lt; Error when SSL/TLS operations\n        UnknownError\n    };\n\n    Exception(Kind kind)\n        : kind_code(kind)\n        , reason(ReasonKindMap[kind]) {}\n\n    Exception(Kind kind, std::string_view reason)\n        : kind_code(kind)\n        , reason(reason) {}\n\n    Exception(unsigned int http_rc)\n        : kind_code(ResponseCodeError) {\n        if (HttpResponseCodeMap.contains(http_rc)) {\n            reason = HttpResponseCodeMap[http_rc];\n        } else {\n            reason = ReasonKindMap[Kind::ResponseCodeError];\n        }\n    }\n\n    [[nodiscard]] unsigned int get_error_enum() const { return kind_code; }\n\n    [[nodiscard]] std::string kind() const { return ReasonKindMap[kind_code]; }\n\n    [[nodiscard]] std::string what() const { return reason; }\n\nprivate:\n    enum Kind kind_code;\n    std::string reason;\n\n    inline static std::string ReasonKindMap[UnknownError + 1] = {\"ResponseCodeError\",\n                                                                 \"CredendialExpiredError\",\n                                                                 \"CredentialInvalidError\",\n                                                                 \"LoginError\",\n                                                                 \"SignInvalidError\",\n                                                                 \"DataDestroy\",\n                                                                 \"RuntimeError\",\n                                                                 \"NetworkError\",\n                                                                 \"JsonError\",\n                                                                 \"OperationOutOfTime\",\n                                                                 \"SslError\",\n                                                                 \"Unknown Error\"};\n\n    inline static std::unordered_map&lt;unsigned, std::string&gt; HttpResponseCodeMap = {\n        {400u, \"400 Bad Request\"},\n        {401u, \"401 Unauthorized\"},\n        {403u, \"403 Forbidden\"},\n        {404u, \"404 Not Found\"},\n        {500u, \"500 Internal Server Error\"},\n        {502u, \"502 Bad Gateway\"},\n        {503u, \"503 Service Unavailable\"},\n    };\n};\n\n} // namespace qqmusic::utils\n</code></pre>"},{"location":"dictionary/paths_8h/","title":"File paths.h","text":"<p>FileList &gt; include &gt; qqmusic &gt; utils &gt; paths.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;filesystem&gt;</code></li> </ul>"},{"location":"dictionary/paths_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace utils \u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027"},{"location":"dictionary/paths_8h/#classes","title":"Classes","text":"Type Name class PathManager \u8fd4\u56de\u9ed8\u8ba4\u8def\u5f84 <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/paths.h</code></p>"},{"location":"dictionary/paths_8h_source/","title":"File paths.h","text":"<p>File List &gt; include &gt; qqmusic &gt; utils &gt; paths.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef QQMUSIC_UTILS_CACHE_H\n#define QQMUSIC_UTILS_CACHE_H\n#include &lt;filesystem&gt;\n\nnamespace qqmusic::utils {\n\nnamespace fs = std::filesystem;\n\nclass PathManager {\npublic:\n    static PathManager&amp; get_instance();\n\n    void set_download_path(std::string_view path);\n    void set_download_path(const fs::path&amp; path);\n\n    void set_cache_path(std::string_view path);\n    void set_cache_path(const fs::path&amp; path);\n\n\n    void set_log_path(std::string_view path);\n    void set_log_path(const fs::path&amp; path);\n\n    [[nodiscard]] fs::path get_cache_path() const;\n\n    [[nodiscard]] fs::path get_download_path() const;\n\n    [[nodiscard]] fs::path get_log_path() const;\n\nprivate:\n    PathManager();\n    fs::path cache_path;\n    fs::path log_path;\n    fs::path download_path;\n};\n\n} // namespace qqmusic::utils\n\n#endif // !QQMUSIC_UTILS_CACHE_H\n</code></pre>"},{"location":"dictionary/qimei_8h/","title":"File qimei.h","text":"<p>FileList &gt; include &gt; qqmusic &gt; utils &gt; qimei.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/buffer.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/device.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"dictionary/qimei_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace utils \u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027"},{"location":"dictionary/qimei_8h/#classes","title":"Classes","text":"Type Name struct QimeiResult <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/qimei.h</code></p>"},{"location":"dictionary/qimei_8h_source/","title":"File qimei.h","text":"<p>File List &gt; include &gt; qqmusic &gt; utils &gt; qimei.h</p> <p>Go to the documentation of this file</p> <pre><code>/*-------------------------------------qqmusic/utils/qimei.h----------------------------------------\n * Provide interface to manage q-imei.\n *\n * Q-IMEI is IMEI used in qqmusic and other tencent services, it is required in\n * some interfaces which need device identification or have device limits\n *------------------------------------------------------------------------------------------------*/\n#ifndef QQMUSIC_UTILS_QIMEI_H\n#define QQMUSIC_UTILS_QIMEI_H\n\n#include &lt;qqmusic/result.h&gt;\n#include &lt;qqmusic/utils/buffer.h&gt;\n#include &lt;qqmusic/utils/device.h&gt;\n#include &lt;string&gt;\n\nnamespace qqmusic::utils {\n\nstruct QimeiResult {\n    std::string q16;\n    std::string q36;\n\n    NLOHMANN_DEFINE_TYPE_INTRUSIVE(QimeiResult, q16, q36);\n};\n\nqqmusic::Result&lt;QimeiResult&gt; get_qimei(qqmusic::utils::Device&amp; device, std::string_view version);\n\n} // namespace qqmusic::utils\n\n#endif // !QQMUSIC_UTILS_QIMEI_H\n</code></pre>"},{"location":"dictionary/session_8h/","title":"File session.h","text":"<p>FileList &gt; include &gt; qqmusic &gt; utils &gt; session.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/asio.hpp&gt;</code></li> <li><code>#include &lt;boost/asio/ssl.hpp&gt;</code></li> <li><code>#include &lt;boost/beast/http/dynamic_body.hpp&gt;</code></li> <li><code>#include &lt;boost/beast/http/message.hpp&gt;</code></li> <li><code>#include &lt;boost/beast/http/string_body.hpp&gt;</code></li> <li><code>#include &lt;boost/url.hpp&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;qqmusic/details/context.h&gt;</code></li> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/credential.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/device.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/qimei.h&gt;</code></li> <li><code>#include &lt;stack&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"dictionary/session_8h/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace utils \u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027"},{"location":"dictionary/session_8h/#classes","title":"Classes","text":"Type Name class Session \u4e0a\u4e0b\u6587 class SessionGuard \u4e00\u4e2a <code>RAII</code> \u98ce\u683c\u7684Session\u5207\u6362\u5668 class SessionManager \u5168\u5c40\u5355\u4f8b\u7684Session\u7ba1\u7406\u5668, \u8d1f\u8d23\u7ef4\u62a4\u5168\u5c40\u4e0a\u4e0b\u6587\u6808, \u5e76\u8d1f\u8d23 <code>session</code> \u5b9e\u4f8b\u7684\u751f\u6210 <p>The documentation for this class was generated from the following file <code>include/qqmusic/utils/session.h</code></p>"},{"location":"dictionary/session_8h_source/","title":"File session.h","text":"<p>File List &gt; include &gt; qqmusic &gt; utils &gt; session.h</p> <p>Go to the documentation of this file</p> <pre><code>/*----------------------------------qqmusic/utils/session.h-----------------------------------------\n *\n * @ file qqmusic/utils/session.h\n *\n * @brief \u5904\u7406\u7f51\u7edc\u8bf7\u6c42, \u4ee5\u53ca\u7ba1\u7406\u76f8\u5173\u7684\u4e0a\u4e0b\u6587\n *\n * @date 2025-3-23\n *\n *------------------------------------------------------------------------------------------------*/\n#ifndef QQMUSIC_UTILS_SESSION_H\n#define QQMUSIC_UTILS_SESSION_H\n\n#include &lt;boost/asio.hpp&gt;\n#include &lt;boost/asio/ssl.hpp&gt;\n#include &lt;boost/beast/http/dynamic_body.hpp&gt;\n#include &lt;boost/beast/http/message.hpp&gt;\n#include &lt;boost/beast/http/string_body.hpp&gt;\n#include &lt;boost/url.hpp&gt;\n#include &lt;memory&gt;\n#include &lt;qqmusic/details/context.h&gt;\n#include &lt;qqmusic/result.h&gt;\n#include &lt;qqmusic/utils/credential.h&gt;\n#include &lt;qqmusic/utils/device.h&gt;\n#include &lt;qqmusic/utils/qimei.h&gt;\n#include &lt;stack&gt;\n#include &lt;utility&gt;\n\nnamespace qqmusic::utils {\n\nnamespace http = boost::beast::http;\nnamespace asio = boost::asio;\nusing HttpResponse = http::response&lt;http::dynamic_body&gt;;\n\nclass SessionManager;\nclass SessionGuard;\n\nclass Session {\n    friend class SessionManager;\n    friend class SessionGuard;\n\npublic:\n    Session() = delete;\n\n    Session(qqmusic::details::NetworkContext&amp; nc,\n            std::shared_ptr&lt;asio::io_context&gt; ioc_ptr,\n            std::shared_ptr&lt;asio::ssl::context&gt; ssl_ctx_ptr,\n            std::mutex&amp; lock)\n        : lock(lock)\n        , global_ctx(nc)\n        , local_ctx(nc)\n        , ioc(std::move(ioc_ptr))\n        , ssl_ctx(std::move(ssl_ctx_ptr)) {};\n\n    qqmusic::details::NetworkContext&amp; get_context_ref();\n\n    void sync_global();\n\n    void update_local();\n\n    qqmusic::Task&lt;qqmusic::Result&lt;HttpResponse&gt;&gt; perform_request(\n        boost::url_view url, http::request&lt;http::string_body&gt;&amp; req, bool auto_redirecting = true);\n\nprivate:\n    qqmusic::Task&lt;qqmusic::Result&lt;HttpResponse&gt;&gt; handle_http_request(\n        boost::url_view url, http::request&lt;http::string_body&gt;&amp; req, bool auto_redirecting);\n\n    qqmusic::Task&lt;qqmusic::Result&lt;HttpResponse&gt;&gt; handle_https_request(\n        boost::url_view url, http::request&lt;http::string_body&gt;&amp; req, bool auto_redirecting);\n\n    std::mutex&amp; lock;\n\n    qqmusic::details::NetworkContext&amp; global_ctx;\n\n    qqmusic::details::NetworkContext local_ctx;\n\n    std::shared_ptr&lt;asio::io_context&gt; ioc;\n    std::shared_ptr&lt;asio::ssl::context&gt; ssl_ctx;\n};\n\nclass SessionManager {\npublic:\n    SessionManager(const SessionManager&amp;) = delete;\n    SessionManager operator=(const SessionManager&amp;) = delete;\n\n    Session get_session();\n\n    void set_context(const qqmusic::details::NetworkContext&amp; context);\n\n    static SessionManager&amp; get_instance();\n\n    void push_context(qqmusic::details::NetworkContext&amp;&amp; context);\n\n    void pop_context();\n\nprivate:\n    SessionManager();\n    std::mutex lock;\n\n    qqmusic::details::NetworkContext ctx;\n\n    std::stack&lt;qqmusic::details::NetworkContext&gt; context_stack;\n\n    std::shared_ptr&lt;asio::io_context&gt; ioc;\n    std::shared_ptr&lt;asio::ssl::context&gt; ssl_ctx;\n};\n\nclass SessionGuard {\npublic:\n    SessionGuard(SessionManager&amp; sm, Session s)\n        : session_manager(sm) {\n        session_manager.push_context(std::move(s.local_ctx));\n    };\n    SessionGuard(SessionManager&amp; sm, details::NetworkContext ctx)\n        : session_manager(sm) {\n        session_manager.push_context(std::move(ctx));\n    };\n    ~SessionGuard() { session_manager.pop_context(); };\n\nprivate:\n    SessionManager&amp; session_manager;\n};\n\n} // namespace qqmusic::utils\n\n#endif // !QQMUSIC_UTILS_SESSION_H\n</code></pre>"},{"location":"dictionary/dir_68267d1309a1af8e8297ef4c3efbcdba/","title":"Dir src","text":"<p>FileList &gt; src</p>"},{"location":"dictionary/dir_68267d1309a1af8e8297ef4c3efbcdba/#files","title":"Files","text":"Type Name file album.cc file login.cc file lyric.cc file mv.cc file search.cc file singer.cc file song.cc file songlist.cc file toplist.cc file user.cc"},{"location":"dictionary/dir_68267d1309a1af8e8297ef4c3efbcdba/#directories","title":"Directories","text":"Type Name dir crypto dir details dir utils <p>The documentation for this class was generated from the following file <code>src/</code></p>"},{"location":"dictionary/album_8cc/","title":"File album.cc","text":"<p>FileList &gt; src &gt; album.cc</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;format&gt;</code></li> <li><code>#include &lt;qqmusic/album.h&gt;</code></li> <li><code>#include &lt;qqmusic/details/api.h&gt;</code></li> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/common.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"dictionary/album_8cc/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic <p>The documentation for this class was generated from the following file <code>src/album.cc</code></p>"},{"location":"dictionary/album_8cc_source/","title":"File album.cc","text":"<p>File List &gt; src &gt; album.cc</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;format&gt;\n#include &lt;qqmusic/album.h&gt;\n#include &lt;qqmusic/details/api.h&gt;\n#include &lt;qqmusic/result.h&gt;\n#include &lt;qqmusic/utils/common.h&gt;\n#include &lt;string&gt;\n\nnamespace qqmusic {\n\nstd::string get_album_cover_url(std::string_view mid, CoverSize size) {\n    return std::format(\"https://y.gtimg.cn/music/photo_new/T002R{}x{}M000{}.jpg\",\n                       (int) size,\n                       (int) size,\n                       mid);\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_album_detail(std::string_view album_mid) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.musichallAlbum.AlbumInfoServer\", \"GetAlbumDetail\");\n    nlohmann::json params = {{\"albumMId\", album_mid}};\n\n    auto req_data = co_await api.prepare_request(params);\n    if (req_data.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_data.unwrapErr().get_error_enum()),\n            std::format(\"[get_album_detail] -- Error occurred when preparing request: `{}`\",\n                        req_data.unwrapErr().what())));\n    }\n\n    auto url = req_data.unwrap().url;\n    auto req = req_data.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_album_detail] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto resp = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (resp.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_album_detail] -- Error occurred when parsing reponse: `{}`\",\n                        resp.unwrapErr().what())));\n    }\n    auto data = resp.unwrap();\n    co_return Ok(data);\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_album_detail(uint64_t album_id) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.musichallAlbum.AlbumInfoServer\", \"GetAlbumDetail\");\n\n    nlohmann::json params = {{\"albumId\", album_id}};\n\n    auto req_data = co_await api.prepare_request(params);\n    if (req_data.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_data.unwrapErr().get_error_enum()),\n            std::format(\"[get_album_detail] -- Error occurred when preparing request: `{}`\",\n                        req_data.unwrapErr().what())));\n    }\n\n    auto url = req_data.unwrap().url;\n    auto req = req_data.unwrap().req;\n    auto response = co_await session.perform_request(url, req);\n    if (response.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_album_detail] -- Error occurred when performing request: `{}`\",\n                        response.unwrapErr().what())));\n    }\n\n    auto resp = api.parse_response(utils::resp2buf(response.unwrap()));\n    if (resp.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_album_detail] -- Error occurred when parsing reponse: `{}`\",\n                        resp.unwrapErr().what())));\n    }\n    auto data = resp.unwrap();\n    co_return Ok(data);\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_album_songs(std::string_view album_mid,\n                                             unsigned int num,\n                                             unsigned int page) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.musichallAlbum.AlbumSongList\", \"GetAlbumSongList\");\n\n    nlohmann::json params = {\n        {\"begin\", num * (page - 1)},\n        {\"num\", num},\n        {\"albumMid\", album_mid},\n    };\n\n    auto req_data = co_await api.prepare_request(params);\n    if (req_data.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_data.unwrapErr().get_error_enum()),\n            std::format(\"[get_album_songs] -- Error occurred when preparing request: `{}`\",\n                        req_data.unwrapErr().what())));\n    }\n\n    auto url = req_data.unwrap().url;\n    auto req = req_data.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_album_songs] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto resp = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (resp.isErr()) {\n        co_return Err(utils::Exception(response_res.unwrapErr()));\n    }\n    auto data = resp.unwrap();\n    co_return Ok(data[\"songList\"]);\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_album_songs(uint64_t album_id,\n                                             unsigned int num,\n                                             unsigned int page) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.musichallAlbum.AlbumSongList\", \"GetAlbumSongList\");\n\n    nlohmann::json params = {\n        {\"begin\", num * (page - 1)},\n        {\"num\", num},\n        {\"albumId\", album_id},\n    };\n\n    auto req_data = co_await api.prepare_request(params);\n    if (req_data.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_data.unwrapErr().get_error_enum()),\n            std::format(\"[get_album_songs] -- Error occurred when preparing request: `{}`\",\n                        req_data.unwrapErr().what())));\n    }\n\n    auto url = req_data.unwrap().url;\n    auto req = req_data.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_album_songs] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto resp = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (resp.isErr()) {\n        co_return Err(utils::Exception(response_res.unwrapErr()));\n    }\n    auto data = resp.unwrap();\n    co_return Ok(data[\"songList\"]);\n}\n\n} // namespace qqmusic\n</code></pre>"},{"location":"dictionary/dir_4261af1259721e3e39e0d2dd7354b511/","title":"Dir crypto","text":"<p>FileList &gt; crypto</p>"},{"location":"dictionary/dir_4261af1259721e3e39e0d2dd7354b511/#files","title":"Files","text":"Type Name file cipher_map.cc file cipher_rc4.cc file cipher_tea.cc file key_derive.cc file qmc.cc <p>The documentation for this class was generated from the following file <code>src/crypto/</code></p>"},{"location":"dictionary/cipher__map_8cc/","title":"File cipher_map.cc","text":"<p>FileList &gt; crypto &gt; cipher_map.cc</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;qqmusic/crypto/cipher_map.h&gt;</code></li> </ul>"},{"location":"dictionary/cipher__map_8cc/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace crypto <p>The documentation for this class was generated from the following file <code>src/crypto/cipher_map.cc</code></p>"},{"location":"dictionary/cipher__map_8cc_source/","title":"File cipher_map.cc","text":"<p>File List &gt; crypto &gt; cipher_map.cc</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;qqmusic/crypto/cipher_map.h&gt;\n\nnamespace qqmusic::crypto {\n\nMapCipher::MapCipher(const std::vector&lt;uint8_t&gt;&amp; key)\n    : key(key) {\n    if (key.size() == 0) {\n        std::cout &lt;&lt; \"[MapCipher constructor failed] key size is 0\" &lt;&lt; std::endl;\n    }\n}\n\nvoid MapCipher::decrypt(qqmusic::utils::buffer&amp; buf, size_t offset) {\n    const auto rotate = [](uint8_t value, uint8_t bits) {\n        const uint8_t r = (bits + 4) % 8;\n        return (value &lt;&lt; r) | (value &gt;&gt; (8 - r));\n    };\n\n    for (size_t i = 0; i &lt; buf.size(); ++i) {\n        const size_t cur_offset = offset + i;\n        size_t final_offset = cur_offset;\n        if (cur_offset &gt; 0x7FFF) {\n            final_offset %= 0x7FFF;\n        }\n        const auto idx = (final_offset * final_offset + 71214) % key.size();\n        const uint8_t mask = rotate(key[idx], static_cast&lt;uint8_t&gt;(idx) &amp; 0x07);\n        buf[i] ^= mask;\n    }\n}\n\n} // namespace qqmusic::crypto\n</code></pre>"},{"location":"dictionary/cipher__rc4_8cc/","title":"File cipher_rc4.cc","text":"<p>FileList &gt; crypto &gt; cipher_rc4.cc</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;qqmusic/crypto/cipher_rc4.h&gt;</code></li> </ul>"},{"location":"dictionary/cipher__rc4_8cc/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace crypto <p>The documentation for this class was generated from the following file <code>src/crypto/cipher_rc4.cc</code></p>"},{"location":"dictionary/cipher__rc4_8cc_source/","title":"File cipher_rc4.cc","text":"<p>File List &gt; crypto &gt; cipher_rc4.cc</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;qqmusic/crypto/cipher_rc4.h&gt;\n\nnamespace qqmusic::crypto {\nRC4Cipher::RC4Cipher(const std::vector&lt;uint8_t&gt;&amp; key)\n    : key(key) {\n    if (key.size() == 0) {\n        std::cout &lt;&lt; \"[RC4Cipher constructor failed] key size is 0\" &lt;&lt; std::endl;\n    }\n}\n\nvoid RC4Cipher::decrypt(qqmusic::utils::buffer&amp; buf, size_t offset) {\n    // \u521d\u59cb\u5316S\u76d2\n    std::vector&lt;uint8_t&gt; box(key.size());\n    std::iota(box.begin(), box.end(), 0);\n\n    // KSA\u5bc6\u94a5\u8c03\u5ea6\u7b97\u6cd5\n    size_t j = 0;\n    for (size_t i = 0; i &lt; key.size(); ++i) {\n        j = (j + box[i] + key[i % key.size()]) % key.size();\n        std::swap(box[i], box[j]);\n    }\n\n    // \u54c8\u5e0c\u503c\u8ba1\u7b97\n    uint32_t hash_base = 1;\n    for (auto k : key) {\n        if (k == 0)\n            continue;\n        const auto next_hash = hash_base * k;\n        if (next_hash == 0 || next_hash &lt;= hash_base)\n            break;\n        hash_base = next_hash;\n    }\n\n    // \u89e3\u5bc6\u4e3b\u903b\u8f91\n    constexpr size_t SegmentSize = 5120;\n    constexpr size_t FirstSegmentSize = 128;\n\n    auto enc_first = [&amp;](auto&amp; buf, auto len, auto off) {\n        for (size_t i = 0; i &lt; len; ++i) {\n            const auto seg_id = (off + i) / SegmentSize;\n            const auto seed = key[seg_id % key.size()];\n            const auto idx = static_cast&lt;double&gt;(hash_base) / ((seg_id + 1) * seed) * 100.0;\n            const auto skip = static_cast&lt;size_t&gt;(idx) % key.size();\n            buf[i] ^= key[skip];\n        }\n    };\n\n    auto enc_regular = [&amp;](auto&amp; buf, auto len, auto off) {\n        auto local_box = box;\n        int j = 0, k = 0;\n        const int seg_num = off / SegmentSize;\n        const int seed = key[seg_num % key.size()];\n        const int idx = static_cast&lt;double&gt;(hash_base) / ((seg_num + 1) * seed) * 100.0;\n        const int skip_len = (off % SegmentSize) + (static_cast&lt;size_t&gt;(idx) % key.size());\n\n        for (int i = -static_cast&lt;int&gt;(skip_len); i &lt; static_cast&lt;int&gt;(len); ++i) {\n            j = (j + i) % static_cast&lt;int&gt;(key.size());\n            k = (local_box[j] + k) % static_cast&lt;int&gt;(key.size());\n            std::swap(local_box[j], local_box[k]);\n            if (i &gt;= 0) {\n                buf[i] ^= local_box[(local_box[j] + local_box[k]) % key.size()];\n            }\n        }\n    };\n    auto process_segment = [&amp;](size_t block_size, auto enc_func) -&gt; size_t {\n        const size_t chunk = std::min(block_size, buf.size());\n        if (chunk == 0)\n            return true;\n\n        enc_func(buf, chunk, offset);\n        return chunk;\n    };\n\n    size_t total_processed = 0;\n    const size_t total_size = buf.size();\n\n    while (total_processed &lt; total_size) {\n        size_t processed = 0;\n\n        // \u5904\u7406\u7b2c\u4e00\u6bb5\n        if (offset &lt; FirstSegmentSize) {\n            const size_t remaining = FirstSegmentSize - offset;\n            processed = process_segment(remaining, enc_first);\n            total_processed += processed;\n            offset += processed;\n            if (processed &lt; remaining)\n                break; // \u6570\u636e\u4e0d\u8db3\u65f6\u9000\u51fa\n        }\n\n        // \u5904\u7406\u5e38\u89c4\u6bb5\n        const size_t remaining = total_size - total_processed;\n        processed = process_segment(std::min(remaining, SegmentSize), enc_regular);\n        total_processed += processed;\n        offset += processed;\n    }\n}\n\n} // namespace qqmusic::crypto\n</code></pre>"},{"location":"dictionary/cipher__tea_8cc/","title":"File cipher_tea.cc","text":"<p>FileList &gt; crypto &gt; cipher_tea.cc</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;qqmusic/crypto/cipher_tea.h&gt;</code></li> </ul>"},{"location":"dictionary/cipher__tea_8cc/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace crypto <p>The documentation for this class was generated from the following file <code>src/crypto/cipher_tea.cc</code></p>"},{"location":"dictionary/cipher__tea_8cc_source/","title":"File cipher_tea.cc","text":"<p>File List &gt; crypto &gt; cipher_tea.cc</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;qqmusic/crypto/cipher_tea.h&gt;\n\nnamespace qqmusic::crypto {\n\nvoid TeaCipher::decrypt(qqmusic::utils::buffer&amp; buf,\n                        size_t offset,\n                        const std::vector&lt;uint8_t&gt;&amp; key) {\n    constexpr int rounds = 32;\n\n    auto load_u32 = [](const uint8_t* p) {\n        return (static_cast&lt;uint32_t&gt;(p[3]) &lt;&lt; 24) | (static_cast&lt;uint32_t&gt;(p[2]) &lt;&lt; 16)\n               | (static_cast&lt;uint32_t&gt;(p[1]) &lt;&lt; 8) | static_cast&lt;uint32_t&gt;(p[0]);\n    };\n\n    auto store_u32 = [](uint8_t* p, uint32_t v) {\n        p[0] = v &amp; 0xFF;\n        p[1] = (v &gt;&gt; 8) &amp; 0xFF;\n        p[2] = (v &gt;&gt; 16) &amp; 0xFF;\n        p[3] = (v &gt;&gt; 24) &amp; 0xFF;\n    };\n\n    uint8_t* block = buf.data() + offset;\n    uint32_t v0 = load_u32(block);\n    uint32_t v1 = load_u32(block + 4);\n    uint32_t sum = 0x9E3779B9 * rounds;\n\n    for (int i = 0; i &lt; rounds; i++) {\n        v1 -= ((v0 &lt;&lt; 4) + key[8 + (sum &gt;&gt; 11 &amp; 3)]) ^ (v0 + sum)\n              ^ ((v0 &gt;&gt; 5) + key[12 + (sum &gt;&gt; 11 &amp; 3)]);\n        v0 -= ((v1 &lt;&lt; 4) + key[0 + (sum &amp; 3)]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + key[4 + (sum &amp; 3)]);\n        sum -= 0x9E3779B9;\n    }\n\n    store_u32(block, v0);\n    store_u32(block + 4, v1);\n}\n\n} // namespace qqmusic::crypto\n</code></pre>"},{"location":"dictionary/key__derive_8cc/","title":"File key_derive.cc","text":"<p>FileList &gt; crypto &gt; key_derive.cc</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;botan/base64.h&gt;</code></li> <li><code>#include &lt;botan/secmem.h&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;format&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;qqmusic/crypto/cipher_tea.h&gt;</code></li> <li><code>#include &lt;qqmusic/crypto/key_derive.h&gt;</code></li> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/buffer.h&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"dictionary/key__derive_8cc/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace crypto <p>The documentation for this class was generated from the following file <code>src/crypto/key_derive.cc</code></p>"},{"location":"dictionary/key__derive_8cc_source/","title":"File key_derive.cc","text":"<p>File List &gt; crypto &gt; key_derive.cc</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;botan/base64.h&gt;\n#include &lt;botan/secmem.h&gt;\n#include &lt;cmath&gt;\n#include &lt;format&gt;\n#include &lt;iostream&gt;\n#include &lt;qqmusic/crypto/cipher_tea.h&gt;\n#include &lt;qqmusic/crypto/key_derive.h&gt;\n#include &lt;qqmusic/result.h&gt;\n#include &lt;qqmusic/utils/buffer.h&gt;\n#include &lt;vector&gt;\n\nnamespace qqmusic::crypto {\n\nqqmusic::utils::buffer KeyDerive::derive(qqmusic::utils::buffer&amp;&amp; raw_key) {\n    auto base64_raw = Botan::base64_decode(std::string(raw_key.begin(), raw_key.end()));\n    std::vector&lt;uint8_t&gt; raw_key_dec(base64_raw.begin(), base64_raw.end());\n\n    // V2 \u524d\u7f00\u5904\u7406\n    static constexpr std::string_view V2_prefix = \"QQMusic EncV2,Key:\";\n    if (std::string_view(reinterpret_cast&lt;const char*&gt;(raw_key_dec.data()), raw_key_dec.size())\n            .starts_with(V2_prefix)) {\n        auto V2_res = derive_V2(\n            std::vector&lt;uint8_t&gt;({raw_key_dec.begin() + V2_prefix.size(), raw_key_dec.end()}));\n        raw_key_dec = V2_res;\n    }\n\n    return derive_V1(std::move(raw_key_dec));\n}\n\nqqmusic::utils::buffer KeyDerive::derive_V1(qqmusic::utils::buffer&amp;&amp; raw_key_dec) {\n    // Check key length (minimum 16 bytes)\n    if (raw_key_dec.size() &lt; 16) {\n        std::cout &lt;&lt; std::format(\"[KeyDerive::derive_V1] -- raw_key_dec size {} &lt; 16\",\n                                 raw_key_dec.size())\n                  &lt;&lt; std::endl;\n        return {};\n    }\n\n    const auto simple_key = makeSimpleKey(106, 8);\n\n    // Build TEA key\n    std::vector&lt;uint8_t&gt; tea_key(16);\n    for (size_t i = 0; i &lt; 8; ++i) {\n        tea_key.push_back(simple_key[i]);\n        tea_key.push_back(raw_key_dec[i]);\n    }\n\n    // Decrypt core data\n    auto raw_key_dec_headless = qqmusic::utils::buffer(\n        std::vector&lt;uint8_t&gt;(raw_key_dec.begin() + 8, raw_key_dec.end()));\n    const auto decrypt_res = decrypt_tencent_tea(std::move(raw_key_dec_headless), tea_key);\n\n    // Concatenate final result\n    std::vector&lt;uint8_t&gt; res;\n    res.reserve(8 + decrypt_res.size());\n    res.insert(res.end(), raw_key_dec.begin(), raw_key_dec.begin() + 8);\n    res.insert(res.end(), decrypt_res.begin(), decrypt_res.end());\n\n    return res;\n}\n\nqqmusic::utils::buffer KeyDerive::derive_V2(qqmusic::utils::buffer raw) {\n    auto first_buf = decrypt_tencent_tea(std::move(raw), DeriveV2Key1);\n    auto second_buf = decrypt_tencent_tea(std::move(first_buf), DeriveV2Key2);\n\n    // Base64\n    auto decode_buf = second_buf;\n    const std::string encoded(decode_buf.begin(), decode_buf.end());\n    auto base64_res = Botan::base64_decode(encoded);\n    std::vector&lt;uint8_t&gt; res(base64_res.begin(), base64_res.end());\n    return res;\n}\n\nqqmusic::utils::buffer KeyDerive::decrypt_tencent_tea(qqmusic::utils::buffer&amp;&amp; in_buf,\n                                                      const std::vector&lt;uint8_t&gt;&amp; key) {\n    constexpr size_t salt_len = 2;\n    constexpr size_t zero_len = 7;\n\n    // Block validation\n    if (in_buf.size() % 8 != 0 || in_buf.size() &lt; 16) {\n        std::cout &lt;&lt; std::format(\"[KeyDerive::decrypt_tencent_tea] -- in_buf len {} &lt; 16\",\n                                 in_buf.size())\n                  &lt;&lt; std::endl;\n        return {};\n    }\n\n    // Decrypt first block\n    qqmusic::utils::buffer dest_buf(8);\n    for (size_t offset = 0; offset &lt; dest_buf.size(); offset += 8) {\n        qqmusic::crypto::TeaCipher::decrypt(in_buf, offset, key);\n    }\n    const uint8_t pad_len = dest_buf[0] &amp; 0x7;\n    const size_t out_len = in_buf.size() - 1 - pad_len - salt_len - zero_len;\n\n    auto xor8Bytes = [](auto&amp; dst, const auto&amp; a, const auto&amp; b) {\n        for (int i = 0; i &lt; 8; ++i) {\n            dst[i] = a[i] ^ b[i];\n        }\n    };\n\n    std::vector&lt;uint8_t&gt; out(out_len);\n    std::array&lt;uint8_t, 8&gt; iv_prev{}, ivCur{};\n    std::copy_n(in_buf.begin(), 8, ivCur.begin());\n\n    // Decrypt main blocks\n    size_t in_buf_pos = 8;\n    size_t dest_idx = 1 + pad_len;\n\n    auto crypto_block = [&amp;] {\n        iv_prev = ivCur;\n        std::copy_n(in_buf.begin() + static_cast&lt;long&gt;(in_buf_pos), 8, ivCur.begin());\n\n        xor8Bytes(dest_buf, dest_buf, in_buf.data() + in_buf_pos);\n        for (size_t offset = 0; offset &lt; dest_buf.size(); offset += 8) {\n            qqmusic::crypto::TeaCipher::decrypt(dest_buf, offset, key);\n        }\n\n        in_buf_pos += 8;\n        dest_idx = 0;\n    };\n\n    // Salt process\n    for (size_t i = 0; i &lt; salt_len;) {\n        if (dest_idx &lt; 8)\n            ++dest_idx, ++i;\n        else if (dest_idx == 8)\n            crypto_block();\n    }\n\n    // main decrypt\n    size_t out_pos = 0;\n    while (out_pos &lt; out_len) {\n        if (dest_idx &lt; 8) {\n            out[out_pos++] = dest_buf[dest_idx] ^ iv_prev[dest_idx];\n            dest_idx++;\n        } else if (dest_idx == 8) {\n            crypto_block();\n        }\n    }\n\n    // Zero check\n    for (size_t i = 0; i &lt; zero_len; ++i) {\n        if (dest_buf[dest_idx] != iv_prev[dest_idx]) {\n            std::cout &lt;&lt; \"[KeyDerive::decrypt_tencent_tea] -- zero check failed\" &lt;&lt; std::endl;\n            return {};\n        }\n        ++dest_idx;\n    }\n\n    return out;\n}\n\n} // namespace qqmusic::crypto\n</code></pre>"},{"location":"dictionary/qmc_8cc/","title":"File qmc.cc","text":"<p>FileList &gt; crypto &gt; qmc.cc</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;qqmusic/crypto/cipher_map.h&gt;</code></li> <li><code>#include &lt;qqmusic/crypto/cipher_rc4.h&gt;</code></li> <li><code>#include &lt;qqmusic/crypto/cipher_tea.h&gt;</code></li> <li><code>#include &lt;qqmusic/crypto/key_derive.h&gt;</code></li> <li><code>#include &lt;qqmusic/crypto/qmc.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/buffer.h&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"dictionary/qmc_8cc/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace crypto <p>The documentation for this class was generated from the following file <code>src/crypto/qmc.cc</code></p>"},{"location":"dictionary/qmc_8cc_source/","title":"File qmc.cc","text":"<p>File List &gt; crypto &gt; qmc.cc</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;qqmusic/crypto/cipher_map.h&gt;\n#include &lt;qqmusic/crypto/cipher_rc4.h&gt;\n#include &lt;qqmusic/crypto/cipher_tea.h&gt;\n#include &lt;qqmusic/crypto/key_derive.h&gt;\n#include &lt;qqmusic/crypto/qmc.h&gt;\n#include &lt;qqmusic/utils/buffer.h&gt;\n#include &lt;utility&gt;\n\nnamespace qqmusic::crypto {\n\nDecoder::Decoder(std::string&amp;&amp; ekey)\n    : ekey((uint8_t*) ekey.data(), ekey.size()){};\n\nbool read2buf(qqmusic::utils::buffer&amp;&amp; buf) {\n    qqmusic::utils::buffer buf_in(std::move(buf));\n    if (buf_in.size() &lt; 0) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\nbool Decoder::decrypt() {\n    // \u89e3\u5bc6\u5bc6\u94a5\n    auto key = qqmusic::crypto::KeyDerive::derive(std::move(ekey));\n\n    // \u521d\u59cb\u5316\u89e3\u5bc6\u7b97\u6cd5\n    if (key.size() &gt; 300) {\n        cipher = std::make_unique&lt;RC4Cipher&gt;(key);\n        cipher-&gt;decrypt(buf_in, 0);\n        buf_out.insert(buf_out.end(), buf_in.begin(), buf_in.end());\n    } else if (!key.empty()) {\n        cipher = std::make_unique&lt;MapCipher&gt;(key);\n        cipher-&gt;decrypt(buf_in, 0);\n        buf_out.insert(buf_out.end(), buf_in.begin(), buf_in.end());\n    } else {\n        std::cout &lt;&lt; \"Decoder decrypt failed! key size abnormal!\" &lt;&lt; std::endl;\n        return false;\n    }\n    return true;\n}\n\n} // namespace qqmusic::crypto\n</code></pre>"},{"location":"dictionary/dir_b485ae80868baed16097635ed27c0024/","title":"Dir details","text":"<p>FileList &gt; details</p>"},{"location":"dictionary/dir_b485ae80868baed16097635ed27c0024/#files","title":"Files","text":"Type Name file api.cc file tripledes.cc <p>The documentation for this class was generated from the following file <code>src/details/</code></p>"},{"location":"dictionary/api_8cc/","title":"File api.cc","text":"<p>FileList &gt; details &gt; api.cc</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/beast/http/message.hpp&gt;</code></li> <li><code>#include &lt;cstdlib&gt;</code></li> <li><code>#include &lt;nlohmann/json.hpp&gt;</code></li> <li><code>#include &lt;qqmusic/details/api.h&gt;</code></li> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/common.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"dictionary/api_8cc/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace details <p>The documentation for this class was generated from the following file <code>src/details/api.cc</code></p>"},{"location":"dictionary/api_8cc_source/","title":"File api.cc","text":"<p>File List &gt; details &gt; api.cc</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;boost/beast/http/message.hpp&gt;\n#include &lt;cstdlib&gt;\n#include &lt;nlohmann/json.hpp&gt;\n#include &lt;qqmusic/details/api.h&gt;\n#include &lt;qqmusic/result.h&gt;\n#include &lt;qqmusic/utils/common.h&gt;\n#include &lt;string&gt;\n\nnamespace qqmusic::details {\n\nqqmusic::Result&lt;nlohmann::json&gt; Api::parse_response(utils::buffer&amp;&amp; response) {\n    try {\n        nlohmann::json resp_json = nlohmann::json::parse(response);\n        nlohmann::json req_data;\n        int64_t rc = resp_json[\"code\"].get&lt;int64_t&gt;();\n        switch (rc) {\n        case 0:\n            /* FIXME: discarded req_data[\"code\"] value*/\n            req_data = resp_json[module + \".\" + method];\n            return Ok(req_data[\"data\"]);\n        case 2000:\n            return Err(qqmusic::utils::Exception(qqmusic::utils::Exception::SignInvalidError,\n                                                 \"[parse_response] -- Sign is invalid\"));\n        case 1000:\n            return Err(qqmusic::utils::Exception(qqmusic::utils::Exception::CredendialExpiredError,\n                                                 \"[parse_response] -- Credential is expired\"));\n        default:\n            return Err(qqmusic::utils::Exception(\n                qqmusic::utils::Exception::ResponseCodeError,\n                std::format(\"[parse_response] -- Unexpected response code: {}\", rc)));\n        }\n    } catch (const std::exception&amp; e) {\n        return Err(qqmusic::utils::Exception(\n            qqmusic::utils::Exception::JsonError,\n            std::format(\"[parse_response] -- Error occurred when parsing json: {}\", e.what())));\n    }\n}\n\nqqmusic::Task&lt;qqmusic::Result&lt;RequestParam&gt;&gt; Api::prepare_request(const nlohmann::json&amp; params,\n                                                                  bool verify) {\n    try {\n        auto&amp; context = session.get_context_ref();\n        common = {\n            {\"cv\", context.api_config.version_code},\n            {\"v\", context.api_config.version_code},\n            {\"QIMEI36\", context.qimei.q36},\n            {\"ct\", \"11\"},\n            {\"tmeAppID\", \"qqmusic\"},\n            {\"format\", \"json\"},\n            {\"inCharset\", \"utf-8\"},\n            {\"outCharset\", \"utf-8\"},\n            {\"uid\", \"3931641530\"},\n        };\n\n        /* need credential only if verify is true */\n        if (verify) {\n            if (credential.is_valid()) {\n                /* set credential relative fields */\n                common.push_back({\"qq\", std::to_string(credential.musicid)});\n                common.push_back({\"authst\", credential.musickey});\n                common.push_back({\"tmeLoginType\", std::to_string(credential.loginType)});\n            } else {\n                /* Error: Not given valid credential */\n                co_return Err(utils::Exception(utils::Exception::CredentialInvalidError,\n                                               \"[Api::prepare_request] -- `verify` is set, but not \"\n                                               \"provided with valid credential\"));\n            }\n        }\n\n        /*Build request data*/\n        nlohmann::json request_data = {\n            {\"comm\", common},\n            {module + '.' + method, {{\"module\", module}, {\"method\", method}, {\"param\", params}}},\n        };\n\n        boost::url url{context.api_config.enable_sign ? context.api_config.enc_endpoint\n                                                      : context.api_config.endpoint};\n\n        if (context.api_config.enable_sign) {\n            /*set request param sign*/\n            url.set_params({{\"sign\", utils::sign(request_data)}});\n        }\n\n        /*set cookie*/\n        context.cookies.set({.domain = \"qq.com\",\n                             .path = \"/\",\n                             .key = \"uin\",\n                             .value = std::to_string(credential.musicid)});\n        context.cookies.set(\n            {.domain = \"qq.com\", .path = \"/\", .key = \"qqmusic_key\", .value = credential.musickey});\n        context.cookies.set(\n            {.domain = \"qq.com\", .path = \"/\", .key = \"qm_keyst\", .value = credential.musickey});\n        context.cookies.set({.domain = \"qq.com\",\n                             .path = \"/\",\n                             .key = \"tmeLoginType\",\n                             .value = std::to_string(credential.loginType)});\n\n        session.sync_global();\n\n        http::request&lt;http::string_body&gt; req{http::verb::post, url, 11};\n        req.set(http::field::host, url.host());\n        req.set(http::field::accept, \"*/*\");\n        /*use raw buffer instead of compressed buffer when debuging*/\n        req.set(http::field::accept_encoding, \"identity\");\n        req.set(http::field::connection, \"keep-alive\");\n        req.set(http::field::referer, \"y.qq.com\");\n        req.set(http::field::user_agent,\n                \"Mozilla/5.0 (Windows NT 11.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) \"\n                \"Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.54\");\n        req.set(http::field::content_type, \"application/json\");\n        req.body() = nlohmann::to_string(request_data);\n\n        auto cookie_res = context.cookies.serialize(\"qq.com\");\n        if (cookie_res.isErr()) {\n            co_return Err(utils::Exception(\n                utils::Exception::JsonError,\n                std::format(\"[Api::prepare_request] -- Cannot serialize cookie: `{}`\",\n                            cookie_res.unwrapErr().what())));\n        }\n        req.set(http::field::cookie, cookie_res.unwrap());\n        co_return Ok(RequestParam{url, req});\n\n    } catch (const std::exception&amp; e) {\n        co_return Err(\n            utils::Exception(utils::Exception::UnknownError,\n                             std::format(\"[Api::prepare_request] -- UnknownError occurred: `{}`\",\n                                         e.what())));\n    }\n}\n\n} // namespace qqmusic::details\n</code></pre>"},{"location":"dictionary/tripledes_8cc/","title":"File tripledes.cc","text":"<p>FileList &gt; details &gt; tripledes.cc</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdio&gt;</code></li> <li><code>#include &lt;qqmusic/details/tripledes.h&gt;</code></li> </ul>"},{"location":"dictionary/tripledes_8cc/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace details <p>The documentation for this class was generated from the following file <code>src/details/tripledes.cc</code></p>"},{"location":"dictionary/tripledes_8cc_source/","title":"File tripledes.cc","text":"<p>File List &gt; details &gt; tripledes.cc</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;cstdio&gt;\n#include &lt;qqmusic/details/tripledes.h&gt;\n\nnamespace qqmusic::details {\n\nstatic std::vector&lt;std::vector&lt;uint32_t&gt;&gt; key_schedule(const uint8_t* key_head,\n                                                       size_t key_size,\n                                                       tripledes_crypt_mode mode);\n\nstatic uint32_t bitnum(const uint8_t* head, size_t size, uint32_t b, uint32_t c);\n\nstatic uint32_t bitnum_intl(uint32_t a, uint32_t b, uint32_t c);\n\nstatic uint32_t bitnum_intr(uint32_t a, uint32_t b, uint32_t c);\n\nstatic void crypt(utils::buffer&amp; buf, std::vector&lt;std::vector&lt;uint32_t&gt;&gt; key);\n\nstatic void initial_permutation(uint32_t* a, uint32_t* b, utils::buffer&amp; buf);\n\nstatic void inverse_permutation(uint32_t a, uint32_t b, utils::buffer&amp; buf);\n\nstatic uint32_t transform(uint32_t state, std::vector&lt;uint32_t&gt; key);\n\nstatic uint32_t sbox_bit(uint32_t a);\n\n// extern api\ntripledes_key_schedule tripledes_key_setup(const uint8_t* key_head,\n                                           size_t key_size,\n                                           tripledes_crypt_mode mode) {\n    std::vector&lt;std::vector&lt;std::vector&lt;uint32_t&gt;&gt;&gt; res;\n\n    if (mode == tripledes_crypt_mode::encrypt) {\n        res.push_back(key_schedule(key_head, key_size, tripledes_crypt_mode::encrypt));\n        res.push_back(key_schedule(key_head + 8, key_size - 8, tripledes_crypt_mode::decrypt));\n        res.push_back(key_schedule(key_head + 16, key_size - 16, tripledes_crypt_mode::encrypt));\n    } else {\n        res.push_back(key_schedule(key_head + 16, key_size - 16, tripledes_crypt_mode::decrypt));\n        res.push_back(key_schedule(key_head + 8, key_size - 8, tripledes_crypt_mode::encrypt));\n        res.push_back(key_schedule(key_head, key_size, tripledes_crypt_mode::decrypt));\n    }\n\n    return res;\n}\n\n// extern api\nvoid tripledes_crypt(utils::buffer&amp; buf_in,\n                     utils::buffer&amp; buf_out,\n                     tripledes_key_schedule key_schedule) {\n    for (int i = 0; i &lt; 3; ++i) {\n        crypt(buf_in, key_schedule[i]);\n    }\n\n    // insert processed data into output buffer\n    buf_out.append(buf_in.data(), buf_in.size());\n}\n\nstatic std::vector&lt;std::vector&lt;uint32_t&gt;&gt; key_schedule(const uint8_t* key_head,\n                                                       size_t key_size,\n                                                       tripledes_crypt_mode mode) {\n    std::vector&lt;std::vector&lt;uint32_t&gt;&gt; schedule(16, std::vector&lt;uint32_t&gt;(6, 0L));\n    const uint32_t key_rnd_shift[] = {1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1};\n    const uint32_t key_perm_c[] = {56, 48, 40, 32, 24, 16, 8,  0,  57, 49, 41, 33, 25, 17,\n                                   9,  1,  58, 50, 42, 34, 26, 18, 10, 2,  59, 51, 43, 35};\n    const uint32_t key_perm_d[] = {62, 54, 46, 38, 30, 22, 14, 6,  61, 53, 45, 37, 29, 21,\n                                   13, 5,  60, 52, 44, 36, 28, 20, 12, 4,  27, 19, 11, 3};\n    const uint32_t key_compression[] = {13, 16, 10, 23, 0,  4,  2,  27, 14, 5,  20, 9,\n                                        22, 18, 11, 3,  25, 7,  15, 6,  26, 19, 12, 1,\n                                        40, 51, 30, 36, 46, 54, 29, 39, 50, 44, 32, 47,\n                                        43, 48, 38, 55, 33, 52, 45, 41, 49, 35, 28, 31};\n\n    uint32_t c = 0, d = 0;\n    for (int i = 0; i &lt; 28; ++i) {\n        c += bitnum(key_head, key_size, key_perm_c[i], 31 - i);\n        d += bitnum(key_head, key_size, key_perm_d[i], 31 - i);\n    }\n\n    for (int i = 0; i &lt; 16; ++i) {\n        c = ((c &lt;&lt; key_rnd_shift[i]) | (c &gt;&gt; (28 - key_rnd_shift[i]))) &amp; 0xfffffff0;\n        d = ((d &lt;&lt; key_rnd_shift[i]) | (d &gt;&gt; (28 - key_rnd_shift[i]))) &amp; 0xfffffff0;\n\n        int togen = mode == tripledes_crypt_mode::decrypt ? 15 - i : i;\n\n        for (int j = 0; j &lt; 6; ++j) {\n            schedule[togen][j] = 0;\n        }\n\n        for (int j = 0; j &lt; 24; ++j) {\n            schedule[togen][j / 8] |= bitnum_intr(c, key_compression[j], 7 - (j % 8));\n        }\n\n        for (int j = 24; j &lt; 48; ++j) {\n            schedule[togen][j / 8] |= bitnum_intr(d, key_compression[j] - 27, 7 - (j % 8));\n        }\n    }\n\n    return schedule;\n}\n\nstatic uint32_t bitnum(const uint8_t* head, size_t size, uint32_t b, uint32_t c) {\n    return ((head[(b / 32) * 4 + 3 - (b % 32) / 8] &gt;&gt; (7 - b % 8)) &amp; 1) &lt;&lt; c;\n}\n\nstatic uint32_t bitnum_intl(uint32_t a, uint32_t b, uint32_t c) {\n    return ((a &lt;&lt; b) &amp; 0x80000000) &gt;&gt; c;\n}\n\nstatic uint32_t bitnum_intr(uint32_t a, uint32_t b, uint32_t c) {\n    return ((a &gt;&gt; (31 - b)) &amp; 1) &lt;&lt; c;\n}\n\nstatic void crypt(utils::buffer&amp; buf, std::vector&lt;std::vector&lt;uint32_t&gt;&gt; key) {\n    uint32_t a = 0, b = 0;\n    initial_permutation(&amp;a, &amp;b, buf);\n\n    for (int i = 0; i &lt; 15; ++i) {\n        long tmp = b;\n        b = transform(b, key[i]) ^ a;\n        a = tmp;\n    }\n    a = transform(b, key[15]) ^ a;\n\n    inverse_permutation(a, b, buf);\n}\n\nstatic void initial_permutation(uint32_t* a, uint32_t* b, utils::buffer&amp; buf) {\n    uint8_t* input_data = buf.data();\n    size_t size = buf.size();\n\n    *a = (bitnum(input_data, size, 57, 31) | bitnum(input_data, size, 49, 30)\n          | bitnum(input_data, size, 41, 29) | bitnum(input_data, size, 33, 28)\n          | bitnum(input_data, size, 25, 27) | bitnum(input_data, size, 17, 26)\n          | bitnum(input_data, size, 9, 25) | bitnum(input_data, size, 1, 24)\n          | bitnum(input_data, size, 59, 23) | bitnum(input_data, size, 51, 22)\n          | bitnum(input_data, size, 43, 21) | bitnum(input_data, size, 35, 20)\n          | bitnum(input_data, size, 27, 19) | bitnum(input_data, size, 19, 18)\n          | bitnum(input_data, size, 11, 17) | bitnum(input_data, size, 3, 16)\n          | bitnum(input_data, size, 61, 15) | bitnum(input_data, size, 53, 14)\n          | bitnum(input_data, size, 45, 13) | bitnum(input_data, size, 37, 12)\n          | bitnum(input_data, size, 29, 11) | bitnum(input_data, size, 21, 10)\n          | bitnum(input_data, size, 13, 9) | bitnum(input_data, size, 5, 8)\n          | bitnum(input_data, size, 63, 7) | bitnum(input_data, size, 55, 6)\n          | bitnum(input_data, size, 47, 5) | bitnum(input_data, size, 39, 4)\n          | bitnum(input_data, size, 31, 3) | bitnum(input_data, size, 23, 2)\n          | bitnum(input_data, size, 15, 1) | bitnum(input_data, size, 7, 0));\n\n    *b = (bitnum(input_data, size, 56, 31) | bitnum(input_data, size, 48, 30)\n          | bitnum(input_data, size, 40, 29) | bitnum(input_data, size, 32, 28)\n          | bitnum(input_data, size, 24, 27) | bitnum(input_data, size, 16, 26)\n          | bitnum(input_data, size, 8, 25) | bitnum(input_data, size, 0, 24)\n          | bitnum(input_data, size, 58, 23) | bitnum(input_data, size, 50, 22)\n          | bitnum(input_data, size, 42, 21) | bitnum(input_data, size, 34, 20)\n          | bitnum(input_data, size, 26, 19) | bitnum(input_data, size, 18, 18)\n          | bitnum(input_data, size, 10, 17) | bitnum(input_data, size, 2, 16)\n          | bitnum(input_data, size, 60, 15) | bitnum(input_data, size, 52, 14)\n          | bitnum(input_data, size, 44, 13) | bitnum(input_data, size, 36, 12)\n          | bitnum(input_data, size, 28, 11) | bitnum(input_data, size, 20, 10)\n          | bitnum(input_data, size, 12, 9) | bitnum(input_data, size, 4, 8)\n          | bitnum(input_data, size, 62, 7) | bitnum(input_data, size, 54, 6)\n          | bitnum(input_data, size, 46, 5) | bitnum(input_data, size, 38, 4)\n          | bitnum(input_data, size, 30, 3) | bitnum(input_data, size, 22, 2)\n          | bitnum(input_data, size, 14, 1) | bitnum(input_data, size, 6, 0));\n}\n\nstatic void inverse_permutation(uint32_t a, uint32_t b, utils::buffer&amp; buf) {\n    uint8_t data[8] = {0};\n\n    data[3] = (bitnum_intr(b, 7, 7) | bitnum_intr(a, 7, 6) | bitnum_intr(b, 15, 5)\n               | bitnum_intr(a, 15, 4) | bitnum_intr(b, 23, 3) | bitnum_intr(a, 23, 2)\n               | bitnum_intr(b, 31, 1) | bitnum_intr(a, 31, 0));\n\n    data[2] = (bitnum_intr(b, 6, 7) | bitnum_intr(a, 6, 6) | bitnum_intr(b, 14, 5)\n               | bitnum_intr(a, 14, 4) | bitnum_intr(b, 22, 3) | bitnum_intr(a, 22, 2)\n               | bitnum_intr(b, 30, 1) | bitnum_intr(a, 30, 0));\n\n    data[1] = (bitnum_intr(b, 5, 7) | bitnum_intr(a, 5, 6) | bitnum_intr(b, 13, 5)\n               | bitnum_intr(a, 13, 4) | bitnum_intr(b, 21, 3) | bitnum_intr(a, 21, 2)\n               | bitnum_intr(b, 29, 1) | bitnum_intr(a, 29, 0));\n\n    data[0] = (bitnum_intr(b, 4, 7) | bitnum_intr(a, 4, 6) | bitnum_intr(b, 12, 5)\n               | bitnum_intr(a, 12, 4) | bitnum_intr(b, 20, 3) | bitnum_intr(a, 20, 2)\n               | bitnum_intr(b, 28, 1) | bitnum_intr(a, 28, 0));\n\n    data[7] = (bitnum_intr(b, 3, 7) | bitnum_intr(a, 3, 6) | bitnum_intr(b, 11, 5)\n               | bitnum_intr(a, 11, 4) | bitnum_intr(b, 19, 3) | bitnum_intr(a, 19, 2)\n               | bitnum_intr(b, 27, 1) | bitnum_intr(a, 27, 0));\n\n    data[6] = (bitnum_intr(b, 2, 7) | bitnum_intr(a, 2, 6) | bitnum_intr(b, 10, 5)\n               | bitnum_intr(a, 10, 4) | bitnum_intr(b, 18, 3) | bitnum_intr(a, 18, 2)\n               | bitnum_intr(b, 26, 1) | bitnum_intr(a, 26, 0));\n\n    data[5] = (bitnum_intr(b, 1, 7) | bitnum_intr(a, 1, 6) | bitnum_intr(b, 9, 5)\n               | bitnum_intr(a, 9, 4) | bitnum_intr(b, 17, 3) | bitnum_intr(a, 17, 2)\n               | bitnum_intr(b, 25, 1) | bitnum_intr(a, 25, 0));\n\n    data[4] = (bitnum_intr(b, 0, 7) | bitnum_intr(a, 0, 6) | bitnum_intr(b, 8, 5)\n               | bitnum_intr(a, 8, 4) | bitnum_intr(b, 16, 3) | bitnum_intr(a, 16, 2)\n               | bitnum_intr(b, 24, 1) | bitnum_intr(a, 24, 0));\n\n    buf.clear();\n    buf.append(data, 8);\n}\n\nstatic uint32_t transform(uint32_t state, std::vector&lt;uint32_t&gt; key) {\n    uint32_t sbox[8][64] = {\n        // sbox1\n        {14, 4,  13, 1, 2,  15, 11, 8, 3, 10, 6, 12, 5,  9,  0,  7,  0,  15, 7,  4,  14, 2,\n         13, 1,  10, 6, 12, 11, 9,  5, 3, 8,  4, 1,  14, 8,  13, 6,  2,  11, 15, 12, 9,  7,\n         3,  10, 5,  0, 15, 12, 8,  2, 4, 9,  1, 7,  5,  11, 3,  14, 10, 0,  6,  13},\n\n        // sbox2\n        {15, 1,  8,  14, 6,  11, 3,  4, 9,  7,  2, 13, 12, 0,  5,  10, 3,  13, 4,  7, 15, 2,\n         8,  15, 12, 0,  1,  10, 6,  9, 11, 5,  0, 14, 7,  11, 10, 4,  13, 1,  5,  8, 12, 6,\n         9,  3,  2,  15, 13, 8,  10, 1, 3,  15, 4, 2,  11, 6,  7,  12, 0,  5,  14, 9},\n\n        // sbox3\n        {10, 0,  9,  14, 6, 3,  15, 5,  1,  13, 12, 7, 11, 4,  2,  8,  13, 7, 0,  9, 3, 4,\n         6,  10, 2,  8,  5, 14, 12, 11, 15, 1,  13, 6, 4,  9,  8,  15, 3,  0, 11, 1, 2, 12,\n         5,  10, 14, 7,  1, 10, 13, 0,  6,  9,  8,  7, 4,  15, 14, 3,  11, 5, 2,  12},\n\n        // sbox4\n        {7, 13, 14, 3, 0, 6,  9, 10, 1,  2,  8,  5, 11, 12, 4,  15, 13, 8,  11, 5, 6, 15,\n         0, 3,  4,  7, 2, 12, 1, 10, 14, 9,  10, 6, 9,  0,  12, 11, 7,  13, 15, 1, 3, 14,\n         5, 2,  8,  4, 3, 15, 0, 6,  10, 10, 13, 8, 9,  4,  5,  11, 12, 7,  2,  14},\n\n        // sbox5\n        {2,  12, 4, 1,  7,  10, 11, 6, 8, 5,  3, 15, 13, 0,  14, 9,  14, 11, 2,  12, 4,  7,\n         13, 1,  5, 0,  15, 10, 3,  9, 8, 6,  4, 2,  1,  11, 10, 13, 7,  8,  15, 9,  12, 5,\n         6,  3,  0, 14, 11, 8,  12, 7, 1, 14, 2, 13, 6,  15, 0,  9,  10, 4,  5,  3},\n\n        // sbox6\n        {12, 1,  10, 15, 9,  2,  6, 8,  0, 13, 3,  4,  14, 7,  5, 11, 10, 15, 4, 2, 7, 12,\n         9,  5,  6,  1,  13, 14, 0, 11, 3, 8,  9,  14, 15, 5,  2, 8,  12, 3,  7, 0, 4, 10,\n         1,  13, 11, 6,  4,  3,  2, 12, 9, 5,  15, 10, 11, 14, 1, 7,  6,  0,  8, 13},\n\n        // sbox7\n        {4, 11, 2,  14, 15, 0,  8,  13, 3, 12, 9,  7, 5,  10, 6,  1,  13, 0,  11, 7,  4, 9,\n         1, 10, 14, 3,  5,  12, 2,  15, 8, 6,  1,  4, 11, 13, 12, 3,  7,  14, 10, 15, 6, 8,\n         0, 5,  9,  2,  6,  11, 13, 8,  1, 4,  10, 7, 9,  5,  0,  15, 14, 2,  3,  12},\n\n        // sbox8\n        {13, 2, 8,  4, 6, 15, 11, 1,  10, 9,  3, 14, 5,  0,  12, 7,  1,  15, 13, 8, 10, 3,\n         7,  4, 12, 5, 6, 11, 0,  14, 9,  2,  7, 11, 4,  1,  9,  12, 14, 2,  0,  6, 10, 13,\n         15, 3, 5,  8, 2, 1,  14, 7,  4,  10, 8, 13, 15, 12, 9,  0,  3,  5,  6,  11},\n    };\n\n    uint32_t t1 = (bitnum_intl(state, 31, 0) | ((state &amp; 0xf0000000) &gt;&gt; 1)\n                   | bitnum_intl(state, 4, 5) | bitnum_intl(state, 3, 6)\n                   | ((state &amp; 0x0f000000) &gt;&gt; 3) | bitnum_intl(state, 8, 11)\n                   | bitnum_intl(state, 7, 12) | ((state &amp; 0x00f00000) &gt;&gt; 5)\n                   | bitnum_intl(state, 12, 17) | bitnum_intl(state, 11, 18)\n                   | ((state &amp; 0x000f0000) &gt;&gt; 7) | bitnum_intl(state, 16, 23));\n\n    uint32_t t2 = (bitnum_intl(state, 15, 0) | ((state &amp; 0x0000f000) &lt;&lt; 15)\n                   | bitnum_intl(state, 20, 5) | bitnum_intl(state, 19, 6)\n                   | ((state &amp; 0x00000f00) &lt;&lt; 13) | bitnum_intl(state, 24, 11)\n                   | bitnum_intl(state, 23, 12) | ((state &amp; 0x000000f0) &lt;&lt; 11)\n                   | bitnum_intl(state, 28, 17) | bitnum_intl(state, 27, 18)\n                   | ((state &amp; 0x0000000f) &lt;&lt; 9) | bitnum_intl(state, 0, 23));\n\n    uint32_t lrgstate[] = {\n        (t1 &gt;&gt; 24) &amp; 0x000000ff,\n        (t1 &gt;&gt; 16) &amp; 0x000000ff,\n        (t1 &gt;&gt; 8) &amp; 0x000000ff,\n        (t2 &gt;&gt; 24) &amp; 0x000000ff,\n        (t2 &gt;&gt; 16) &amp; 0x000000ff,\n        (t2 &gt;&gt; 8) &amp; 0x000000ff,\n    };\n\n    for (int i = 0; i &lt; 6; ++i) {\n        lrgstate[i] ^= key[i];\n    }\n\n    state = ((sbox[0][sbox_bit(lrgstate[0] &gt;&gt; 2)] &lt;&lt; 28)\n             | (sbox[1][sbox_bit(((lrgstate[0] &amp; 0x03) &lt;&lt; 4) | (lrgstate[1] &gt;&gt; 4))] &lt;&lt; 24)\n             | (sbox[2][sbox_bit(((lrgstate[1] &amp; 0x0f) &lt;&lt; 2) | (lrgstate[2] &gt;&gt; 6))] &lt;&lt; 20)\n             | (sbox[3][sbox_bit(lrgstate[2] &amp; 0x3f)] &lt;&lt; 16)\n             | (sbox[4][sbox_bit(lrgstate[3] &gt;&gt; 2)] &lt;&lt; 12)\n             | (sbox[5][sbox_bit(((lrgstate[3] &amp; 0x03) &lt;&lt; 4) | (lrgstate[4] &gt;&gt; 4))] &lt;&lt; 8)\n             | (sbox[6][sbox_bit(((lrgstate[4] &amp; 0x0f) &lt;&lt; 2) | (lrgstate[5] &gt;&gt; 6))] &lt;&lt; 4)\n             | sbox[7][sbox_bit(lrgstate[5] &amp; 0x3f)]);\n\n    return (bitnum_intl(state, 15, 0) | bitnum_intl(state, 6, 1) | bitnum_intl(state, 19, 2)\n            | bitnum_intl(state, 20, 3) | bitnum_intl(state, 28, 4) | bitnum_intl(state, 11, 5)\n            | bitnum_intl(state, 27, 6) | bitnum_intl(state, 16, 7) | bitnum_intl(state, 0, 8)\n            | bitnum_intl(state, 14, 9) | bitnum_intl(state, 22, 10) | bitnum_intl(state, 25, 11)\n            | bitnum_intl(state, 4, 12) | bitnum_intl(state, 17, 13) | bitnum_intl(state, 30, 14)\n            | bitnum_intl(state, 9, 15) | bitnum_intl(state, 1, 16) | bitnum_intl(state, 7, 17)\n            | bitnum_intl(state, 23, 18) | bitnum_intl(state, 13, 19) | bitnum_intl(state, 31, 20)\n            | bitnum_intl(state, 26, 21) | bitnum_intl(state, 2, 22) | bitnum_intl(state, 8, 23)\n            | bitnum_intl(state, 18, 24) | bitnum_intl(state, 12, 25) | bitnum_intl(state, 29, 26)\n            | bitnum_intl(state, 5, 27) | bitnum_intl(state, 21, 28) | bitnum_intl(state, 10, 29)\n            | bitnum_intl(state, 3, 30) | bitnum_intl(state, 24, 31));\n}\n\nstatic uint32_t sbox_bit(uint32_t a) {\n    return (a &amp; 32) | ((a &amp; 31) &gt;&gt; 1) | ((a &amp; 1) &lt;&lt; 4);\n}\n\n} // namespace qqmusic::details\n</code></pre>"},{"location":"dictionary/login_8cc/","title":"File login.cc","text":"<p>FileList &gt; src &gt; login.cc</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/beast/core/buffers_to_string.hpp&gt;</code></li> <li><code>#include &lt;boost/beast/http.hpp&gt;</code></li> <li><code>#include &lt;boost/beast/http/message.hpp&gt;</code></li> <li><code>#include &lt;boost/uuid.hpp&gt;</code></li> <li><code>#include &lt;boost/uuid/uuid_io.hpp&gt;</code></li> <li><code>#include &lt;botan/auto_rng.h&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;ctime&gt;</code></li> <li><code>#include &lt;qqmusic/details/api.h&gt;</code></li> <li><code>#include &lt;qqmusic/login.h&gt;</code></li> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/common.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/session.h&gt;</code></li> <li><code>#include &lt;ratio&gt;</code></li> <li><code>#include &lt;regex&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;string_view&gt;</code></li> </ul>"},{"location":"dictionary/login_8cc/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic"},{"location":"dictionary/login_8cc/#public-static-functions","title":"Public Static Functions","text":"Type Name qqmusic::Task&lt; qqmusic::Result&lt; qqmusic::utils::Credential &gt; &gt; auth_qq_qr (std::string_view sigx, std::string_view uin)  qqmusic::Task&lt; qqmusic::Result&lt; qqmusic::utils::Credential &gt; &gt; auth_wx_qr (std::string_view code)"},{"location":"dictionary/login_8cc/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"dictionary/login_8cc/#function-auth_qq_qr","title":"function auth_qq_qr","text":"<pre><code>static qqmusic::Task&lt; qqmusic::Result&lt; qqmusic::utils::Credential &gt; &gt; auth_qq_qr (\n    std::string_view sigx,\n    std::string_view uin\n) \n</code></pre>"},{"location":"dictionary/login_8cc/#function-auth_wx_qr","title":"function auth_wx_qr","text":"<pre><code>static qqmusic::Task&lt; qqmusic::Result&lt; qqmusic::utils::Credential &gt; &gt; auth_wx_qr (\n    std::string_view code\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/login.cc</code></p>"},{"location":"dictionary/login_8cc_source/","title":"File login.cc","text":"<p>File List &gt; src &gt; login.cc</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;boost/beast/core/buffers_to_string.hpp&gt;\n#include &lt;boost/beast/http.hpp&gt;\n#include &lt;boost/beast/http/message.hpp&gt;\n#include &lt;boost/uuid.hpp&gt;\n#include &lt;boost/uuid/uuid_io.hpp&gt;\n#include &lt;botan/auto_rng.h&gt;\n#include &lt;chrono&gt;\n#include &lt;cmath&gt;\n#include &lt;ctime&gt;\n#include &lt;qqmusic/details/api.h&gt;\n#include &lt;qqmusic/login.h&gt;\n#include &lt;qqmusic/result.h&gt;\n#include &lt;qqmusic/utils/common.h&gt;\n#include &lt;qqmusic/utils/session.h&gt;\n#include &lt;ratio&gt;\n#include &lt;regex&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;string_view&gt;\n\nstatic qqmusic::Task&lt;qqmusic::Result&lt;qqmusic::utils::Credential&gt;&gt; auth_qq_qr(std::string_view sigx,\n                                                                             std::string_view uin);\n\nstatic qqmusic::Task&lt;qqmusic::Result&lt;qqmusic::utils::Credential&gt;&gt; auth_wx_qr(std::string_view code);\n\nnamespace qqmusic {\n\nqqmusic::Task&lt;qqmusic::Result&lt;QRCode&gt;&gt; get_qrcode(QRLoginType login_type) {\n    namespace http = boost::beast::http;\n    namespace asio = boost::asio;\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto&amp; context = session.get_context_ref();\n    if (login_type == QRLoginType::QQ) {\n        /*qq login*/\n        boost::url url{\"https://ssl.ptlogin2.qq.com/ptqrshow\"};\n\n        Botan::AutoSeeded_RNG rng;\n        /*random unsigned long long generator*/\n        auto randull = [&amp;rng]() -&gt; uint64_t {\n            uint64_t res = 0;\n            std::vector&lt;uint8_t&gt; buffer(sizeof(res));\n            rng.randomize(buffer);\n            memcpy(&amp;res, buffer.data(), sizeof(res));\n            return res;\n        };\n        url.set_params({{\"appid\", \"716027609\"},\n                        {\"e\", \"2\"},\n                        {\"l\", \"M\"},\n                        {\"s\", \"3\"},\n                        {\"d\", \"72\"},\n                        {\"v\", \"4\"},\n                        /* origin python code: `\"t\": str(random.random()),` */\n                        {\"t\", \"0.\" + std::to_string(randull() % 10000000000000000)},\n                        {\"daid\", \"383\"},\n                        {\"pt_3rd_aid\", \"100497308\"}});\n\n        http::request&lt;http::string_body&gt; req{http::verb::get, url, 11};\n        req.set(http::field::host, url.host());\n        req.set(http::field::accept, \"*/*\");\n        /*use raw buffer instead of compressed buffer when debuging*/\n        req.set(http::field::accept_encoding, \"gzip, deflate\");\n        req.set(http::field::connection, \"keep-alive\");\n        req.set(http::field::user_agent,\n                \"Mozilla/5.0 (Windows NT 11.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) \"\n                \"Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.54\");\n        req.set(http::field::referer, \"https://xui.ptlogin2.qq.com/\");\n\n        /*send request*/\n        auto res = co_await session.perform_request(url, req);\n        if (res.isErr()) {\n            co_return Err(utils::Exception(\n                utils::Exception::NetworkError,\n                std::format(\"[get_qrcode] -- Error occurred when performing https request: `{}`\",\n                            res.unwrapErr().what())));\n        }\n        auto data = utils::resp2buf(res.unwrap());\n        auto qrsig_res = context.cookies.get(\"qrsig\");\n        auto qrsig = qrsig_res.unwrap();\n        if (qrsig_res.isErr()) {\n            co_return Err(utils::Exception(utils::Exception::DataDestroy,\n                                           \"[get_qrcode] -- Cannot get qrsig from cookie\"));\n        }\n        co_return Ok(QRCode{.qr_type = QRLoginType::QQ,\n                            .identifier = qrsig,\n                            .mimie_type = \"image/png\",\n                            .data = data});\n    } else {\n        /*wx login*/\n        boost::url uuid_url{\"https://open.weixin.qq.com/connect/qrconnect\"};\n        uuid_url.set_params({\n            {\"appid\", \"wx48db31d50e334801\"},\n            {\"redirect_uri\",\n             \"https://y.qq.com/portal/wx_redirect.html?login_type=2&amp;surl=https://y.qq.com/\"},\n            {\"response_type\", \"code\"},\n            {\"scope\", \"snsapi_login\"},\n            {\"state\", \"STATE\"},\n            {\"href\",\n             \"https://y.qq.com/mediastyle/music_v17/src/css/popup_wechat.css#wechat_redirect\"},\n        });\n\n        http::request&lt;http::string_body&gt; req{http::verb::get, uuid_url, 11};\n        req.set(http::field::host, uuid_url.host());\n        req.set(http::field::accept, \"*/*\");\n        /*use raw buffer instead of compressed buffer when debuging*/\n        req.set(http::field::accept_encoding, \"identity\");\n        req.set(http::field::connection, \"keep-alive\");\n        req.set(http::field::referer, \"y.qq.com\");\n        req.set(http::field::user_agent,\n                \"Mozilla/5.0 (Windows NT 11.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) \"\n                \"Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.54\");\n\n        /*send request*/\n        auto res = co_await session.perform_request(uuid_url, req);\n        if (res.isErr()) {\n            co_return Err(utils::Exception(\n                utils::Exception::NetworkError,\n                std::format(\"[get_qrcode] -- Error occurred when performing https request: `{}`\",\n                            res.unwrapErr().what())));\n        }\n\n        auto resp = res.unwrap();\n        std::string raw = boost::beast::buffers_to_string(resp.body().data());\n        std::regex uuid_pattern{R\"REGEX(uuid=(.+?)\\\")REGEX\"};\n        std::smatch matches;\n        if (!std::regex_search(raw, matches, uuid_pattern)) {\n            /*Not found*/\n            co_return Err(utils::Exception(\n                utils::Exception::DataDestroy,\n                \"[get_qrcode] -- No uuid found in wechat api response, data might be ruined\"));\n        }\n\n        std::string&amp;&amp; uuid = matches[1].str();\n        boost::url qr_url{std::format(\"https://open.weixin.qq.com/connect/qrcode/{}\", uuid)};\n        http::request&lt;http::string_body&gt; qr_req{http::verb::get, qr_url, 11};\n        qr_req.set(http::field::host, qr_url.host());\n        qr_req.set(http::field::accept, \"*/*\");\n        /*use raw buffer instead of compressed buffer when debuging*/\n        qr_req.set(http::field::accept_encoding, \"identity\");\n        qr_req.set(http::field::connection, \"keep-alive\");\n        qr_req.set(http::field::referer, \"https://open.weixin.qq.com/connect/qrconnect\");\n        qr_req\n            .set(http::field::user_agent,\n                 \"Mozilla/5.0 (Windows NT 11.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) \"\n                 \"Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.54\");\n        auto qr_result = co_await session.perform_request(qr_url, qr_req);\n        if (qr_result.isErr()) {\n            co_return Err(utils::Exception(\n                utils::Exception::NetworkError,\n                std::format(\"[get_qrcode] -- Error occurred when performing https request: `{}`\",\n                            qr_result.unwrapErr().what())));\n        }\n        auto image = utils::resp2buf(qr_result.unwrap());\n        co_return Ok(QRCode{.qr_type = QRLoginType::WX,\n                            .identifier = uuid,\n                            .mimie_type = \"image/jpeg\",\n                            .data = image});\n    }\n}\n\nqqmusic::Task&lt;qqmusic::Result&lt;QRCodeLoginResult&gt;&gt; check_qq_qr(QRCode&amp; qrc) {\n    namespace http = boost::beast::http;\n    if (qrc.qr_type != QRLoginType::QQ) {\n        co_return Err(utils::Exception(utils::Exception::DataDestroy,\n                                       \"[check_qq_qr] -- Not a QQ login QRCode\"));\n    }\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto qrsig = qrc.identifier;\n\n    /*zoned time cannot be used on MacOS platform yet*/\n#ifdef PLATFORM_APPLE\n    auto now = std::chrono::system_clock::now();\n    auto now_time_t = std::chrono::system_clock::to_time_t(now);\n    auto duration = now.time_since_epoch() % 1000;\n    auto millis = std::chrono::duration_cast&lt;std::chrono::duration&lt;double, std::milli&gt;&gt;(duration)\n                      .count();\n    std::tm local_tm{};\n    localtime_r(&amp;now_time_t, &amp;local_tm);\n    auto seconds = mktime(&amp;local_tm);\n    double ts = static_cast&lt;double&gt;(seconds) * 1000.0 + millis;\n#else\n    std::chrono::time_point&lt;std::chrono::system_clock&gt; tp{std::chrono::system_clock::now()};\n    auto zoned_time = std::chrono::zoned_time{std::chrono::current_zone(), tp};\n    double ts = std::chrono::duration&lt;double, std::milli&gt;(\n                    zoned_time.get_local_time().time_since_epoch())\n                    .count();\n#endif\n\n    boost::url url{\"https://ssl.ptlogin2.qq.com/ptqrlogin\"};\n    url.set_params({\n        {\"u1\", \"https://graph.qq.com/oauth2.0/login_jump\"},\n        {\"ptqrtoken\", std::to_string(utils::hash33(qrsig))},\n        {\"ptredirect\", \"0\"},\n        {\"h\", \"1\"},\n        {\"t\", \"1\"},\n        {\"g\", \"1\"},\n        {\"from_ui\", \"1\"},\n        {\"ptlang\", \"2052\"},\n        {\"action\", std::format(\"0-0-{}\", ts)},\n        {\"js_ver\", \"20102616\"},\n        {\"js_type\", \"1\"},\n        {\"pt_uistyle\", \"40\"},\n        {\"aid\", \"716027609\"},\n        {\"daid\", \"383\"},\n        {\"pt_3rd_aid\", \"100497308\"},\n        {\"has_onekey\", \"1\"},\n    });\n    http::request&lt;http::string_body&gt; qr_req{http::verb::get, url, 11};\n    qr_req.set(http::field::host, url.host());\n    qr_req.set(http::field::accept, \"*/*\");\n    /*use raw buffer instead of compressed buffer when debuging*/\n    qr_req.set(http::field::accept_encoding, \"identity\");\n    qr_req.set(http::field::connection, \"keep-alive\");\n    qr_req.set(http::field::referer, \"https://xui.ptlogin2.qq.com/\");\n    qr_req.set(http::field::cookie, std::format(\"qrsig={}\", qrsig));\n    qr_req.set(http::field::user_agent,\n               \"Mozilla/5.0 (Windows NT 11.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) \"\n               \"Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.54\");\n\n    auto qr_res = co_await session.perform_request(url, qr_req);\n    if (qr_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[check_qq_qr] -- Error occurred when performing https request: `{}`\",\n                        qr_res.unwrapErr().what())));\n    }\n\n    auto resp = qr_res.unwrap();\n    std::string raw = boost::beast::buffers_to_string(resp.body().data());\n    /*match status*/\n    std::regex list_pat{R\"REGEX(ptuiCB\\((.*)\\))REGEX\"};\n    std::vector&lt;std::string&gt; items;\n    std::smatch list_match;\n    if (std::regex_match(raw, list_match, list_pat)) {\n        auto list = list_match[1].str();\n        auto list1 = list;\n        std::regex item_pat{R\"REGEX(\\'([^,']*)\\')REGEX\"};\n        std::smatch item_match;\n        while (std::regex_search(list1, item_match, item_pat)) {\n            items.push_back(item_match[1].str());\n            list1 = item_match.suffix().str();\n        }\n    } else {\n        co_return Err(utils::Exception(utils::Exception::DataDestroy,\n                                       \"[check_qq_qr] -- Failed to get QR Code status\"));\n    }\n\n    int code;\n    try {\n        code = std::stoi(items[0]);\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(utils::Exception::DataDestroy,\n                                       \"[check_qq_qr] -- Failed parsing status code\"));\n    }\n\n    auto event = QRCodeLoginEvent(code);\n    if (event == QRCodeLoginEvent::Status::DONE) {\n        /*Authorize*/\n        std::regex sigx_pat{R\"REGEX(&amp;ptsigx=(.+?)&amp;s_url)REGEX\"};\n        std::regex uin_pat{R\"REGEX(&amp;uin=(.+?)&amp;service)REGEX\"};\n        std::smatch sigx_match, uin_match;\n        if (!std::regex_search(items[2], sigx_match, sigx_pat)) {\n            co_return Err(utils::Exception(utils::Exception::DataDestroy,\n                                           \"[check_qq_qr] -- Cannot find sigx\"));\n        }\n        if (!std::regex_search(items[2], uin_match, uin_pat)) {\n            co_return Err(utils::Exception(utils::Exception::DataDestroy,\n                                           \"[check_qq_qr] -- Cannot find uin\"));\n        }\n        std::string sigx = sigx_match[1].str();\n        std::string uin = uin_match[1].str();\n        auto auth_res = co_await auth_qq_qr(sigx, uin);\n        if (auth_res.isErr()) {\n            co_return Err(auth_res.unwrapErr());\n        }\n        co_return Ok(QRCodeLoginResult{event, auth_res.unwrap()});\n    }\n\n    co_return Ok(QRCodeLoginResult{event, std::nullopt});\n}\n\nqqmusic::Task&lt;qqmusic::Result&lt;QRCodeLoginResult&gt;&gt; check_wx_qr(QRCode&amp; qrc) {\n    namespace http = boost::beast::http;\n    if (qrc.qr_type != QRLoginType::WX) {\n        co_return Err(utils::Exception(utils::Exception::DataDestroy,\n                                       \"[check_qq_qr] -- Not a WX login QRCode\"));\n    }\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto uuid = qrc.identifier;\n\n#ifdef PLATFORM_APPLE\n    auto now = std::chrono::system_clock::now();\n    auto now_time_t = std::chrono::system_clock::to_time_t(now);\n    auto duration = now.time_since_epoch() % 1000;\n    auto millis = std::chrono::duration_cast&lt;std::chrono::duration&lt;double, std::milli&gt;&gt;(duration)\n                      .count();\n    std::tm local_tm{};\n    localtime_r(&amp;now_time_t, &amp;local_tm);\n    auto seconds = mktime(&amp;local_tm);\n    double ts = static_cast&lt;double&gt;(seconds) * 1000.0 + millis;\n#else\n    std::chrono::time_point&lt;std::chrono::system_clock&gt; tp{std::chrono::system_clock::now()};\n    auto zoned_time = std::chrono::zoned_time{std::chrono::current_zone(), tp};\n    double ts = std::chrono::duration&lt;double, std::milli&gt;(\n                    zoned_time.get_local_time().time_since_epoch())\n                    .count()\n                / 1000;\n#endif\n\n    boost::url url{\"https://lp.open.weixin.qq.com/connect/l/qrconnect\"};\n    url.set_params({{\"uuid\", uuid}, {\"_\", std::to_string(lround(ts) * 1000)}});\n\n    http::request&lt;http::string_body&gt; req{http::verb::get, url, 11};\n    req.set(http::field::host, url.host());\n    req.set(http::field::accept, \"*/*\");\n    /*use raw buffer instead of compressed buffer when debuging*/\n    req.set(http::field::accept_encoding, \"identity\");\n    req.set(http::field::connection, \"keep-alive\");\n    req.set(http::field::referer, \"https://open.weixin.qq.com/\");\n    req.set(http::field::user_agent,\n            \"Mozilla/5.0 (Windows NT 11.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) \"\n            \"Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.54\");\n\n    auto res = co_await session.perform_request(url, req);\n    if (res.isErr()) {\n        if (res.unwrapErr().get_error_enum() == utils::Exception::OperationOutOfTime) {\n            co_return Ok(QRCodeLoginResult({QRCodeLoginEvent::Status::SCAN, std::nullopt}));\n        }\n\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[check_wx_qr] -- Error occurred when performing https request: `{}`\",\n                        res.unwrapErr().what())));\n    }\n\n    auto resp = res.unwrap();\n    auto text = boost::beast::buffers_to_string(resp.body().data());\n    std::regex pat{R\"REGEX(window\\.wx_errcode=(\\d+);window\\.wx_code=\\'([^\\']*)\\')REGEX\"};\n    std::smatch match;\n    if (!std::regex_search(text, match, pat)) {\n        co_return Err(utils::Exception(utils::Exception::DataDestroy,\n                                       \"[check_wx_qr] -- Cannot get QR Code status\"));\n    }\n\n    int wx_errcode = 0;\n    try {\n        wx_errcode = std::stoi(match[1].str());\n    } catch (const std::exception&amp;) {\n        /*Not a number*/\n        co_return Ok(QRCodeLoginResult{QRCodeLoginEvent::Status::OTHER, std::nullopt});\n    }\n\n    auto event = QRCodeLoginEvent(wx_errcode);\n    if (event == QRCodeLoginEvent::Status::DONE) {\n        auto wx_code = match[2].str();\n        if (!wx_code.size()) {\n            co_return Err(utils::Exception(utils::Exception::DataDestroy,\n                                           \"[check_wx_qr] -- Cannot get wx code\"));\n        }\n\n        auto credential_res = co_await auth_wx_qr(wx_code);\n        if (credential_res.isErr()) {\n            co_return Err(\n                utils::Exception(utils::Exception::CredentialInvalidError,\n                                 std::format(\"[check_wx_qr] -- Cannot get credential: `{}`\",\n                                             credential_res.unwrapErr().what())));\n        }\n        co_return Ok(QRCodeLoginResult{event, credential_res.unwrap()});\n    }\n\n    co_return Ok(QRCodeLoginResult({event, std::nullopt}));\n}\n\nqqmusic::Task&lt;qqmusic::Result&lt;PhoneLoginResult&gt;&gt; send_authcode(std::string_view phone,\n                                                               std::string_view country_code) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session,\n                            \"music.login.LoginServer\",\n                            \"SendPhoneAuthCode\",\n                            {},\n                            {{\"tmeLoginMethod\", \"3\"}});\n    auto req_res = co_await api.prepare_request({\n        {\"tmeAppid\", \"qqmusic\"},\n        {\"phoneNo\", phone},\n        {\"areaCode\", country_code},\n    });\n\n    if (req_res.isErr()) {\n        co_return Err(utils::Exception(\n            qqmusic::utils::Exception::DataDestroy,\n            std::format(\"[send_authcode] -- Error occurred when preparing request: `{}`\",\n                        req_res.unwrapErr().what())));\n    }\n\n    auto url = req_res.unwrap().url;\n    auto req = req_res.unwrap().req;\n    req.base().erase(boost::beast::http::field::cookie);\n    auto res = co_await session.perform_request(url, req);\n    if (res.isErr()) {\n        co_return Err(qqmusic::utils::Exception(\n            qqmusic::utils::Exception::NetworkError,\n            std::format(\"[send_authcode] -- Network Error when request for security url: `{}`\",\n                        res.unwrapErr().what())));\n    }\n\n    auto resp_parse_res = api.parse_response(utils::resp2buf(res.unwrap()));\n    if (resp_parse_res.isErr()) {\n        co_return Err(qqmusic::utils::Exception(qqmusic::utils::Exception::DataDestroy,\n                                                \"[send_authcode] -- Cannot parse response\"));\n    }\n\n    auto raw_result = nlohmann::json::parse(\n        utils::resp2buf(res.unwrap()))[\"music.login.LoginServer.SendPhoneAuthCode\"];\n    try {\n        int64_t code = raw_result[\"code\"].get&lt;int64_t&gt;();\n        switch (code) {\n        case 0:\n            co_return Ok(PhoneLoginResult{PhoneLoginEvent::SEND, \"\"});\n        case 20276:\n            co_return Ok(\n                PhoneLoginResult{PhoneLoginEvent::CAPTCHA, raw_result[\"data\"][\"securityURL\"]});\n        case 100001:\n            co_return Ok(PhoneLoginResult{PhoneLoginEvent::FREQUENCY, \"\"});\n        default:\n            /*Error*/\n            co_return Ok(PhoneLoginResult{PhoneLoginEvent::OTHER, raw_result[\"data\"][\"errMsg\"]});\n        }\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(\n            utils::Exception::JsonError,\n            \"[send_authcode] -- Cannot parse security url or error message from json\"));\n    }\n}\n\nqqmusic::Task&lt;qqmusic::Result&lt;utils::Credential&gt;&gt; phone_authorize(std::string_view phone,\n                                                                  std::string_view auth_code,\n                                                                  std::string_view country_code) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session,\n                            \"music.login.LoginServer\",\n                            \"Login\",\n                            {},\n                            {{\"tmeLoginMethod\", \"3\"}, {\"tmeLoginType\", \"0\"}});\n    auto req_res = co_await api.prepare_request(nlohmann::json{{\"code\", auth_code},\n                                                               {\"phoneNo\", phone},\n                                                               {\"areaCode\", country_code},\n                                                               {\"loginMode\", 1}});\n\n    if (req_res.isErr()) {\n        co_return Err(utils::Exception(\n            qqmusic::utils::Exception::DataDestroy,\n            std::format(\"[phone_authorize] -- Error occurred when preparing request: `{}`\",\n                        req_res.unwrapErr().what())));\n    }\n    auto url = req_res.unwrap().url;\n    auto req = req_res.unwrap().req;\n    req.base().erase(boost::beast::http::field::cookie);\n    auto res = co_await session.perform_request(url, req);\n    if (res.isErr()) {\n        co_return Err(qqmusic::utils::Exception(\n            qqmusic::utils::Exception::NetworkError,\n            std::format(\"[phone_authorize] -- Network Error when request for credential: `{}`\",\n                        res.unwrapErr().what())));\n    }\n\n    try {\n        auto raw_result = nlohmann::json::parse(\n            utils::resp2buf(res.unwrap()))[\"music.login.LoginServer.Login\"];\n        int64_t code = raw_result[\"code\"].get&lt;int64_t&gt;();\n        switch (code) {\n        case 0:\n            co_return Ok(utils::Credential(raw_result[\"data\"]));\n        case 20271:\n            co_return Err(\n                utils::Exception(utils::Exception::LoginError,\n                                 \"[phone_authorize] -- Auth_code error or already authorized\"));\n        default:\n            /*Error*/\n            co_return Err(\n                utils::Exception(utils::Exception::UnknownError,\n                                 \"[phone_authorize] -- Authorize failed for unknown error\"));\n        }\n    } catch (const std::exception&amp; e) {\n        co_return Err(\n            utils::Exception(utils::Exception::JsonError,\n                             \"[phone_authorize] -- Cannot parse Credential from response data\"));\n    }\n}\n\n} // namespace qqmusic\n\nstatic qqmusic::Task&lt;qqmusic::Result&lt;qqmusic::utils::Credential&gt;&gt; auth_qq_qr(std::string_view sigx,\n                                                                             std::string_view uin) {\n    namespace http = boost::beast::http;\n    auto session = qqmusic::utils::SessionManager::get_instance().get_session();\n    auto&amp; context = session.get_context_ref();\n    boost::url p_skey_url{\"https://ssl.ptlogin2.graph.qq.com/check_sig\"};\n    p_skey_url.set_params({\n        {\"uin\", uin},\n        {\"pttype\", \"1\"},\n        {\"service\", \"ptqrlogin\"},\n        {\"nodirect\", \"0\"},\n        {\"ptsigx\", sigx},\n        {\"s_url\", \"https://graph.qq.com/oauth2.0/login_jump\"},\n        {\"ptlang\", \"2052\"},\n        {\"ptredirect\", \"100\"},\n        {\"aid\", \"716027609\"},\n        {\"daid\", \"383\"},\n        {\"j_later\", \"0\"},\n        {\"low_login_hour\", \"0\"},\n        {\"regmaster\", \"0\"},\n        {\"pt_login_type\", \"3\"},\n        {\"pt_aid\", \"0\"},\n        {\"pt_aaid\", \"16\"},\n        {\"pt_light\", \"0\"},\n        {\"pt_3rd_aid\", \"100497308\"},\n    });\n\n    http::request&lt;http::string_body&gt; p_skey_req{http::verb::get, p_skey_url, 11};\n    p_skey_req.set(http::field::host, p_skey_url.host());\n    p_skey_req.set(http::field::accept, \"*/*\");\n    /*use raw buffer instead of compressed buffer when debuging*/\n    p_skey_req.set(http::field::accept_encoding, \"identity\");\n    p_skey_req.set(http::field::connection, \"keep-alive\");\n    p_skey_req.set(http::field::referer, \"https://xui.ptlogin2.qq.com/\");\n    p_skey_req\n        .set(http::field::user_agent,\n             \"Mozilla/5.0 (Windows NT 11.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) \"\n             \"Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.54\");\n\n    auto pskey_resp_res = co_await session.perform_request(p_skey_url, p_skey_req);\n    if (pskey_resp_res.isErr()) {\n        co_return Err(qqmusic::utils::Exception(\n            qqmusic::utils::Exception::NetworkError,\n            std::format(\"[auth_qq_qr] -- Network Error when request for p_skey: `{}`\",\n                        pskey_resp_res.unwrapErr().what())));\n    }\n\n    auto getkey_res = context.cookies.get(\"p_skey\");\n    if (getkey_res.isErr()) {\n        co_return Err(qqmusic::utils::Exception(qqmusic::utils::Exception::NetworkError,\n                                                \"[auth_qq_qr] -- Cannot get p_skey\"));\n    }\n    auto p_skey = getkey_res.unwrap();\n\n    boost::url location_url{\"https://graph.qq.com/oauth2.0/authorize\"};\n\n    /* regex R\"REGEX(\\&amp;*(?:([^&amp;=]+)\\=([^&amp;=]+))\\&amp;*)REGEX\" \n     * can be used to parse application/x-www-form-urlencoded format data\n     * */\n\n    boost::uuids::uuid u = boost::uuids::random_generator()();\n    auto timestamp_ms = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(\n                            std::chrono::system_clock::now().time_since_epoch())\n                            .count();\n    std::string timestamp_str = std::to_string(timestamp_ms - timestamp_ms % 1000);\n\n    std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt;\n        params{{\"response_type\", \"code\"},\n               {\"client_id\", \"100497308\"},\n               {\"redirect_uri\",\n                \"https%3A%2F%2Fy.qq.com%2Fportal%2Fwx_redirect.html%3Flogin_type%3D1%26surl%\"\n                \"3Dhttps%253A%25252F%25252Fy.qq.com%25252F\"},\n               {\"scope\", \"get_user_info%2Cget_app_friends\"},\n               {\"state\", \"state\"},\n               {\"switch\", \"\"},\n               {\"from_ptlogin\", \"1\"},\n               {\"src\", \"1\"},\n               {\"update_auth\", \"1\"},\n               {\"openapi\", \"1010_1030\"},\n               {\"g_tk\", std::to_string(qqmusic::utils::hash33(p_skey, 5381))},\n               {\"auth_time\", timestamp_str},\n               {\"ui\", boost::uuids::to_string(u)}};\n\n    std::ostringstream oss;\n    for (auto&amp; i : params) {\n        oss &lt;&lt; i.first &lt;&lt; \"=\" &lt;&lt; i.second &lt;&lt; \"&amp;\";\n    }\n    auto data = oss.str();\n    data.erase(data.end() - 1);\n    http::request&lt;http::string_body&gt; location_req{http::verb::post, location_url, 11};\n    location_req.set(http::field::host, location_url.host());\n    location_req.set(http::field::accept, \"*/*\");\n    /*use raw buffer instead of compressed buffer when debuging*/\n    location_req.set(http::field::accept_encoding, \"identity\");\n    location_req.set(http::field::connection, \"keep-alive\");\n    location_req\n        .set(http::field::user_agent,\n             \"Mozilla/5.0 (Windows NT 11.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) \"\n             \"Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.54\");\n    location_req.set(http::field::content_type, \"application/x-www-form-urlencoded\");\n    auto cookie1_dump = context.cookies.serialize(\"graph.qq.com\");\n    auto cookie2_dump = context.cookies.serialize(\"qq.com\");\n    if (cookie1_dump.isErr() || cookie2_dump.isErr()) {\n        co_return Err(qqmusic::utils::Exception(qqmusic::utils::Exception::JsonError,\n                                                \"[auth_qq_qr] -- Cannot set cookie\"));\n    }\n    auto cookie_str = cookie1_dump.unwrap() + \"; \" + cookie2_dump.unwrap();\n    location_req.set(http::field::cookie, cookie_str);\n    location_req.body() = data;\n\n    location_req.prepare_payload();\n\n    auto location_res = co_await session.perform_request(location_url, location_req, false);\n    if (location_res.isErr()) {\n        co_return Err(qqmusic::utils::Exception(\n            qqmusic::utils::Exception::NetworkError,\n            std::format(\"[auth_qq_qr] -- Error occurred when getting location: `{}`\",\n                        location_res.unwrapErr().what())));\n    }\n\n    auto headers = location_res.unwrap().base();\n    std::string location;\n    if (auto pos = headers.find(http::field::location); pos == headers.end()) {\n        /*Not find*/\n        co_return Err(qqmusic::utils::Exception(\n            qqmusic::utils::Exception::DataDestroy,\n            \"[auth_qq_qr] -- Cannot find location, data might be ruined\"));\n    } else {\n        location = pos-&gt;value();\n    }\n\n    std::regex code_pat{R\"REGEX(code=([^&amp;]+))REGEX\"};\n    std::smatch code_match;\n    if (!std::regex_search(location, code_match, code_pat)) {\n        co_return Err(qqmusic::utils::Exception(qqmusic::utils::Exception::DataDestroy,\n                                                \"[auth_qq_qr] -- Cannot get code from location\"));\n    }\n\n    auto code = code_match[1].str();\n    auto api = qqmusic::details::Api(session,\n                                     \"music.login.LoginServer\",\n                                     \"Login\",\n                                     {},\n                                     nlohmann::json{{\"tmeLoginType\", \"2\"}});\n    auto credential_req = co_await api.prepare_request({{\"code\", code}});\n    if (credential_req.isErr()) {\n        if (credential_req.unwrapErr().get_error_enum()\n            == qqmusic::utils::Exception::CredendialExpiredError) {\n            co_return Err(\n                qqmusic::utils::Exception(qqmusic::utils::Exception::LoginError,\n                                          \"[auth_wx_qr] -- Cannot authorize for multiple times\"));\n        }\n        co_return Err(qqmusic::utils::Exception(\n            qqmusic::utils::Exception::DataDestroy,\n            std::format(\"[auth_qq_qr] -- Error occurred when preparing request: `{}`\",\n                        credential_req.unwrapErr().what())));\n    }\n\n    auto cred_url = credential_req.unwrap().url;\n    auto cred_req = credential_req.unwrap().req;\n    auto credential_res = co_await session.perform_request(cred_url, cred_req);\n    if (credential_res.isErr()) {\n        if (credential_res.unwrapErr().get_error_enum()\n            == qqmusic::utils::Exception::CredendialExpiredError) {\n            co_return Err(\n                qqmusic::utils::Exception(qqmusic::utils::Exception::LoginError,\n                                          \"[auth_qq_qr] -- Cannot authorize for multiple times\"));\n        }\n        co_return Err(qqmusic::utils::Exception(\n            qqmusic::utils::Exception::NetworkError,\n            std::format(\"[auth_qq_qr] -- Error occurred when getting credential: `{}`\",\n                        credential_res.unwrapErr().what())));\n    }\n\n    auto credential_raw_res = api.parse_response(qqmusic::utils::resp2buf(credential_res.unwrap()));\n    if (credential_raw_res.isErr()) {\n        co_return Err(qqmusic::utils::Exception(qqmusic::utils::Exception::DataDestroy,\n                                                \"[auth_qq_qr] -- Cannot parse response\"));\n    }\n    try {\n        co_return Ok(qqmusic::utils::Credential(credential_raw_res.unwrap()));\n    } catch (const std::exception&amp; e) {\n        co_return Err(qqmusic::utils::Exception(qqmusic::utils::Exception::JsonError,\n                                                \"[auth_qq_qr] -- Cannot parse credential\"));\n    }\n}\n\nstatic qqmusic::Task&lt;qqmusic::Result&lt;qqmusic::utils::Credential&gt;&gt; auth_wx_qr(std::string_view code) {\n    auto session = qqmusic::utils::SessionManager::get_instance().get_session();\n    auto api = qqmusic::details::Api(session,\n                                     \"music.login.LoginServer\",\n                                     \"Login\",\n                                     {},\n                                     {{\"tmeLoginType\", \"1\"}});\n    auto req_res = co_await api.prepare_request(\n        {{\"code\", code}, {\"strAppid\", \"wx48db31d50e334801\"}});\n    if (req_res.isErr()) {\n        if (req_res.unwrapErr().get_error_enum()\n            == qqmusic::utils::Exception::CredendialExpiredError) {\n            co_return Err(\n                qqmusic::utils::Exception(qqmusic::utils::Exception::LoginError,\n                                          \"[auth_wx_qr] -- Cannot authorize for multiple times\"));\n        }\n        co_return Err(qqmusic::utils::Exception(\n            qqmusic::utils::Exception::DataDestroy,\n            std::format(\"[auth_wx_qr] -- Error occurred when preparing request: `{}`\",\n                        req_res.unwrapErr().what())));\n    }\n\n    auto cred_url = req_res.unwrap().url;\n    auto cred_req = req_res.unwrap().req;\n    auto credential_res = co_await session.perform_request(cred_url, cred_req);\n    if (credential_res.isErr()) {\n        if (credential_res.unwrapErr().get_error_enum()\n            == qqmusic::utils::Exception::CredendialExpiredError) {\n            co_return Err(\n                qqmusic::utils::Exception(qqmusic::utils::Exception::LoginError,\n                                          \"[auth_wx_qr] -- Cannot authorize for multiple times\"));\n        }\n        co_return Err(qqmusic::utils::Exception(\n            qqmusic::utils::Exception::NetworkError,\n            std::format(\"[auth_qq_qr] -- Error occurred when getting credential: `{}`\",\n                        credential_res.unwrapErr().what())));\n    }\n\n    auto credential_raw_res = api.parse_response(qqmusic::utils::resp2buf(credential_res.unwrap()));\n    if (credential_raw_res.isErr()) {\n        co_return Err(qqmusic::utils::Exception(qqmusic::utils::Exception::DataDestroy,\n                                                \"[auth_wx_qr] -- Cannot parse response\"));\n    }\n    try {\n        co_return Ok(qqmusic::utils::Credential(credential_raw_res.unwrap()));\n    } catch (const std::exception&amp; e) {\n        co_return Err(qqmusic::utils::Exception(qqmusic::utils::Exception::JsonError,\n                                                \"[auth_wx_qr] -- Cannot parse credential\"));\n    }\n}\n</code></pre>"},{"location":"dictionary/lyric_8cc/","title":"File lyric.cc","text":"<p>FileList &gt; src &gt; lyric.cc</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;qqmusic/details/api.h&gt;</code></li> <li><code>#include &lt;qqmusic/lyric.h&gt;</code></li> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/buffer.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/common.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/session.h&gt;</code></li> </ul>"},{"location":"dictionary/lyric_8cc/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic <p>The documentation for this class was generated from the following file <code>src/lyric.cc</code></p>"},{"location":"dictionary/lyric_8cc_source/","title":"File lyric.cc","text":"<p>File List &gt; src &gt; lyric.cc</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;qqmusic/details/api.h&gt;\n#include &lt;qqmusic/lyric.h&gt;\n#include &lt;qqmusic/result.h&gt;\n#include &lt;qqmusic/utils/buffer.h&gt;\n#include &lt;qqmusic/utils/common.h&gt;\n#include &lt;qqmusic/utils/session.h&gt;\n\nnamespace qqmusic {\n\nTask&lt;Result&lt;Lyric&gt;&gt; get_lyric(std::string_view mid, bool qrc, bool trans, bool roma) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.musichallSong.PlayLyricInfo\", \"GetPlayLyricInfo\");\n    nlohmann::json params = {{\"crypt\", 1},\n                             {\"ct\", 11},\n                             {\"cv\", 13020508},\n                             {\"lrc_t\", 0},\n                             {\"qrc\", (unsigned) qrc},\n                             {\"qrc_t\", 0},\n                             {\"roma\", (unsigned) roma},\n                             {\"roma_t\", 0},\n                             {\"trans\", (unsigned) trans},\n                             {\"trans_t\", 0},\n                             {\"type\", 1},\n                             {\"songMid\", mid}};\n\n    auto req_res = co_await api.prepare_request(params);\n    if (req_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_lyric] -- Error occurred when preparing request: `{}`\",\n                        req_res.unwrapErr().what())));\n    }\n\n    auto url = req_res.unwrap().url;\n    auto req = req_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_lyric] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto data_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (data_res.isErr()) {\n        co_return Err(\n            utils::Exception(utils::Exception::DataDestroy,\n                             std::format(\"[get_lyric] -- Error occurred when parsing reponse: `{}`\",\n                                         data_res.unwrapErr().what())));\n    }\n\n    auto data = data_res.unwrap();\n    if (!data.contains(\"lyric\") || !data.contains(\"trans\") || !data.contains(\"roma\")) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            \"[get_lyric] -- Assert data contains field `lyric`, `trans` and `roma` failed\"));\n    }\n\n    Lyric res{};\n\n    utils::buffer lyric_buf{utils::hex2buf(data[\"lyric\"].get&lt;std::string&gt;())};\n    if (lyric_buf.size() == 0) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_lyric] -- Cannot find lyric, may be `{}` is not a song\", mid)));\n    }\n    auto lyric_res = utils::qrc_decode(lyric_buf, utils::qrc_type::cloud);\n    if (lyric_res.isErr()) {\n        co_return Err(utils::Exception(utils::Exception::DataDestroy,\n                                       std::format(\"[get_lyric] -- Lyric decode error: `{}`\",\n                                                   lyric_res.unwrapErr().what())));\n    }\n    res.lyric = lyric_res.unwrap();\n\n    utils::buffer trans_buf{utils::hex2buf(data[\"trans\"].get&lt;std::string&gt;())};\n    if (trans &amp;&amp; trans_buf.size()) {\n        auto trans_res = utils::qrc_decode(trans_buf, utils::qrc_type::cloud);\n        if (trans_res.isErr()) {\n            co_return Err(utils::Exception(utils::Exception::DataDestroy,\n                                           std::format(\"[get_lyric] -- Lyric decode error: `{}`\",\n                                                       trans_res.unwrapErr().what())));\n        }\n        res.trans = trans_res.unwrap();\n    }\n\n    utils::buffer roma_buf{utils::hex2buf(data[\"roma\"].get&lt;std::string&gt;())};\n    if (roma &amp;&amp; roma_buf.size()) {\n        auto roma_res = utils::qrc_decode(roma_buf, utils::qrc_type::cloud);\n        if (roma_res.isErr()) {\n            co_return Err(utils::Exception(utils::Exception::DataDestroy,\n                                           std::format(\"[get_lyric] -- Lyric decode error: `{}`\",\n                                                       roma_res.unwrapErr().what())));\n        }\n        res.roma = roma_res.unwrap();\n    }\n\n    co_return Ok(res);\n}\n\nTask&lt;Result&lt;Lyric&gt;&gt; get_lyric(uint64_t id, bool qrc, bool trans, bool roma) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.musichallSong.PlayLyricInfo\", \"GetPlayLyricInfo\");\n    nlohmann::json params = {{\"crypt\", 1},\n                             {\"ct\", 11},\n                             {\"cv\", 13020508},\n                             {\"lrc_t\", 0},\n                             {\"qrc\", (unsigned) qrc},\n                             {\"qrc_t\", 0},\n                             {\"roma\", (unsigned) roma},\n                             {\"roma_t\", 0},\n                             {\"trans\", (unsigned) trans},\n                             {\"trans_t\", 0},\n                             {\"type\", 1},\n                             {\"songId\", id}};\n\n    auto req_res = co_await api.prepare_request(params);\n    if (req_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_lyric] -- Error occurred when preparing request: `{}`\",\n                        req_res.unwrapErr().what())));\n    }\n\n    auto url = req_res.unwrap().url;\n    auto req = req_res.unwrap().req;\n    req.prepare_payload();\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_lyric] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto data_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (data_res.isErr()) {\n        co_return Err(\n            utils::Exception(utils::Exception::DataDestroy,\n                             std::format(\"[get_lyric] -- Error occurred when parsing reponse: `{}`\",\n                                         data_res.unwrapErr().what())));\n    }\n\n    auto data = data_res.unwrap();\n    if (!data.contains(\"lyric\") || !data.contains(\"trans\") || !data.contains(\"roma\")) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            \"[get_lyric] -- Assert data contains field `lyric`, `trans` and `roma` failed\"));\n    }\n\n    Lyric res{};\n\n    utils::buffer lyric_buf{utils::hex2buf(data[\"lyric\"].get&lt;std::string&gt;())};\n    if (lyric_buf.size() == 0) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_lyric] -- Cannot find lyric, may be `{}` is not a song\", id)));\n    }\n    auto lyric_res = utils::qrc_decode(lyric_buf, utils::qrc_type::cloud);\n    if (lyric_res.isErr()) {\n        co_return Err(utils::Exception(utils::Exception::DataDestroy,\n                                       std::format(\"[get_lyric] -- Lyric decode error: `{}`\",\n                                                   lyric_res.unwrapErr().what())));\n    }\n    res.lyric = lyric_res.unwrap();\n\n    utils::buffer trans_buf{utils::hex2buf(data[\"trans\"].get&lt;std::string&gt;())};\n    if (trans &amp;&amp; trans_buf.size()) {\n        auto trans_res = utils::qrc_decode(trans_buf, utils::qrc_type::cloud);\n        if (trans_res.isErr()) {\n            co_return Err(utils::Exception(utils::Exception::DataDestroy,\n                                           std::format(\"[get_lyric] -- Lyric decode error: `{}`\",\n                                                       trans_res.unwrapErr().what())));\n        }\n        res.trans = trans_res.unwrap();\n    }\n\n    utils::buffer roma_buf{utils::hex2buf(data[\"roma\"].get&lt;std::string&gt;())};\n    if (roma &amp;&amp; roma_buf.size()) {\n        auto roma_res = utils::qrc_decode(roma_buf, utils::qrc_type::cloud);\n        if (roma_res.isErr()) {\n            co_return Err(utils::Exception(utils::Exception::DataDestroy,\n                                           std::format(\"[get_lyric] -- Lyric decode error: `{}`\",\n                                                       roma_res.unwrapErr().what())));\n        }\n        res.roma = roma_res.unwrap();\n    }\n\n    co_return Ok(res);\n    co_return Err(utils::Exception(utils::Exception::UnknownError, \"Not implemented yet\"));\n}\n\n} // namespace qqmusic\n</code></pre>"},{"location":"dictionary/mv_8cc/","title":"File mv.cc","text":"<p>FileList &gt; src &gt; mv.cc</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"qqmusic/details/result.h\"</code></li> <li><code>#include &lt;boost/uuid.hpp&gt;</code></li> <li><code>#include &lt;boost/uuid/uuid_io.hpp&gt;</code></li> <li><code>#include &lt;qqmusic/details/api.h&gt;</code></li> <li><code>#include &lt;qqmusic/mv.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/common.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/session.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"dictionary/mv_8cc/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic <p>The documentation for this class was generated from the following file <code>src/mv.cc</code></p>"},{"location":"dictionary/mv_8cc_source/","title":"File mv.cc","text":"<p>File List &gt; src &gt; mv.cc</p> <p>Go to the documentation of this file</p> <pre><code>#include \"qqmusic/details/result.h\"\n#include &lt;boost/uuid.hpp&gt;\n#include &lt;boost/uuid/uuid_io.hpp&gt;\n#include &lt;qqmusic/details/api.h&gt;\n#include &lt;qqmusic/mv.h&gt;\n#include &lt;qqmusic/utils/common.h&gt;\n#include &lt;qqmusic/utils/session.h&gt;\n#include &lt;string&gt;\n\nnamespace qqmusic {\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_mv_detail(std::span&lt;std::string&gt; vids) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"video.VideoDataServer\", \"get_video_info_batch\");\n    nlohmann::json params = {\n        {\"vidlist\", vids},\n        {\"required\",\n         {\n             \"vid\",\n             \"type\",\n             \"sid\",\n             \"cover_pic\",\n             \"duration\",\n             \"singers\",\n             \"video_switch\",\n             \"msg\",\n             \"name\",\n             \"desc\",\n             \"playcnt\",\n             \"pubdate\",\n             \"isfav\",\n             \"gmid\",\n             \"uploader_headurl\",\n             \"uploader_nick\",\n             \"uploader_encuin\",\n             \"uploader_uin\",\n             \"uploader_hasfollow\",\n             \"uploader_follower_num\",\n             \"uploader_hasfollow\",\n             \"related_songs\",\n         }},\n    };\n\n    auto req_res = co_await api.prepare_request(params);\n    if (req_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_mv_detail] -- Error occurred when preparing request: `{}`\",\n                        req_res.unwrapErr().what())));\n    }\n\n    auto url = req_res.unwrap().url;\n    auto req = req_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_mv_detail] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto data_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (data_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_mv_detail] -- Error occurred when parsing reponse: `{}`\",\n                        data_res.unwrapErr().what())));\n    }\n\n    co_return Ok(data_res.unwrap());\n}\n\nTask&lt;Result&lt;std::vector&lt;MvUrl&gt;&gt;&gt; get_mv_urls(std::span&lt;std::string&gt; vids) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.stream.MvUrlProxy\", \"GetMvUrls\");\n    boost::uuids::uuid uuid = boost::uuids::random_generator()();\n    nlohmann::json params = {\n        {\"vids\", vids},\n        {\"request_type\", 10003},\n        {\"guid\", boost::uuids::to_string(uuid)},\n        {\"videoformat\", 1},\n        {\"format\", 265},\n        {\"dolby\", 1},\n        {\"use_new_domain\", 1},\n        {\"use_ipv6\", 1},\n    };\n\n    auto req_res = co_await api.prepare_request(params);\n    if (req_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_mv_urls] -- Error occurred when preparing request: `{}`\",\n                        req_res.unwrapErr().what())));\n    }\n\n    auto url = req_res.unwrap().url;\n    auto req = req_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_mv_urls] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto data_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (data_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_mv_urls] -- Error occurred when parsing reponse: `{}`\",\n                        data_res.unwrapErr().what())));\n    }\n\n    std::vector&lt;MvUrl&gt; res;\n    auto get_play_urls = [](nlohmann::json&amp; data) {\n        std::map&lt;std::string, std::string&gt; res;\n        for (auto&amp; url_info : data) {\n            if (url_info.contains(\"freeflow_url\") &amp;&amp; url_info[\"freeflow_url\"].size()\n                &amp;&amp; url_info.contains(\"filetype\")) {\n                std::string type = std::to_string(url_info[\"filetype\"].get&lt;uint64_t&gt;());\n                res[type] = url_info[\"freeflow_url\"][0].get&lt;std::string&gt;();\n            }\n        }\n        return res;\n    };\n    auto data = data_res.unwrap();\n    for (auto&amp; i : data.items()) {\n        if (!i.value().contains(\"mp4\") || !i.value().contains(\"hls\")) {\n            co_return Err(utils::Exception(\n                utils::Exception::DataDestroy,\n                \"[get_mv_urls] -- Assert data contains fields `mp4` and `hls` failed.\"));\n        }\n\n        MvUrl item;\n        item.vid = i.key();\n        item.mp4 = get_play_urls(i.value()[\"mp4\"]);\n        item.hls = get_play_urls(i.value()[\"hls\"]);\n        res.push_back(item);\n    }\n    co_return Ok(res);\n}\n\n} // namespace qqmusic\n</code></pre>"},{"location":"dictionary/search_8cc/","title":"File search.cc","text":"<p>FileList &gt; src &gt; search.cc</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/beast/core/buffers_to_string.hpp&gt;</code></li> <li><code>#include &lt;boost/beast/http.hpp&gt;</code></li> <li><code>#include &lt;boost/url/urls.hpp&gt;</code></li> <li><code>#include &lt;qqmusic/details/api.h&gt;</code></li> <li><code>#include &lt;qqmusic/search.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/common.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/session.h&gt;</code></li> </ul>"},{"location":"dictionary/search_8cc/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic <p>The documentation for this class was generated from the following file <code>src/search.cc</code></p>"},{"location":"dictionary/search_8cc_source/","title":"File search.cc","text":"<p>File List &gt; src &gt; search.cc</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;boost/beast/core/buffers_to_string.hpp&gt;\n#include &lt;boost/beast/http.hpp&gt;\n#include &lt;boost/url/urls.hpp&gt;\n#include &lt;qqmusic/details/api.h&gt;\n#include &lt;qqmusic/search.h&gt;\n#include &lt;qqmusic/utils/common.h&gt;\n#include &lt;qqmusic/utils/session.h&gt;\n\nnamespace qqmusic {\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; hotkey() {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.musicsearch.HotkeyService\", \"GetHotkeyForQQMusicMobile\");\n\n    nlohmann::json params = {{\"search_id\", utils::get_search_id()}};\n\n    auto req_param_res = co_await api.prepare_request(params);\n    if (req_param_res.isErr()) {\n        co_return Err(\n            utils::Exception(utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n                             std::format(\"[hotkey] -- Error occurred when preparing request: `{}`\",\n                                         req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(\n            utils::Exception(utils::Exception::NetworkError,\n                             std::format(\"[hotkey] -- Error occurred when performing request: `{}`\",\n                                         response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(\n            utils::Exception(utils::Exception::DataDestroy,\n                             std::format(\"[hotkey] -- Error occurred when parsing reponse: `{}`\",\n                                         response_json_res.unwrapErr().what())));\n    }\n    auto response_json = response_json_res.unwrap();\n    co_return Ok(response_json);\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; keyword_complete(std::string_view keyword) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.smartboxCgi.SmartBoxCgi\", \"GetSmartBoxResult\");\n\n    nlohmann::json params = {{\"search_id\", utils::get_search_id()},\n                             {\"query\", keyword},\n                             {\"num_per_page\", 0},\n                             {\"page_idx\", 0}};\n\n    auto req_param_res = co_await api.prepare_request(params);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[keyword_complete] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[keyword_complete] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[keyword_complete] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n    auto response_json = response_json_res.unwrap();\n    co_return Ok(response_json);\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; quick_search(std::string_view keyword) {\n    namespace http = boost::beast::http;\n    auto session = utils::SessionManager::get_instance().get_session();\n    boost::url url{\"https://c.y.qq.com/splcloud/fcgi-bin/smartbox_new.fcg\"};\n    url.set_params({{\"key\", keyword}});\n    http::request&lt;http::string_body&gt; req{http::verb::get, url, 11};\n    req.set(http::field::host, url.host());\n    req.set(http::field::accept, \"*/*\");\n    /*use raw buffer instead of compressed buffer when debuging*/\n    req.set(http::field::accept_encoding, \"identity\");\n    req.set(http::field::connection, \"keep-alive\");\n    req.set(http::field::user_agent,\n            \"Mozilla/5.0 (Windows NT 11.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) \"\n            \"Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.54\");\n\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[quick_search] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    try {\n        auto resp_json = nlohmann::json::parse(\n            boost::beast::buffers_to_string(response_res.unwrap().body().data()));\n        int64_t rc = resp_json[\"code\"].get&lt;int64_t&gt;();\n        switch (rc) {\n        case 0:\n            co_return Ok(resp_json[\"data\"]);\n        case 1000:\n            co_return Err(\n                qqmusic::utils::Exception(qqmusic::utils::Exception::CredendialExpiredError,\n                                          \"[quick_search] -- Credential is expired\"));\n        case 2000:\n            co_return Err(qqmusic::utils::Exception(qqmusic::utils::Exception::SignInvalidError,\n                                                    \"[quick_search] -- Sign is invalid\"));\n        default:\n            co_return Err(qqmusic::utils::Exception(\n                qqmusic::utils::Exception::ResponseCodeError,\n                std::format(\"[quick_search] -- Unexpected response code: {}\", rc)));\n        }\n\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(utils::Exception::JsonError,\n                             std::format(\"[quick_search] -- Cannot parse response: `{}`\",\n                                         e.what())));\n    }\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; general_search(std::string_view keyword,\n                                            unsigned num,\n                                            unsigned page,\n                                            bool highlight) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.adaptor.SearchAdaptor\", \"do_search_v2\");\n\n    nlohmann::json params = {\n        {\"searchid\", utils::get_search_id()},\n        {\"search_type\", 100},\n        {\"page_num\", num},\n        {\"query\", keyword},\n        {\"page_id\", page},\n        {\"highlight\", (unsigned) highlight},\n        {\"grp\", 1},\n    };\n\n    auto req_param_res = co_await api.prepare_request(params);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[general_search] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[general_search] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[general_search] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n    auto response_json = response_json_res.unwrap();\n    co_return Ok(response_json);\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; search_by_type(std::string_view keyword,\n                                            SearchType type,\n                                            unsigned num_per_page,\n                                            unsigned page,\n                                            bool highlight) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.search.SearchCgiService\", \"DoSearchForQQMusicMobile\");\n\n    nlohmann::json params = {\n        {\"searchid\", utils::get_search_id()},\n        {\"search_type\", (unsigned) type},\n        {\"page_num\", page},\n        {\"query\", keyword},\n        {\"num_per_page\", num_per_page},\n        {\"highlight\", (unsigned) highlight},\n        {\"grp\", 1},\n    };\n\n    auto req_param_res = co_await api.prepare_request(params);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[search_by_type] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[search_by_type] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[search_by_type] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n    auto response_json = response_json_res.unwrap();\n    std::string key;\n    switch ((unsigned) type) {\n    case (unsigned) SearchType::SONG:\n    case (unsigned) SearchType::LYRIC:\n    case (unsigned) SearchType::AUDIO:\n        key = \"item_song\";\n        break;\n    case (unsigned) SearchType::SINGER:\n        key = \"singer\";\n        break;\n    case (unsigned) SearchType::ALBUM:\n        key = \"item_album\";\n        break;\n    case (unsigned) SearchType::SONG_LIST:\n        key = \"item_songlist\";\n        break;\n    case (unsigned) SearchType::MV:\n        key = \"item_mv\";\n        break;\n    case (unsigned) SearchType::USER:\n        key = \"item_user\";\n        break;\n    case (unsigned) SearchType::AUDIO_ALBUM:\n        key = \"item_audio\";\n        break;\n    default:\n        co_return Err(utils::Exception(utils::Exception::DataDestroy,\n                                       \"[search_by_type] -- Error enum value of search type\"));\n    }\n\n    try {\n        auto res = response_json[\"body\"][key];\n        co_return Ok(res);\n    } catch (const std::exception&amp; e) {\n        co_return Err(\n            utils::Exception(utils::Exception::DataDestroy,\n                             std::format(\"[search_by_type] -- Cannot get search result: `{}`\",\n                                         e.what())));\n    }\n}\n\n} // namespace qqmusic\n</code></pre>"},{"location":"dictionary/singer_8cc/","title":"File singer.cc","text":"<p>FileList &gt; src &gt; singer.cc</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/asio/this_coro.hpp&gt;</code></li> <li><code>#include &lt;qqmusic/details/api.h&gt;</code></li> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;qqmusic/singer.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/async-executor.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/common.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/session.h&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"dictionary/singer_8cc/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic <p>The documentation for this class was generated from the following file <code>src/singer.cc</code></p>"},{"location":"dictionary/singer_8cc_source/","title":"File singer.cc","text":"<p>File List &gt; src &gt; singer.cc</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;boost/asio/this_coro.hpp&gt;\n#include &lt;qqmusic/details/api.h&gt;\n#include &lt;qqmusic/result.h&gt;\n#include &lt;qqmusic/singer.h&gt;\n#include &lt;qqmusic/utils/async-executor.h&gt;\n#include &lt;qqmusic/utils/common.h&gt;\n#include &lt;qqmusic/utils/session.h&gt;\n#include &lt;utility&gt;\n\nnamespace qqmusic {\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_singer_list(AreaType area, GenderType gender, GenreType genre) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.musichallSinger.SingerList\", \"GetSingerList\");\n    nlohmann::json params = {{\"hastag\", 0},\n                             {\"area\", (int) area},\n                             {\"sex\", (int) gender},\n                             {\"genre\", (int) genre}};\n    auto req_param_res = co_await api.prepare_request(params);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_singer_list] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_singer_list] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_singer_list] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n    auto response_json = response_json_res.unwrap();\n    try {\n        co_return Ok(response_json[\"hotlist\"]);\n    } catch (const std::exception&amp; e) {\n        co_return Err(\n            utils::Exception(utils::Exception::DataDestroy,\n                             std::format(\n                                 \"[get_singer_list] -- Cannot find field `hotlist` in response\")));\n    }\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_singer_list_index(AreaType area,\n                                                   GenderType gender,\n                                                   GenreType genre,\n                                                   IndexType index,\n                                                   unsigned sin,\n                                                   unsigned cur_page) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.musichallSinger.SingerList\", \"GetSingerListIndex\");\n    nlohmann::json params = {{\"hastag\", 0},\n                             {\"area\", (int) area},\n                             {\"sex\", (int) gender},\n                             {\"genre\", (int) genre},\n                             {\"index\", index},\n                             {\"sin\", sin},\n                             {\"cur_page\", cur_page}};\n    auto req_param_res = co_await api.prepare_request(params);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_singer_list_index] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_singer_list_index] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_singer_list_index] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n    auto response_json = response_json_res.unwrap();\n    co_return Ok(response_json);\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_singer_list_index_all(AreaType area,\n                                                       GenderType gender,\n                                                       GenreType genre,\n                                                       IndexType index) {\n    // TODO: I didn't implement a `RequestGroup` as the python did.\n    // so how can I optimize the code to make the requests execute parallel?\n    auto data_res = co_await get_singer_list_index(area, gender, genre, index, 0, 1);\n    if (data_res.isErr()) {\n        co_return Err(data_res.unwrapErr());\n    }\n\n    auto data = data_res.unwrap();\n    nlohmann::json singer_list;\n    unsigned int total;\n    try {\n        total = data[\"total\"];\n        singer_list = std::move(data[\"singerlist\"]);\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(\n            utils::Exception::JsonError,\n            std::format(\"[get_singer_list_index_all] -- Cannot get singer list basic info: `{}`\",\n                        e.what())));\n    }\n\n    if (total &lt;= 80) {\n        co_return Ok(singer_list);\n    }\n\n    unsigned pages = total / 80;\n    std::vector&lt;Task&lt;Result&lt;nlohmann::json&gt;&gt;&gt; tasks;\n    for (unsigned i = 2, sin = 80; i &lt; pages + 2; ++i, sin += 80) {\n        tasks.push_back(get_singer_list_index(area, gender, genre, index, sin, i));\n    }\n\n    auto&amp; async_executor = utils::AsyncExecutor::get_instance();\n    auto all_results = co_await async_executor.when_all(std::move(tasks));\n    for (auto&amp; res : all_results) {\n        if (res.isErr()) {\n            co_return Err(res.unwrapErr());\n        }\n        auto group_new = res.unwrap();\n        if (!group_new.contains(\"singerlist\")) {\n            co_return Err(utils::Exception(\n                utils::Exception::DataDestroy,\n                \"[get_singer_list_index_all] -- Cannot find field `singerlist` in response\"));\n        }\n        singer_list.insert(singer_list.end(), group_new[\"singerlist\"]);\n    }\n\n    co_return Ok(singer_list);\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_singer_info(std::string_view mid) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session,\n                            \"music.UnifiedHomepage.UnifiedHomepageSrv\",\n                            \"GetHomepageHeader\");\n    nlohmann::json params = {{\"SingerMid\", mid}};\n    auto req_param_res = co_await api.prepare_request(params);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_singer_info] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_singer_info] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_singer_info] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n    auto response_json = response_json_res.unwrap();\n    co_return Ok(response_json);\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_tab_detail(std::string_view mid,\n                                            TabType type,\n                                            unsigned page,\n                                            unsigned num) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session,\n                            \"music.UnifiedHomepage.UnifiedHomepageSrv\",\n                            \"GetHomepageTabDetail\");\n    nlohmann::json params = {{\"SingerMid\", mid},\n                             {\"IsQueryTabDetail\", 1},\n                             {\"TabID\", type.get_id()},\n                             {\"PageNum\", page - 1},\n                             {\"PageSize\", num},\n                             {\"Order\", 0}};\n    auto req_param_res = co_await api.prepare_request(params);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_singer_info] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_singer_info] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_singer_info] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n\n    try {\n        auto data = response_json_res.unwrap();\n        auto result = data.value(\"List\", data.value(\"VideoList\", data.value(\"AlbumList\", data)));\n        co_return Ok(result);\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(\n            utils::Exception::JsonError,\n            std::format(\"[get_singer_info] -- Cannot filter result from response: `{}`\", e.what())));\n    }\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_singer_desc(std::span&lt;std::string&gt; mids, unsigned number) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.musichallSinger.SingerInfoInter\", \"GetSingerDetail\");\n    nlohmann::json params = {{\"singer_mids\", mids}, {\"groups\", 1}, {\"wikis\", 1}};\n    auto req_param_res = co_await api.prepare_request(params);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_singer_desc] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_singer_desc] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_singer_desc] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n\n    auto data = response_json_res.unwrap();\n    if (!data.contains(\"singerlist\")) {\n        co_return Err(\n            utils::Exception(utils::Exception::DataDestroy,\n                             \"[get_singer_desc] -- Cannot find field `singerlist` in response\"));\n    }\n    co_return Ok(data[\"singerlist\"]);\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_similar_singers(std::string_view mid, unsigned number) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.SimilarSingerSvr\", \"GetSimilarSingerList\");\n    nlohmann::json params = {{\"singerMid\", mid}, {\"number\", number}};\n    auto req_param_res = co_await api.prepare_request(params);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_similar_singers] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_similar_singers] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_similar_singers] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n    auto response_json = response_json_res.unwrap();\n    try {\n        co_return Ok(response_json[\"singerlist\"]);\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_similar_singers] -- Cannot find field `singerlist` in response\")));\n    }\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_songs_list(std::string_view mid, unsigned num, unsigned begin) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"musichall.song_list_server\", \"GetSingerSongList\");\n    nlohmann::json params = {\n        {\"singerMid\", mid},\n        {\"order\", 1},\n        {\"number\", num},\n        {\"begin\", begin},\n    };\n    auto req_param_res = co_await api.prepare_request(params);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_songs_list] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_songs_list] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_songs_list] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n    auto response_json = response_json_res.unwrap();\n    co_return Ok(response_json);\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_songs_list_all(std::string_view mid) {\n    auto data_res = co_await get_songs_list(mid, 30, 0);\n    if (data_res.isErr()) {\n        co_return Err(data_res.unwrapErr());\n    }\n\n    auto data = data_res.unwrap();\n    nlohmann::json song_list;\n    unsigned int total;\n    try {\n        total = data[\"totalNum\"];\n        for (auto&amp; song : data[\"songList\"]) {\n            song_list.push_back(song[\"songInfo\"]);\n        }\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(\n            utils::Exception::JsonError,\n            std::format(\"[get_singer_list_index_all] -- Cannot get singer list basic info: `{}`\",\n                        e.what())));\n    }\n\n    if (total &lt;= 30) {\n        co_return Ok(song_list);\n    }\n\n    std::vector&lt;Task&lt;Result&lt;nlohmann::json&gt;&gt;&gt; tasks;\n    for (unsigned i = 30; i &lt; total; i += 30) {\n        tasks.push_back(get_songs_list(mid, 30, i));\n    }\n\n    auto&amp; async_executor = utils::AsyncExecutor::get_instance();\n    auto all_results = co_await async_executor.when_all(std::move(tasks));\n    for (auto&amp; res : all_results) {\n        if (res.isErr()) {\n            co_return Err(res.unwrapErr());\n        }\n        auto group_new = res.unwrap();\n        if (!group_new.contains(\"songList\")) {\n            co_return Err(utils::Exception(\n                utils::Exception::DataDestroy,\n                \"[get_singer_list_index_all] -- Cannot find field `songList` in response\"));\n        }\n\n        for (auto&amp; song : group_new[\"songList\"]) {\n            song_list.push_back(song[\"songInfo\"]);\n        }\n    }\n\n    co_return Ok(song_list);\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_album_list(std::string_view mid, unsigned number, unsigned begin) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.musichallAlbum.AlbumListServer\", \"GetAlbumList\");\n    nlohmann::json params = {\n        {\"singerMid\", mid},\n        {\"order\", 1},\n        {\"number\", number},\n        {\"begin\", begin},\n    };\n    auto req_param_res = co_await api.prepare_request(params);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_album_list] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_album_list] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_album_list] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n    auto response_json = response_json_res.unwrap();\n    co_return Ok(response_json);\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_album_list_all(std::string_view mid) {\n    auto data_res = co_await get_album_list(mid, 30, 0);\n    if (data_res.isErr()) {\n        co_return Err(data_res.unwrapErr());\n    }\n\n    auto data = data_res.unwrap();\n    nlohmann::json album_list;\n    unsigned int total;\n    try {\n        total = data[\"total\"];\n        album_list = data[\"albumlist\"];\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(\n            utils::Exception::JsonError,\n            std::format(\"[get_album_list_all] -- Cannot get singer list basic info: `{}`\",\n                        e.what())));\n    }\n\n    if (total &lt;= 30) {\n        co_return Ok(album_list);\n    }\n\n    std::vector&lt;Task&lt;Result&lt;nlohmann::json&gt;&gt;&gt; tasks;\n    for (unsigned i = 30; i &lt; total; i += 30) {\n        tasks.push_back(get_album_list(mid, 30, i));\n    }\n\n    auto&amp; async_executor = utils::AsyncExecutor::get_instance();\n    auto all_results = co_await async_executor.when_all(std::move(tasks));\n    for (auto&amp; res : all_results) {\n        if (res.isErr()) {\n            co_return Err(res.unwrapErr());\n        }\n        auto group_new = res.unwrap();\n        if (!group_new.contains(\"albumList\")) {\n            co_return Err(utils::Exception(\n                utils::Exception::DataDestroy,\n                \"[get_singer_list_index_all] -- Cannot find field `albumList` in response\"));\n        }\n\n        album_list.push_back(group_new[\"albumList\"]);\n    }\n\n    co_return Ok(album_list);\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_mv_list(std::string_view mid, unsigned number, unsigned begin) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"MvService.MvInfoProServer\", \"GetSingerMvList\");\n    nlohmann::json params = {{\"singermid\", mid}, {\"order\", 1}, {\"count\", number}, {\"start\", begin}};\n    auto req_param_res = co_await api.prepare_request(params);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_mv_list] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_mv_list] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_mv_list] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n    auto response_json = response_json_res.unwrap();\n    co_return Ok(response_json);\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_mv_list_all(std::string_view mid) {\n    auto data_res = co_await get_mv_list(mid, 100, 0);\n    if (data_res.isErr()) {\n        co_return Err(data_res.unwrapErr());\n    }\n\n    auto data = data_res.unwrap();\n    nlohmann::json mv_list;\n    unsigned int total;\n    try {\n        total = data[\"total\"];\n        mv_list = data[\"list\"];\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(\n            utils::Exception::JsonError,\n            std::format(\"[get_mv_list_all] -- Cannot get singer list basic info: `{}`\", e.what())));\n    }\n\n    if (total &lt;= 100) {\n        co_return Ok(mv_list);\n    }\n\n    std::vector&lt;Task&lt;Result&lt;nlohmann::json&gt;&gt;&gt; tasks;\n    for (unsigned i = 100; i &lt; total; i += 100) {\n        tasks.push_back(get_mv_list(mid, 100, i));\n    }\n\n    auto&amp; async_executor = utils::AsyncExecutor::get_instance();\n    auto all_results = co_await async_executor.when_all(std::move(tasks));\n    for (auto&amp; res : all_results) {\n        if (res.isErr()) {\n            co_return Err(res.unwrapErr());\n        }\n        auto group_new = res.unwrap();\n        if (!group_new.contains(\"list\")) {\n            co_return Err(utils::Exception(\n                utils::Exception::DataDestroy,\n                \"[get_singer_list_index_all] -- Cannot find field `list` in response\"));\n        }\n\n        mv_list.push_back(group_new[\"list\"]);\n    }\n\n    co_return Ok(mv_list);\n}\n\n} // namespace qqmusic\n</code></pre>"},{"location":"dictionary/song_8cc/","title":"File song.cc","text":"<p>FileList &gt; src &gt; song.cc</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/beast/http/message.hpp&gt;</code></li> <li><code>#include &lt;boost/beast/http/string_body.hpp&gt;</code></li> <li><code>#include &lt;boost/uuid/uuid.hpp&gt;</code></li> <li><code>#include &lt;botan/auto_rng.h&gt;</code></li> <li><code>#include &lt;qqmusic/details/api.h&gt;</code></li> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;qqmusic/song.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/async-executor.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/common.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/session.h&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"dictionary/song_8cc/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic <p>The documentation for this class was generated from the following file <code>src/song.cc</code></p>"},{"location":"dictionary/song_8cc_source/","title":"File song.cc","text":"<p>File List &gt; src &gt; song.cc</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;boost/beast/http/message.hpp&gt;\n#include &lt;boost/beast/http/string_body.hpp&gt;\n#include &lt;boost/uuid/uuid.hpp&gt;\n#include &lt;botan/auto_rng.h&gt;\n#include &lt;qqmusic/details/api.h&gt;\n#include &lt;qqmusic/result.h&gt;\n#include &lt;qqmusic/song.h&gt;\n#include &lt;qqmusic/utils/async-executor.h&gt;\n#include &lt;qqmusic/utils/common.h&gt;\n#include &lt;qqmusic/utils/session.h&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\nnamespace qqmusic {\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; query_song(std::span&lt;std::string&gt; mids) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.trackInfo.UniformRuleCtrl\", \"CgiGetTrackInfo\");\n\n    auto placeholder = std::vector(mids.size(), 0);\n    nlohmann::json params = {{\"types\", placeholder},\n                             {\"modify_stamp\", placeholder},\n                             {\"ctx\", 0},\n                             {\"client\", 1},\n                             {\"mids\", mids}};\n\n    auto req_params = co_await api.prepare_request(params);\n    if (req_params.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_params.unwrapErr().get_error_enum()),\n            std::format(\"[query_song] -- Error occurred when preparing request: `{}`\",\n                        req_params.unwrapErr().what())));\n    }\n\n    auto url = req_params.unwrap().url;\n    auto req = req_params.unwrap().req;\n    auto resp_res = co_await session.perform_request(url, req);\n    if (resp_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[query_song] -- Error occurred when performing request: `{}`\",\n                        resp_res.unwrapErr().what())));\n    }\n\n    auto resp_data = api.parse_response(utils::resp2buf(resp_res.unwrap()));\n    if (resp_data.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[query_song] -- Error occurred when parsing reponse: `{}`\",\n                        resp_data.unwrapErr().what())));\n    }\n    try {\n        auto data = resp_data.unwrap()[\"tracks\"];\n        co_return Ok(data);\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(utils::Exception::JsonError,\n                                       \"[query_song] -- Cannot get `tracks` from data\"));\n    }\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; query_song(std::span&lt;uint64_t&gt; ids) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.trackInfo.UniformRuleCtrl\", \"CgiGetTrackInfo\");\n\n    auto placeholder = std::vector(ids.size(), 0);\n    nlohmann::json params = {{\"types\", placeholder},\n                             {\"modify_stamp\", placeholder},\n                             {\"ctx\", 0},\n                             {\"client\", 1},\n                             {\"mids\", ids}};\n\n    auto req_params = co_await api.prepare_request(params);\n    if (req_params.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_params.unwrapErr().get_error_enum()),\n            std::format(\"[query_song] -- Error occurred when preparing request: `{}`\",\n                        req_params.unwrapErr().what())));\n    }\n\n    auto url = req_params.unwrap().url;\n    auto req = req_params.unwrap().req;\n    auto resp_res = co_await session.perform_request(url, req);\n    if (resp_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[query_song] -- Error occurred when performing request: `{}`\",\n                        resp_res.unwrapErr().what())));\n    }\n\n    auto resp_data = api.parse_response(utils::resp2buf(resp_res.unwrap()));\n    if (resp_data.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[query_song] -- Error occurred when parsing reponse: `{}`\",\n                        resp_data.unwrapErr().what())));\n    }\n    try {\n        auto data = resp_data.unwrap()[\"tracks\"];\n        co_return Ok(data);\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(utils::Exception::JsonError,\n                                       \"[query_song] -- Cannot get `tracks` from data\"));\n    }\n    co_return Err(utils::Exception(utils::Exception::UnknownError, \"Not implemented\"));\n}\n\nTask&lt;Result&lt;std::vector&lt;SongInfo&gt;&gt;&gt; get_song_urls(std::span&lt;std::string&gt; mids,\n                                                  std::unique_ptr&lt;BaseMediaFileType&gt; file_type,\n                                                  std::optional&lt;utils::Credential&gt; credential) {\n    if (file_type == nullptr) {\n        file_type = std::make_unique&lt;SongFileType&gt;();\n    }\n    bool encrypted = file_type-&gt;encrypted();\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session,\n                            encrypted ? \"music.vkey.GetEVkey\" : \"music.vkey.GetVkey\",\n                            encrypted ? \"CgiGetEVkey\" : \"UrlGetVkey\",\n                            credential.has_value() ? credential.value() : utils::Credential{});\n    auto rng = Botan::AutoSeeded_RNG();\n\n    auto gen_hex_strings = [&amp;rng](unsigned len) {\n        const char table[] = \"abcdef1234567890\";\n        uint64_t randi = 0;\n        std::vector&lt;uint8_t&gt; buffer(sizeof(randi));\n        rng.randomize(buffer);\n        memcpy(&amp;randi, buffer.data(), sizeof(randi));\n        std::vector&lt;char&gt; res(len);\n        for (auto&amp; i : res) {\n            rng.randomize(buffer);\n            memcpy(&amp;randi, buffer.data(), sizeof(randi));\n            i = table[randi % 16];\n        }\n        return std::string(res.data(), res.size());\n    };\n\n    std::vector&lt;Task&lt;Result&lt;details::RequestParam&gt;&gt;&gt; request_group;\n    unsigned full_group_num = mids.size() / 100;\n    /* slice mids into groups. the max request id amount is 100 */\n    for (unsigned i = 0; i &lt; full_group_num; ++i) {\n        auto it = mids.begin() + i * 100;\n        auto group = std::span&lt;std::string&gt;{it, it + 100};\n        std::vector&lt;std::string&gt; name_list;\n        for (auto&amp; mid : group) {\n            std::string file_name;\n            file_name += file_type-&gt;prefix();\n            file_name += mid;\n            file_name += mid;\n            file_name += file_type-&gt;expandation();\n            name_list.push_back(file_name);\n        }\n        std::vector&lt;int&gt; placeholder{100, 0};\n        nlohmann::json params = {\n            {\"filename\", name_list},\n            {\"guid\", gen_hex_strings(32)},\n            {\"songmid\", group},\n            {\"songtype\", placeholder},\n        };\n        request_group.push_back(api.prepare_request(params));\n    }\n\n    /* handle the left mids */\n    auto group_rest = std::span&lt;std::string&gt;{mids.begin() + full_group_num * 100, mids.end()};\n    std::vector&lt;std::string&gt; name_list;\n    for (auto&amp; mid : group_rest) {\n        std::string file_name;\n        file_name += file_type-&gt;prefix();\n        file_name += mid;\n        file_name += mid;\n        file_name += file_type-&gt;expandation();\n        name_list.push_back(file_name);\n    }\n    std::vector&lt;int&gt; placeholder{100, 0};\n    nlohmann::json params = {\n        {\"filename\", name_list},\n        {\"guid\", gen_hex_strings(32)},\n        {\"songmid\", group_rest},\n        {\"songtype\", placeholder},\n    };\n    request_group.push_back(api.prepare_request(params));\n\n    /* wrap the request and the post-process to task */\n    auto task = [&amp;session,\n                 &amp;api,\n                 encrypted](boost::url url,\n                            boost::beast::http::request&lt;boost::beast::http::string_body&gt; req)\n        -&gt; Task&lt;Result&lt;std::vector&lt;SongInfo&gt;&gt;&gt; {\n        static const char domain[] = \"https://isure.stream.qqmusic.qq.com/\";\n        auto res = co_await session.perform_request(url, req);\n        if (res.isErr()) {\n            co_return Err(res.unwrapErr());\n        }\n\n        auto resp = api.parse_response(utils::resp2buf(res.unwrap()));\n        if (resp.isErr()) {\n            co_return Err(utils::Exception(\n                utils::Exception::DataDestroy,\n                std::format(\"[get_song_urls] -- Error occurred when parsing reponse: `{}`\",\n                            resp.unwrapErr().what())));\n        }\n\n        std::vector&lt;SongInfo&gt; list{};\n\n        try {\n            auto data = resp.unwrap()[\"midurlinfo\"];\n            for (auto&amp; info : data) {\n                SongInfo item;\n                item.mid = info[\"songmid\"];\n                auto url = info[\"wifiurl\"].get&lt;std::string&gt;();\n                if (url.size()) {\n                    item.url = domain + url;\n                }\n                if (encrypted) {\n                    item.ekey = info[\"ekey\"];\n                }\n                list.push_back(item);\n            }\n            co_return Ok(list);\n        } catch (const std::exception&amp; e) {\n            co_return Err(utils::Exception(utils::Exception::JsonError,\n                                           \"[get_song_urls] -- Cannot process the result\"));\n        }\n    };\n\n    auto&amp; executor = utils::AsyncExecutor::get_instance();\n    auto requests = co_await executor.when_all(std::move(request_group));\n    std::vector&lt;Task&lt;Result&lt;std::vector&lt;SongInfo&gt;&gt;&gt;&gt; tasks;\n    for (auto&amp; req_params : requests) {\n        if (req_params.isErr()) {\n            co_return Err(utils::Exception(utils::Exception::DataDestroy,\n                                           \"[get_song_urls] -- Prepare request error\"));\n        }\n        tasks.push_back(task(req_params.unwrap().url, req_params.unwrap().req));\n    }\n\n    std::vector&lt;SongInfo&gt; song_list;\n    auto all_results = co_await executor.when_all(std::move(tasks));\n    for (auto&amp; res : all_results) {\n        if (res.isErr()) {\n            co_return Err(res.unwrapErr());\n        }\n        auto next = res.unwrap();\n        song_list.insert(song_list.end(), next.begin(), next.end());\n    }\n\n    co_return Ok(song_list);\n}\n\nTask&lt;Result&lt;std::string&gt;&gt; get_try_url(std::string_view mid, std::string_view vs) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.vkey.GetVkey\", \"UrlGetVkey\");\n\n    auto rng = Botan::AutoSeeded_RNG();\n\n    auto gen_hex_strings = [&amp;rng](unsigned len) {\n        const char table[] = \"abcdef1234567890\";\n        uint64_t randi = 0;\n        std::vector&lt;uint8_t&gt; buffer(sizeof(randi));\n        rng.randomize(buffer);\n        memcpy(&amp;randi, buffer.data(), sizeof(randi));\n        std::vector&lt;char&gt; res(len);\n        for (auto&amp; i : res) {\n            rng.randomize(buffer);\n            memcpy(&amp;randi, buffer.data(), sizeof(randi));\n            i = table[randi % 16];\n        }\n        return std::string(res.data(), res.size());\n    };\n\n    std::vector&lt;std::string&gt; list{std::string{mid}};\n    nlohmann::json params = {\n        {\"filename\", std::format(\"RS02{}.mp3\", vs)},\n        {\"guid\", gen_hex_strings(32)},\n        {\"songmid\", list},\n        {\"songtype\", std::vector&lt;int&gt;{1}},\n    };\n\n    auto req_params = co_await api.prepare_request(params);\n    if (req_params.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_params.unwrapErr().get_error_enum()),\n            std::format(\"[get_try_url] -- Error occurred when preparing request: `{}`\",\n                        req_params.unwrapErr().what())));\n    }\n\n    auto url = req_params.unwrap().url;\n    auto req = req_params.unwrap().req;\n    auto resp_res = co_await session.perform_request(url, req);\n    if (resp_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_try_url] -- Error occurred when performing request: `{}`\",\n                        resp_res.unwrapErr().what())));\n    }\n\n    auto resp_data = api.parse_response(utils::resp2buf(resp_res.unwrap()));\n    if (resp_data.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_try_url] -- Error occurred when parsing reponse: `{}`\",\n                        resp_data.unwrapErr().what())));\n    }\n    try {\n        auto data = resp_data.unwrap()[\"midurlinfo\"][0];\n        if (data[\"wifiurl\"].size()) {\n            co_return Ok(std::format(\"https://isure.stream.qqmusic.qq.com/{}\",\n                                     data[\"wifiurl\"].get&lt;std::string&gt;()));\n        } else {\n            co_return Ok(std::string{});\n        }\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(utils::Exception::JsonError,\n                                       \"[get_try_url] -- Cannot get `tracks` from data\"));\n    }\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_song_detail(std::string_view mid) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.pf_song_detail_svr\", \"get_song_detail_yqq\");\n    nlohmann::json params = {{\"song_mid\", mid}};\n\n    auto req_params = co_await api.prepare_request(params);\n    if (req_params.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_params.unwrapErr().get_error_enum()),\n            std::format(\"[get_song_detail] -- Error occurred when preparing request: `{}`\",\n                        req_params.unwrapErr().what())));\n    }\n\n    auto url = req_params.unwrap().url;\n    auto req = req_params.unwrap().req;\n    auto resp_res = co_await session.perform_request(url, req);\n    if (resp_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_song_detail] -- Error occurred when performing request: `{}`\",\n                        resp_res.unwrapErr().what())));\n    }\n\n    auto resp_data = api.parse_response(utils::resp2buf(resp_res.unwrap()));\n    if (resp_data.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_song_detail] -- Error occurred when parsing reponse: `{}`\",\n                        resp_data.unwrapErr().what())));\n    }\n    try {\n        co_return Ok(resp_data.unwrap());\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(utils::Exception::JsonError,\n                                       \"[get_song_detail] -- Cannot get `tracks` from data\"));\n    }\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_song_detail(uint64_t id) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.pf_song_detail_svr\", \"get_song_detail_yqq\");\n    nlohmann::json params = {{\"song_id\", id}};\n\n    auto req_params = co_await api.prepare_request(params);\n    if (req_params.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_params.unwrapErr().get_error_enum()),\n            std::format(\"[get_song_detail] -- Error occurred when preparing request: `{}`\",\n                        req_params.unwrapErr().what())));\n    }\n\n    auto url = req_params.unwrap().url;\n    auto req = req_params.unwrap().req;\n    auto resp_res = co_await session.perform_request(url, req);\n    if (resp_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_song_detail] -- Error occurred when performing request: `{}`\",\n                        resp_res.unwrapErr().what())));\n    }\n\n    auto resp_data = api.parse_response(utils::resp2buf(resp_res.unwrap()));\n    if (resp_data.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_song_detail] -- Error occurred when parsing reponse: `{}`\",\n                        resp_data.unwrapErr().what())));\n    }\n    try {\n        co_return Ok(resp_data.unwrap());\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(utils::Exception::JsonError,\n                                       \"[get_song_detail] -- Cannot get `tracks` from data\"));\n    }\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_similar_songs(uint64_t songid) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.recommend.TrackRelationServer\", \"GetSimilarSongs\");\n\n    nlohmann::json params = {{\"songid\", songid}};\n\n    auto req_params = co_await api.prepare_request(params);\n    if (req_params.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_params.unwrapErr().get_error_enum()),\n            std::format(\"[get_similar_songs] -- Error occurred when preparing request: `{}`\",\n                        req_params.unwrapErr().what())));\n    }\n\n    auto url = req_params.unwrap().url;\n    auto req = req_params.unwrap().req;\n    auto resp_res = co_await session.perform_request(url, req);\n    if (resp_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_similar_songs] -- Error occurred when performing request: `{}`\",\n                        resp_res.unwrapErr().what())));\n    }\n\n    auto resp_data = api.parse_response(utils::resp2buf(resp_res.unwrap()));\n    if (resp_data.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_similar_songs] -- Error occurred when parsing reponse: `{}`\",\n                        resp_data.unwrapErr().what())));\n    }\n    try {\n        auto data = resp_data.unwrap()[\"vecSong\"];\n        co_return Ok(data);\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(utils::Exception::JsonError,\n                                       \"[get_similar_songs] -- Cannot get `vecSong` from data\"));\n    }\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_labels(uint64_t songid) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.recommend.TrackRelationServer\", \"GetSongLabels\");\n\n    nlohmann::json params = {{\"songid\", songid}};\n\n    auto req_params = co_await api.prepare_request(params);\n    if (req_params.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_params.unwrapErr().get_error_enum()),\n            std::format(\"[get_labels] -- Error occurred when preparing request: `{}`\",\n                        req_params.unwrapErr().what())));\n    }\n\n    auto url = req_params.unwrap().url;\n    auto req = req_params.unwrap().req;\n    auto resp_res = co_await session.perform_request(url, req);\n    if (resp_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_labels] -- Error occurred when performing request: `{}`\",\n                        resp_res.unwrapErr().what())));\n    }\n\n    auto resp_data = api.parse_response(utils::resp2buf(resp_res.unwrap()));\n    if (resp_data.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_labels] -- Error occurred when parsing reponse: `{}`\",\n                        resp_data.unwrapErr().what())));\n    }\n    try {\n        auto data = resp_data.unwrap()[\"labels\"];\n        co_return Ok(data);\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(utils::Exception::JsonError,\n                                       \"[get_labels] -- Cannot get `labels` from data\"));\n    }\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_related_songlist(uint64_t songid) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.recommend.TrackRelationServer\", \"GetRelatedPlaylist\");\n\n    nlohmann::json params = {{\"songid\", songid}};\n\n    auto req_params = co_await api.prepare_request(params);\n    if (req_params.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_params.unwrapErr().get_error_enum()),\n            std::format(\"[get_related_songlist] -- Error occurred when preparing request: `{}`\",\n                        req_params.unwrapErr().what())));\n    }\n\n    auto url = req_params.unwrap().url;\n    auto req = req_params.unwrap().req;\n    auto resp_res = co_await session.perform_request(url, req);\n    if (resp_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_related_songlist] -- Error occurred when performing request: `{}`\",\n                        resp_res.unwrapErr().what())));\n    }\n\n    auto resp_data = api.parse_response(utils::resp2buf(resp_res.unwrap()));\n    if (resp_data.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_related_songlist] -- Error occurred when parsing reponse: `{}`\",\n                        resp_data.unwrapErr().what())));\n    }\n    try {\n        auto data = resp_data.unwrap()[\"vecPlaylist\"];\n        co_return Ok(data);\n    } catch (const std::exception&amp; e) {\n        co_return Err(\n            utils::Exception(utils::Exception::JsonError,\n                             \"[get_related_songlist] -- Cannot get `vecPlaylist` from data\"));\n    }\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_related_mv(uint64_t songid, std::optional&lt;std::string&gt; last_mvid) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"MvService.MvInfoProServer\", \"GetSongRelatedMv\");\n\n    nlohmann::json params = {{\"songid\", songid}, {\"songtype\", 1}};\n    if (last_mvid.has_value()) {\n        params.push_back({\"lastmvid\", last_mvid.value()});\n    }\n\n    auto req_params = co_await api.prepare_request(params);\n    if (req_params.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_params.unwrapErr().get_error_enum()),\n            std::format(\"[get_related_mv] -- Error occurred when preparing request: `{}`\",\n                        req_params.unwrapErr().what())));\n    }\n\n    auto url = req_params.unwrap().url;\n    auto req = req_params.unwrap().req;\n    auto resp_res = co_await session.perform_request(url, req);\n    if (resp_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_related_mv] -- Error occurred when performing request: `{}`\",\n                        resp_res.unwrapErr().what())));\n    }\n\n    auto resp_data = api.parse_response(utils::resp2buf(resp_res.unwrap()));\n    if (resp_data.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_related_mv] -- Error occurred when parsing reponse: `{}`\",\n                        resp_data.unwrapErr().what())));\n    }\n    try {\n        auto data = resp_data.unwrap()[\"list\"];\n        co_return Ok(data);\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(utils::Exception::JsonError,\n                                       \"[get_related_mv] -- Cannot get `list` from data\"));\n    }\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_other_version(std::string_view mid) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session,\n                            \"music.musichallSong.OtherVersionServer\",\n                            \"GetOtherVersionSongs\");\n\n    nlohmann::json params = {{\"songmid\", mid}};\n    auto req_params = co_await api.prepare_request(params);\n    if (req_params.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_params.unwrapErr().get_error_enum()),\n            std::format(\"[get_other_version] -- Error occurred when preparing request: `{}`\",\n                        req_params.unwrapErr().what())));\n    }\n\n    auto url = req_params.unwrap().url;\n    auto req = req_params.unwrap().req;\n    auto resp_res = co_await session.perform_request(url, req);\n    if (resp_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_other_version] -- Error occurred when performing request: `{}`\",\n                        resp_res.unwrapErr().what())));\n    }\n\n    auto resp_data = api.parse_response(utils::resp2buf(resp_res.unwrap()));\n    if (resp_data.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_other_version] -- Error occurred when parsing reponse: `{}`\",\n                        resp_data.unwrapErr().what())));\n    }\n    try {\n        auto data = resp_data.unwrap()[\"versionList\"];\n        co_return Ok(data);\n    } catch (const std::exception&amp; e) {\n        co_return Err(\n            utils::Exception(utils::Exception::JsonError,\n                             \"[get_other_version] -- Cannot get `versionList` from data\"));\n    }\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_other_version(uint64_t id) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session,\n                            \"music.musichallSong.OtherVersionServer\",\n                            \"GetOtherVersionSongs\");\n\n    nlohmann::json params = {{\"songid\", id}};\n    auto req_params = co_await api.prepare_request(params);\n    if (req_params.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_params.unwrapErr().get_error_enum()),\n            std::format(\"[get_other_version] -- Error occurred when preparing request: `{}`\",\n                        req_params.unwrapErr().what())));\n    }\n\n    auto url = req_params.unwrap().url;\n    auto req = req_params.unwrap().req;\n    auto resp_res = co_await session.perform_request(url, req);\n    if (resp_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_other_version] -- Error occurred when performing request: `{}`\",\n                        resp_res.unwrapErr().what())));\n    }\n\n    auto resp_data = api.parse_response(utils::resp2buf(resp_res.unwrap()));\n    if (resp_data.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_other_version] -- Error occurred when parsing reponse: `{}`\",\n                        resp_data.unwrapErr().what())));\n    }\n    try {\n        auto data = resp_data.unwrap()[\"versionList\"];\n        co_return Ok(data);\n    } catch (const std::exception&amp; e) {\n        co_return Err(\n            utils::Exception(utils::Exception::JsonError,\n                             \"[get_other_version] -- Cannot get `versionList` from data\"));\n    }\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_producer_info(std::string_view mid) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.sociality.KolWorksTag\", \"SongProducer\");\n\n    nlohmann::json params = {{\"songmid\", mid}};\n    auto req_params = co_await api.prepare_request(params);\n    if (req_params.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_params.unwrapErr().get_error_enum()),\n            std::format(\"[get_producer_info] -- Error occurred when preparing request: `{}`\",\n                        req_params.unwrapErr().what())));\n    }\n\n    auto url = req_params.unwrap().url;\n    auto req = req_params.unwrap().req;\n    auto resp_res = co_await session.perform_request(url, req);\n    if (resp_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_producer_info] -- Error occurred when performing request: `{}`\",\n                        resp_res.unwrapErr().what())));\n    }\n\n    auto resp_data = api.parse_response(utils::resp2buf(resp_res.unwrap()));\n    if (resp_data.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_producer_info] -- Error occurred when parsing reponse: `{}`\",\n                        resp_data.unwrapErr().what())));\n    }\n    try {\n        auto data = resp_data.unwrap()[\"Lst\"];\n        co_return Ok(data);\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(utils::Exception::JsonError,\n                                       \"[get_producer_info] -- Cannot get `Lst` from data\"));\n    }\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_producer_info(uint64_t id) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.sociality.KolWorksTag\", \"SongProducer\");\n\n    nlohmann::json params = {{\"songid\", id}};\n    auto req_params = co_await api.prepare_request(params);\n    if (req_params.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_params.unwrapErr().get_error_enum()),\n            std::format(\"[get_producer_info] -- Error occurred when preparing request: `{}`\",\n                        req_params.unwrapErr().what())));\n    }\n\n    auto url = req_params.unwrap().url;\n    auto req = req_params.unwrap().req;\n    auto resp_res = co_await session.perform_request(url, req);\n    if (resp_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_producer_info] -- Error occurred when performing request: `{}`\",\n                        resp_res.unwrapErr().what())));\n    }\n\n    auto resp_data = api.parse_response(utils::resp2buf(resp_res.unwrap()));\n    if (resp_data.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_producer_info] -- Error occurred when parsing reponse: `{}`\",\n                        resp_data.unwrapErr().what())));\n    }\n    try {\n        auto data = resp_data.unwrap()[\"Lst\"];\n        co_return Ok(data);\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(utils::Exception::JsonError,\n                                       \"[get_producer_info] -- Cannot get `Lst` from data\"));\n    }\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_sheet(std::string_view mid) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.mir.SheetMusicSvr\", \"GetMoreSheetMusic\");\n\n    nlohmann::json params = {{\"songmid\", mid}, {\"scoreType\", -1}};\n    auto req_params = co_await api.prepare_request(params);\n    if (req_params.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_params.unwrapErr().get_error_enum()),\n            std::format(\"[get_sheet] -- Error occurred when preparing request: `{}`\",\n                        req_params.unwrapErr().what())));\n    }\n\n    auto url = req_params.unwrap().url;\n    auto req = req_params.unwrap().req;\n    auto resp_res = co_await session.perform_request(url, req);\n    if (resp_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_sheet] -- Error occurred when performing request: `{}`\",\n                        resp_res.unwrapErr().what())));\n    }\n\n    auto resp_data = api.parse_response(utils::resp2buf(resp_res.unwrap()));\n    if (resp_data.isErr()) {\n        co_return Err(\n            utils::Exception(utils::Exception::DataDestroy,\n                             std::format(\"[get_sheet] -- Error occurred when parsing reponse: `{}`\",\n                                         resp_data.unwrapErr().what())));\n    }\n    try {\n        auto data = resp_data.unwrap()[\"result\"];\n        co_return Ok(data);\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(utils::Exception::JsonError,\n                                       \"[get_sheet] -- Cannot get `result` from data\"));\n    }\n}\n\n// readable: \u662f\u5426\u4eba\u7c7b\u53ef\u8bfb\n//\n// demo:\n// {'m_numbers': {'438910555': 1000001}, 'm_show': {'438910555': '550w+'}}\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_fav_num(std::span&lt;uint64_t&gt; id_list, bool readable) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.musicasset.SongFavRead\", \"GetSongFansNumberById\");\n\n    nlohmann::json params = {{\"v_songId\", id_list}};\n    auto req_params = co_await api.prepare_request(params);\n    if (req_params.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_params.unwrapErr().get_error_enum()),\n            std::format(\"[get_fav_num] -- Error occurred when preparing request: `{}`\",\n                        req_params.unwrapErr().what())));\n    }\n\n    auto url = req_params.unwrap().url;\n    auto req = req_params.unwrap().req;\n    auto resp_res = co_await session.perform_request(url, req);\n    if (resp_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_fav_num] -- Error occurred when performing request: `{}`\",\n                        resp_res.unwrapErr().what())));\n    }\n\n    auto resp_data = api.parse_response(utils::resp2buf(resp_res.unwrap()));\n    if (resp_data.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_fav_num] -- Error occurred when parsing reponse: `{}`\",\n                        resp_data.unwrapErr().what())));\n    }\n    try {\n        auto data = resp_data.unwrap()[readable ? \"m_show\" : \"m_numbers\"];\n        co_return Ok(data);\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(utils::Exception::JsonError,\n                                       \"[get_fav_num] -- Cannot get statistics from data\"));\n    }\n}\n\n} // namespace qqmusic\n</code></pre>"},{"location":"dictionary/songlist_8cc/","title":"File songlist.cc","text":"<p>FileList &gt; src &gt; songlist.cc</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;format&gt;</code></li> <li><code>#include &lt;qqmusic/details/api.h&gt;</code></li> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;qqmusic/songlist.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/async-executor.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/common.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/session.h&gt;</code></li> </ul>"},{"location":"dictionary/songlist_8cc/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic <p>The documentation for this class was generated from the following file <code>src/songlist.cc</code></p>"},{"location":"dictionary/songlist_8cc_source/","title":"File songlist.cc","text":"<p>File List &gt; src &gt; songlist.cc</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;format&gt;\n#include &lt;qqmusic/details/api.h&gt;\n#include &lt;qqmusic/result.h&gt;\n#include &lt;qqmusic/songlist.h&gt;\n#include &lt;qqmusic/utils/async-executor.h&gt;\n#include &lt;qqmusic/utils/common.h&gt;\n#include &lt;qqmusic/utils/session.h&gt;\n\nnamespace qqmusic {\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_songlist_detail(uint64_t dissid,\n                                                 unsigned dirid,\n                                                 unsigned num,\n                                                 unsigned page,\n                                                 bool only_song,\n                                                 bool tag,\n                                                 bool user_info) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.srfDissInfo.DissInfo\", \"CgiGetDiss\");\n\n    nlohmann::json params = {{\"disstid\", dissid},\n                             {\"dirid\", dirid},\n                             {\"tag\", tag},\n                             {\"song_begin\", num * (page - 1)},\n                             {\"song_num\", num},\n                             {\"userinfo\", (unsigned) user_info},\n                             {\"orderlist\", 1},\n                             {\"onlysonglist\", (unsigned) only_song}};\n\n    auto req_params = co_await api.prepare_request(params);\n    if (req_params.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_params.unwrapErr().get_error_enum()),\n            std::format(\"[get_songlist_detail] -- Error occurred when preparing request: `{}`\",\n                        req_params.unwrapErr().what())));\n    }\n\n    auto url = req_params.unwrap().url;\n    auto req = req_params.unwrap().req;\n    auto resp_res = co_await session.perform_request(url, req);\n    if (resp_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_songlist_detail] -- Error occurred when performing request: `{}`\",\n                        resp_res.unwrapErr().what())));\n    }\n\n    auto resp_data = api.parse_response(utils::resp2buf(resp_res.unwrap()));\n    if (resp_data.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_songlist_detail] -- Error occurred when parsing reponse: `{}`\",\n                        resp_data.unwrapErr().what())));\n    }\n\n    auto data = resp_data.unwrap();\n    try {\n        co_return Ok(nlohmann::json{{\"dirinfo\", data[\"dirinfo\"]},\n                                    {\"total_song_num\", data[\"total_song_num\"]},\n                                    {\"songlist_size\", data[\"songlist_size\"]},\n                                    {\"songlist\", data[\"songlist\"]},\n                                    {\"songtag\", data[\"songtag\"]},\n                                    {\"orderlist\", data[\"orderlist\"]}});\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(\n            utils::Exception::JsonError,\n            std::format(\"[get_songlist_detail] -- Cannot filter data from response: `{}`\",\n                        e.what())));\n    }\n    co_return Err(utils::Exception(utils::Exception::UnknownError, \"Not implemented\"));\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_songlist(uint64_t dissid, unsigned dirid) {\n    auto response = co_await get_songlist_detail(dissid, dirid, 100, 1, true);\n    if (response.isErr()) {\n        co_return Err(utils::Exception(response.unwrapErr()));\n    }\n    auto data = response.unwrap();\n    uint64_t total = data[\"total_song_num\"].get&lt;uint64_t&gt;();\n    nlohmann::json songlist = data[\"songlist\"];\n\n    if (total &lt;= 100) {\n        co_return Ok(songlist);\n    }\n\n    std::vector&lt;Task&lt;Result&lt;nlohmann::json&gt;&gt;&gt; tasks;\n    for (unsigned i = 100; i &lt; total; i += 100) {\n        tasks.push_back(get_songlist_detail(dissid, dirid, 100, i, true));\n    }\n\n    auto&amp; async_executor = utils::AsyncExecutor::get_instance();\n    auto all_results = co_await async_executor.when_all(std::move(tasks));\n    for (auto&amp; res : all_results) {\n        if (res.isErr()) {\n            co_return Err(utils::Exception(utils::Exception::DataDestroy,\n                                           std::format(\"[get_songlist] -- Error occurred when \"\n                                                       \"unwrapping results of left items: `{}`\",\n                                                       res.unwrapErr().what())));\n        }\n        songlist.insert(songlist.end(), res.unwrap()[\"songlist\"]);\n    }\n    co_return Ok(songlist);\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; songlist_create(std::string_view dirname,\n                                             std::optional&lt;utils::Credential&gt; credential) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    /* if provided with credential, use it. otherwise use the credential in current session */\n    auto api = details::Api(session,\n                            \"music.musicasset.PlaylistBaseWrite\",\n                            \"AddPlaylist\",\n                            credential.has_value() ? credential.value()\n                                                   : session.get_context_ref().credential);\n    nlohmann::json params = {{\"dirName\", dirname}};\n    auto req_param_res = co_await api.prepare_request(params, true);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[songlist_create] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[songlist_create] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[songlist_create] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n    auto response_json = response_json_res.unwrap();\n    try {\n        co_return Ok(response_json[\"result\"]);\n    } catch (const std::exception&amp; e) {\n        co_return Err(\n            utils::Exception(utils::Exception::DataDestroy,\n                             \"[songlist_create] -- Cannot find field `result` in response\"));\n    }\n}\n\nTask&lt;Result&lt;bool&gt;&gt; songlist_delete(uint64_t dirid, std::optional&lt;utils::Credential&gt; credential) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session,\n                            \"music.musicasset.PlaylistBaseWrite\",\n                            \"DelPlaylist\",\n                            credential.has_value() ? credential.value()\n                                                   : session.get_context_ref().credential);\n\n    nlohmann::json params = {{\"dirId\", dirid}};\n    auto req_param_res = co_await api.prepare_request(params, true);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[songlist_delete] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[songlist_delete] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[songlist_delete] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n    auto response_json = response_json_res.unwrap();\n    try {\n        co_return Ok(response_json[\"result\"][\"dirid\"].get&lt;uint64_t&gt;() == dirid);\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(utils::Exception::DataDestroy,\n                                       \"[songlist_delete] -- Cannot get result in response\"));\n    }\n}\n\nTask&lt;Result&lt;bool&gt;&gt; songlist_add_songs(uint64_t dirid,\n                                      std::span&lt;uint64_t&gt; song_ids,\n                                      std::optional&lt;utils::Credential&gt; credential) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session,\n                            \"music.musicasset.PlaylistDetailWrite\",\n                            \"AddSonglist\",\n                            credential.has_value() ? credential.value()\n                                                   : session.get_context_ref().credential);\n    nlohmann::json content;\n    for (auto&amp; song : song_ids) {\n        content.push_back({{\"songType\", 0}, {\"songId\", song}});\n    }\n    nlohmann::json params = {{\"dirId\", dirid}, {\"v_songInfo\", content}};\n    auto req_param_res = co_await api.prepare_request(params, true);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[songlist_add_songs] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    std::cout &lt;&lt; std::endl &lt;&lt; req &lt;&lt; std::endl;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[songlist_add_songs] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    std::cout &lt;&lt; response_res.unwrap() &lt;&lt; std::endl;\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[songlist_add_songs] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n    auto response_json = response_json_res.unwrap();\n    try {\n        co_return Ok(!(response_json[\"result\"][\"updateTime\"].get&lt;uint64_t&gt;() == 0));\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(utils::Exception::DataDestroy,\n                                       \"[songlist_add_songs] -- Cannot get result in response\"));\n    }\n}\n\nTask&lt;Result&lt;bool&gt;&gt; songlist_delete_songs(uint64_t dirid,\n                                         std::span&lt;uint64_t&gt; song_ids,\n                                         std::optional&lt;utils::Credential&gt; credential) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session,\n                            \"music.musicasset.PlaylistDetailWrite\",\n                            \"DelSonglist\",\n                            credential.has_value() ? credential.value()\n                                                   : session.get_context_ref().credential);\n    nlohmann::json content;\n    for (auto&amp; song : song_ids) {\n        content.push_back({{\"songType\", 0}, {\"songId\", song}});\n    }\n    nlohmann::json params = {{\"dirId\", dirid}, {\"v_songInfo\", content}};\n    auto req_param_res = co_await api.prepare_request(params, true);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[songlist_delete_songs] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[songlist_delete_songs] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[songlist_delete_songs] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n    auto response_json = response_json_res.unwrap();\n    try {\n        co_return Ok(!(response_json[\"result\"][\"updateTime\"].get&lt;uint64_t&gt;() == 0));\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(utils::Exception::DataDestroy,\n                                       \"[songlist_delete_songs] -- Cannot get result in response\"));\n    }\n}\n\n} // namespace qqmusic\n</code></pre>"},{"location":"dictionary/toplist_8cc/","title":"File toplist.cc","text":"<p>FileList &gt; src &gt; toplist.cc</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;qqmusic/details/api.h&gt;</code></li> <li><code>#include &lt;qqmusic/toplist.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/common.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/session.h&gt;</code></li> </ul>"},{"location":"dictionary/toplist_8cc/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic <p>The documentation for this class was generated from the following file <code>src/toplist.cc</code></p>"},{"location":"dictionary/toplist_8cc_source/","title":"File toplist.cc","text":"<p>File List &gt; src &gt; toplist.cc</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;qqmusic/details/api.h&gt;\n#include &lt;qqmusic/toplist.h&gt;\n#include &lt;qqmusic/utils/common.h&gt;\n#include &lt;qqmusic/utils/session.h&gt;\n\nnamespace qqmusic {\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_toplist_category() {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.musicToplist.Toplist\", \"GetAll\");\n    auto req_params = co_await api.prepare_request(nlohmann::json::object());\n    if (req_params.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_params.unwrapErr().get_error_enum()),\n            std::format(\"[get_toplist_category] -- Error occurred when preparing request: `{}`\",\n                        req_params.unwrapErr().what())));\n    }\n\n    auto url = req_params.unwrap().url;\n    auto req = req_params.unwrap().req;\n    auto resp_res = co_await session.perform_request(url, req);\n    if (resp_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_toplist_category] -- Error occurred when performing request: `{}`\",\n                        resp_res.unwrapErr().what())));\n    }\n\n    auto resp_data = api.parse_response(utils::resp2buf(resp_res.unwrap()));\n    if (resp_data.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_toplist_category] -- Error occurred when parsing reponse: `{}`\",\n                        resp_data.unwrapErr().what())));\n    }\n    try {\n        auto data = resp_data.unwrap()[\"group\"];\n        co_return Ok(data);\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(utils::Exception::JsonError,\n                                       \"[get_toplist_category] -- Cannot get `group` from data\"));\n    }\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_toplist_item_detail(unsigned top_id,\n                                                     unsigned num,\n                                                     unsigned page,\n                                                     bool tag) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.musicToplist.Toplist\", \"GetDetail\");\n    nlohmann::json params = {{\"topId\", top_id},\n                             {\"offset\", num * (page - 1)},\n                             {\"num\", num},\n                             {\"withTags\", tag}};\n\n    auto req_data = co_await api.prepare_request(params);\n    if (req_data.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_data.unwrapErr().get_error_enum()),\n            std::format(\"[get_toplist_item_detail] -- Error occurred when preparing request: `{}`\",\n                        req_data.unwrapErr().what())));\n    }\n\n    auto url = req_data.unwrap().url;\n    auto req = req_data.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_toplist_item_detail] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto resp = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (resp.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_toplist_item_detail] -- Error occurred when parsing reponse: `{}`\",\n                        resp.unwrapErr().what())));\n    }\n    auto data = resp.unwrap();\n    co_return Ok(data);\n}\n\n} // namespace qqmusic\n</code></pre>"},{"location":"dictionary/user_8cc/","title":"File user.cc","text":"<p>FileList &gt; src &gt; user.cc</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/beast/http.hpp&gt;</code></li> <li><code>#include &lt;boost/url/urls.hpp&gt;</code></li> <li><code>#include &lt;qqmusic/details/api.h&gt;</code></li> <li><code>#include &lt;qqmusic/user.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/common.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/session.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"dictionary/user_8cc/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic <p>The documentation for this class was generated from the following file <code>src/user.cc</code></p>"},{"location":"dictionary/user_8cc_source/","title":"File user.cc","text":"<p>File List &gt; src &gt; user.cc</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;boost/beast/http.hpp&gt;\n#include &lt;boost/url/urls.hpp&gt;\n#include &lt;qqmusic/details/api.h&gt;\n#include &lt;qqmusic/user.h&gt;\n#include &lt;qqmusic/utils/common.h&gt;\n#include &lt;qqmusic/utils/session.h&gt;\n#include &lt;string&gt;\n\nnamespace qqmusic {\n\nTask&lt;Result&lt;std::string&gt;&gt; get_euin(uint64_t musicid) {\n    namespace http = boost::beast::http;\n    auto session = utils::SessionManager::get_instance().get_session();\n\n    boost::url url{\"https://c6.y.qq.com/rsc/fcgi-bin/fcg_get_profile_homepage.fcg\"};\n    url.set_params({{\"ct\", \"20\"},\n                    {\"cv\", \"4747474\"},\n                    {\"cid\", \"205360838\"},\n                    {\"userid\", std::to_string(musicid)}});\n    http::request&lt;http::string_body&gt; req{http::verb::get, url, 11};\n    req.set(http::field::host, url.host());\n    req.set(http::field::accept, \"*/*\");\n    /*use raw buffer instead of compressed buffer when debuging*/\n    req.set(http::field::accept_encoding, \"gzip, deflate\");\n    req.set(http::field::connection, \"keep-alive\");\n    req.set(http::field::user_agent,\n            \"Mozilla/5.0 (Windows NT 11.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) \"\n            \"Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.54\");\n    req.set(http::field::referer, \"y.qq.com\");\n\n    /*send request*/\n    auto res = co_await session.perform_request(url, req);\n    if (res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_euin] -- Error occurred when performing https request: `{}`\",\n                        res.unwrapErr().what())));\n    }\n\n    try {\n        auto data = nlohmann::json::parse(utils::resp2buf(res.unwrap()))[\"data\"];\n        std::string euin = data[\"creator\"][\"encrypt_uin\"];\n        co_return Ok(euin);\n    } catch (const std::exception&amp; e) {\n        co_return Err(\n            utils::Exception(utils::Exception::JsonError,\n                             std::format(\"[get_euin] -- Cannot filter euin from json: `{}`\",\n                                         e.what())));\n    }\n}\n\nTask&lt;Result&lt;uint64_t&gt;&gt; get_musicid(std::string_view euin) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.srfDissInfo.DissInfo\", \"CgiGetDiss\");\n\n    nlohmann::json params = {{\"disstid\", 0},\n                             {\"dirid\", 201},\n                             {\"song_num\", 1},\n                             {\"enc_host_uin\", euin},\n                             {\"onlysonglist\", 1}};\n\n    auto req_param_res = co_await api.prepare_request(params);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_musicid] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_musicid] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_musicid] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n    auto response_json = response_json_res.unwrap();\n    try {\n        co_return Ok(response_json[\"dirinfo\"][\"creator\"][\"musicid\"].get&lt;uint64_t&gt;());\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(\n            utils::Exception::JsonError,\n            std::format(\"[get_musicid] -- Cannot filter musicid from response: `{}`\", e.what())));\n    }\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_homepage(std::string_view euin,\n                                          std::optional&lt;utils::Credential&gt; credential) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session,\n                            \"music.UnifiedHomepage.UnifiedHomepageSrv\",\n                            \"GetHomepageHeader\",\n                            credential.has_value() ? credential.value()\n                                                   : session.get_context_ref().credential);\n\n    nlohmann::json params = {{\"uin\", euin}, {\"IsQueryTabDetail\", 1}};\n\n    auto req_param_res = co_await api.prepare_request(params, true);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_homepage] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_homepage] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_homepage] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n    auto response_json = response_json_res.unwrap();\n    co_return Ok(response_json);\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_vip_info(std::optional&lt;utils::Credential&gt; credential) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session,\n                            \"VipLogin.VipLoginInter\",\n                            \"vip_login_base\",\n                            credential.has_value() ? credential.value()\n                                                   : session.get_context_ref().credential);\n\n    auto req_param_res = co_await api.prepare_request(nlohmann::json::object(), true);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_vip_info] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_vip_info] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_vip_info] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n    co_return Ok(response_json_res.unwrap());\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_follow_singers(std::string_view euin,\n                                                unsigned page,\n                                                unsigned num,\n                                                std::optional&lt;utils::Credential&gt; credential) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session,\n                            \"music.concern.RelationList\",\n                            \"GetFollowSingerList\",\n                            credential.has_value() ? credential.value()\n                                                   : session.get_context_ref().credential);\n\n    nlohmann::json params = {{\"HostUin\", euin}, {\"From\", (page - 1) * num}, {\"Size\", num}};\n    auto req_param_res = co_await api.prepare_request(params, true);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_follow_singers] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_follow_singers] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_follow_singers] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n    auto response_json = response_json_res.unwrap();\n    try {\n        co_return Ok(\n            nlohmann::json{{\"total\", response_json[\"Total\"]}, {\"list\", response_json[\"List\"]}});\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(\n            utils::Exception::JsonError,\n            std::format(\"[get_follow_singers] -- Cannot get result in response: `{}`\", e.what())));\n    }\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_fans(std::string_view euin,\n                                      unsigned page,\n                                      unsigned num,\n                                      std::optional&lt;utils::Credential&gt; credential) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session,\n                            \"music.concern.RelationList\",\n                            \"GetFansList\",\n                            credential.has_value() ? credential.value()\n                                                   : session.get_context_ref().credential);\n\n    nlohmann::json params = {{\"HostUin\", euin}, {\"From\", (page - 1) * num}, {\"Size\", num}};\n    auto req_param_res = co_await api.prepare_request(params, true);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_fans] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_fans] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(\n            utils::Exception(utils::Exception::DataDestroy,\n                             std::format(\"[get_fans] -- Error occurred when parsing reponse: `{}`\",\n                                         response_json_res.unwrapErr().what())));\n    }\n    auto response_json = response_json_res.unwrap();\n    try {\n        co_return Ok(\n            nlohmann::json{{\"total\", response_json[\"Total\"]}, {\"list\", response_json[\"List\"]}});\n    } catch (const std::exception&amp; e) {\n        co_return Err(\n            utils::Exception(utils::Exception::JsonError,\n                             std::format(\"[get_fans] -- Cannot get result in response: `{}`\",\n                                         e.what())));\n    }\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_friend_list(unsigned page,\n                                             unsigned num,\n                                             std::optional&lt;utils::Credential&gt; credential) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session,\n                            \"music.homepage.Friendship\",\n                            \"GetFriendList\",\n                            credential.has_value() ? credential.value()\n                                                   : session.get_context_ref().credential);\n\n    nlohmann::json params = {{\"PageSize\", num}, {\"Page\", page - 1}};\n    auto req_param_res = co_await api.prepare_request(params, true);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_friend_list] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_friend_list] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_friend_list] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n    auto response_json = response_json_res.unwrap();\n    std::cout &lt;&lt; response_json &lt;&lt; std::endl;\n    try {\n        co_return Ok(response_json[\"Friends\"]);\n    } catch (const std::exception&amp; e) {\n        co_return Err(\n            utils::Exception(utils::Exception::JsonError,\n                             std::format(\"[get_friend_list] -- Cannot get result in response: `{}`\",\n                                         e.what())));\n    }\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_follow_usr(std::string_view euin,\n                                            unsigned page,\n                                            unsigned num,\n                                            std::optional&lt;utils::Credential&gt; credential) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session,\n                            \"music.concern.RelationList\",\n                            \"GetFollowUserList\",\n                            credential.has_value() ? credential.value()\n                                                   : session.get_context_ref().credential);\n\n    nlohmann::json params = {{\"HostUin\", euin}, {\"From\", (page - 1) * num}, {\"Size\", num}};\n    auto req_param_res = co_await api.prepare_request(params, true);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_follow_usr] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_follow_usr] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_follow_usr] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n    auto response_json = response_json_res.unwrap();\n    try {\n        co_return Ok(\n            nlohmann::json{{\"total\", response_json[\"Total\"]}, {\"list\", response_json[\"List\"]}});\n    } catch (const std::exception&amp; e) {\n        co_return Err(\n            utils::Exception(utils::Exception::JsonError,\n                             std::format(\"[get_follow_usr] -- Cannot get result in response: `{}`\",\n                                         e.what())));\n    }\n    co_return Err(utils::Exception(utils::Exception::UnknownError, \"Not implemented\"));\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_created_songlist(uint64_t musicid,\n                                                  std::optional&lt;utils::Credential&gt; credential) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.musicasset.PlaylistBaseRead\", \"GetPlaylistByUin\");\n\n    nlohmann::json params = {{\"uin\", std::to_string(musicid)}};\n\n    auto req_param_res = co_await api.prepare_request(params);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_created_songlist] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_created_songlist] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_created_songlist] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n    auto response_json = response_json_res.unwrap();\n    try {\n        co_return Ok(response_json[\"v_playlist\"]);\n    } catch (const std::exception&amp; e) {\n        co_return Err(utils::Exception(\n            utils::Exception::JsonError,\n            std::format(\"[get_created_songlist] -- Cannot get result in response: `{}`\", e.what())));\n    }\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_fav_song(std::string_view euin,\n                                          unsigned page,\n                                          unsigned num,\n                                          std::optional&lt;utils::Credential&gt; credential) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session,\n                            \"music.srfDissInfo.DissInfo\",\n                            \"CgiGetDiss\",\n                            credential.has_value() ? credential.value()\n                                                   : session.get_context_ref().credential);\n\n    nlohmann::json params = {{\"disstid\", 0},\n                             {\"dirid\", 201},\n                             {\"tag\", 1},\n                             {\"song_begin\", num * (page - 1)},\n                             {\"song_num\", num},\n                             {\"userinfo\", 1},\n                             {\"orderlist\", 1},\n                             {\"enc_host_uin\", euin}};\n\n    auto req_param_res = co_await api.prepare_request(params, true);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_fav_song] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_fav_song] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_fav_song] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n\n    co_return Ok(response_json_res.unwrap());\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_fav_songlist(std::string_view euin,\n                                              unsigned page,\n                                              unsigned num,\n                                              std::optional&lt;utils::Credential&gt; credential) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session,\n                            \"music.musicasset.PlaylistFavRead\",\n                            \"CgiGetPlaylistFavInfo\",\n                            credential.has_value() ? credential.value()\n                                                   : session.get_context_ref().credential);\n\n    nlohmann::json params = {{\"uin\", euin}, {\"offset\", (page - 1) * num}, {\"size\", num}};\n    auto req_param_res = co_await api.prepare_request(params, true);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_fav_songlist] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_fav_songlist] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_fav_songlist] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n    co_return Ok(response_json_res.unwrap());\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_fav_album(std::string_view euin,\n                                           unsigned page,\n                                           unsigned num,\n                                           std::optional&lt;utils::Credential&gt; credential) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session,\n                            \"music.musicasset.AlbumFavRead\",\n                            \"CgiGetAlbumFavInfo\",\n                            credential.has_value() ? credential.value()\n                                                   : session.get_context_ref().credential);\n\n    nlohmann::json params = {{\"euin\", euin}, {\"offset\", (page - 1) * num}, {\"size\", num}};\n    auto req_param_res = co_await api.prepare_request(params, true);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_fav_album] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_fav_album] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_fav_album] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n    co_return Ok(response_json_res.unwrap());\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_fav_mv(std::string_view euin,\n                                        unsigned page,\n                                        unsigned num,\n                                        std::optional&lt;utils::Credential&gt; credential) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session,\n                            \"music.musicasset.MVFavRead\",\n                            \"getMyFavMV_v2\",\n                            credential.has_value() ? credential.value()\n                                                   : session.get_context_ref().credential);\n\n    nlohmann::json params = {{\"encuin\", euin}, {\"num\", page - 1}, {\"pagesize\", num}};\n    auto req_param_res = co_await api.prepare_request(params, true);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_fav_mv] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_fav_mv] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_fav_mv] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n    co_return Ok(response_json_res.unwrap());\n}\n\nTask&lt;Result&lt;nlohmann::json&gt;&gt; get_music_gene(std::string_view euin,\n                                            std::optional&lt;utils::Credential&gt; credential) {\n    auto session = utils::SessionManager::get_instance().get_session();\n    auto api = details::Api(session,\n                            \"music.recommend.UserProfileSettingSvr\",\n                            \"GetProfileReport\",\n                            credential.has_value() ? credential.value()\n                                                   : session.get_context_ref().credential);\n\n    nlohmann::json params = {{\"VisitAccount\", euin}};\n    auto req_param_res = co_await api.prepare_request(params, true);\n    if (req_param_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[get_music_gene] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::NetworkError,\n            std::format(\"[get_music_gene] -- Error occurred when performing request: `{}`\",\n                        response_res.unwrapErr().what())));\n    }\n\n    auto response_json_res = api.parse_response(utils::resp2buf(response_res.unwrap()));\n    if (response_json_res.isErr()) {\n        co_return Err(utils::Exception(\n            utils::Exception::DataDestroy,\n            std::format(\"[get_music_gene] -- Error occurred when parsing reponse: `{}`\",\n                        response_json_res.unwrapErr().what())));\n    }\n    co_return Ok(response_json_res.unwrap());\n}\n\n} // namespace qqmusic\n</code></pre>"},{"location":"dictionary/dir_313caf1132e152dd9b58bea13a4052ca/","title":"Dir utils","text":"<p>FileList &gt; src &gt; utils</p>"},{"location":"dictionary/dir_313caf1132e152dd9b58bea13a4052ca/#files","title":"Files","text":"Type Name file async-executor.cc file common.cc file cookie.cc file credential.cc file device.cc file paths.cc file qimei.cc file session.cc <p>The documentation for this class was generated from the following file <code>src/utils/</code></p>"},{"location":"dictionary/async-executor_8cc/","title":"File async-executor.cc","text":"<p>FileList &gt; src &gt; utils &gt; async-executor.cc</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/asio/signal_set.hpp&gt;</code></li> <li><code>#include &lt;qqmusic/utils/async-executor.h&gt;</code></li> </ul>"},{"location":"dictionary/async-executor_8cc/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace utils \u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027 <p>The documentation for this class was generated from the following file <code>src/utils/async-executor.cc</code></p>"},{"location":"dictionary/async-executor_8cc_source/","title":"File async-executor.cc","text":"<p>File List &gt; src &gt; utils &gt; async-executor.cc</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;boost/asio/signal_set.hpp&gt;\n#include &lt;qqmusic/utils/async-executor.h&gt;\n\nnamespace qqmusic::utils {\n\nAsyncExecutor::AsyncExecutor() {\n    ioc_thread = std::thread([this]() {\n        boost::asio::signal_set sigset{ioc, SIGINT, SIGTERM};\n        /*set handler for SIGINT and SIGTERM*/\n        sigset.async_wait([&amp;](auto, auto) { ioc.stop(); });\n        /*keep ioc alive when no task left*/\n        boost::asio::executor_work_guard&lt;decltype(ioc.get_executor())&gt; work{ioc.get_executor()};\n        /*run the ioc event loop*/\n        ioc.run();\n    });\n}\n\nAsyncExecutor::~AsyncExecutor() {\n    shutdown();\n}\n\nvoid AsyncExecutor::shutdown() {\n    ioc.stop();\n    if (ioc_thread.joinable()) {\n        ioc_thread.join();\n    }\n}\n\nAsyncExecutor&amp; AsyncExecutor::get_instance() {\n    static AsyncExecutor ae;\n    return ae;\n}\n\n} // namespace qqmusic::utils\n</code></pre>"},{"location":"dictionary/common_8cc/","title":"File common.cc","text":"<p>FileList &gt; src &gt; utils &gt; common.cc</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/asio/buffer.hpp&gt;</code></li> <li><code>#include &lt;boost/uuid/detail/md5.hpp&gt;</code></li> <li><code>#include &lt;botan/auto_rng.h&gt;</code></li> <li><code>#include &lt;botan/base64.h&gt;</code></li> <li><code>#include &lt;botan/hex.h&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;cstdio&gt;</code></li> <li><code>#include &lt;cstdlib&gt;</code></li> <li><code>#include &lt;cstring&gt;</code></li> <li><code>#include &lt;qqmusic/details/tripledes.h&gt;</code></li> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/buffer.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/common.h&gt;</code></li> <li><code>#include &lt;span&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;zlib.h&gt;</code></li> </ul>"},{"location":"dictionary/common_8cc/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace utils \u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027 <p>The documentation for this class was generated from the following file <code>src/utils/common.cc</code></p>"},{"location":"dictionary/common_8cc_source/","title":"File common.cc","text":"<p>File List &gt; src &gt; utils &gt; common.cc</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;boost/asio/buffer.hpp&gt;\n#include &lt;boost/uuid/detail/md5.hpp&gt;\n#include &lt;botan/auto_rng.h&gt;\n#include &lt;botan/base64.h&gt;\n#include &lt;botan/hex.h&gt;\n#include &lt;cmath&gt;\n#include &lt;cstdint&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstring&gt;\n#include &lt;qqmusic/details/tripledes.h&gt;\n#include &lt;qqmusic/result.h&gt;\n#include &lt;qqmusic/utils/buffer.h&gt;\n#include &lt;qqmusic/utils/common.h&gt;\n#include &lt;span&gt;\n#include &lt;string&gt;\n#include &lt;zlib.h&gt;\n\nnamespace qqmusic::utils {\n\nbuffer resp2buf(http::response&lt;http::dynamic_body&gt;&amp;&amp; resp) {\n    /* TODO: I haven't found a better way to convert http::request to normal buffer*/\n    auto* ptr = static_cast&lt;const uint8_t*&gt;((*resp.body().data().begin()).data());\n    auto size = resp.body().data().buffer_bytes();\n    return qqmusic::utils::buffer{ptr, size};\n}\n\nbuffer hex2buf(std::string_view hex) {\n    return buffer{Botan::hex_decode(hex)};\n}\n\nstatic std::string head(std::span&lt;uint8_t&gt; data);\nstatic std::string tail(std::span&lt;uint8_t&gt; data);\nstatic std::string middle(std::span&lt;uint8_t&gt; data);\n\nstd::string sign(const nlohmann::json&amp; params) {\n    boost::uuids::detail::md5 hash;\n    boost::uuids::detail::md5::digest_type digest;\n    auto str = params.dump();\n    hash.process_bytes(str.data(), str.size());\n    hash.get_digest(digest);\n    auto md5_str = Botan::hex_encode(digest);\n    auto h = head(std::span&lt;uint8_t&gt;((uint8_t*) md5_str.data(), md5_str.size()));\n    auto e = tail(std::span&lt;uint8_t&gt;((uint8_t*) md5_str.data(), md5_str.size()));\n    auto m = middle(std::span&lt;uint8_t&gt;((uint8_t*) md5_str.data(), md5_str.size()));\n    std::string res = \"zzb\" + h + m + e;\n    /*iterate the string and do some format jobs\n     *\n     * origin python code:\n     * ```\n     * return res.lower().replace(\"/\", \"\").replace(\"+\", \"\").replace(\"=\", \"\")\n     * ```\n     * */\n    for (auto itr = res.begin(); itr != res.end(); /*left blank*/) {\n        switch (*itr) {\n        case '+':\n        case '/':\n        case '=':\n            /*delete char '+', '=', '/'*/\n            itr = res.erase(itr);\n            break;\n        case 'A':\n        case 'B':\n        case 'C':\n        case 'D':\n        case 'E':\n        case 'F':\n        case 'G':\n        case 'H':\n        case 'I':\n        case 'J':\n        case 'K':\n        case 'L':\n        case 'M':\n        case 'N':\n        case 'O':\n        case 'P':\n        case 'Q':\n        case 'R':\n        case 'T':\n        case 'U':\n        case 'V':\n        case 'W':\n        case 'X':\n        case 'Y':\n        case 'Z':\n            /*lower case the string*/\n            *itr -= ('A' - 'a');\n        default:\n            itr++;\n        }\n    }\n    return res;\n}\n\nstatic std::string head(std::span&lt;uint8_t&gt; data) {\n    const int p[] = {21, 4, 9, 26, 16, 20, 27, 30};\n    return {\n        (char) data[p[0]],\n        (char) data[p[1]],\n        (char) data[p[2]],\n        (char) data[p[3]],\n        (char) data[p[4]],\n        (char) data[p[5]],\n        (char) data[p[6]],\n        (char) data[p[7]],\n    };\n}\n\nstatic std::string tail(std::span&lt;uint8_t&gt; data) {\n    const int p[] = {18, 11, 3, 2, 1, 7, 6, 25};\n    return {\n        (char) data[p[0]],\n        (char) data[p[1]],\n        (char) data[p[2]],\n        (char) data[p[3]],\n        (char) data[p[4]],\n        (char) data[p[5]],\n        (char) data[p[6]],\n        (char) data[p[7]],\n    };\n}\n\nstatic std::string middle(std::span&lt;uint8_t&gt; data) {\n    auto zd = [](unsigned char ch) -&gt; unsigned char {\n        switch (ch) {\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return ch - '0';\n        case 'A':\n        case 'B':\n        case 'C':\n        case 'D':\n        case 'E':\n        case 'F':\n            return ch - 'A' + 10;\n        default:\n            throw std::runtime_error(\"Assert data is hex string failed\");\n        }\n    };\n    const unsigned char ol[]\n        = {212, 45, 80, 68, 195, 163, 163, 203, 157, 220, 254, 91, 204, 79, 104, 6};\n    size_t size = data.size();\n    std::vector&lt;unsigned char&gt; res;\n    unsigned int j = 0;\n    for (size_t i = 0; i &lt; size; i += 2) {\n        unsigned char one = zd(data[i]);\n        unsigned char two = zd(data[i + 1]);\n        unsigned char r = one * 16 ^ two;\n        res.push_back(r ^ ol[j++]);\n    }\n    return Botan::base64_encode(res);\n}\n\nstatic int decompress(const buffer&amp; src, buffer&amp; dest);\n\n// qmc decoder\nstatic void qmc1_decrypt(buffer&amp; src);\n\nqqmusic::Result&lt;std::string&gt; qrc_decode(const buffer&amp; src, qrc_type type) {\n    buffer tmp;\n    if (type == qrc_type::local) {\n        buffer raw(src);\n        qmc1_decrypt(raw);\n        tmp.assign(raw.begin() + 11, raw.end());\n    } else {\n        tmp = src;\n    }\n\n    size_t tmp_size = tmp.size();\n    // check if size is integer multiple of 8 bytes\n    if (tmp_size % 8 != 0) {\n        return Err(Exception(Exception::Kind::DataDestroy,\n                             \"qrc-decoder: buffer size cannot devided by 8\"));\n    }\n\n    // QRC_KEY = b\"!@#)(*$%123ZXC!@!@#)(NHL\"\n    constexpr uint8_t qrc_key[] = \"\\x21\\x40\\x23\\x29\\x28\\x2A\\x24\\x25\\x31\\x32\\x33\\x5A\\x58\\x43\\x21\\x40\"\n                                  \"\\x21\\x40\\x23\\x29\\x28\\x4E\\x48\\x4C\";\n\n    constexpr size_t qrc_key_size = sizeof(qrc_key) - 1;\n\n    // generate key schedule\n    const auto schedule = tripledes_key_setup(qrc_key,\n                                              qrc_key_size,\n                                              details::tripledes_crypt_mode::decrypt);\n\n    buffer compressed_buffer;\n\n    // iterate encrypted_text_byte function in units of 8 bytes\n    // origin python code:\n    // for i in range(0, len(encrypted_text_byte), 8):\n    //     data += tripledes_crypt(encrypted_text_byte[i:], schedule)\n    uint8_t* head = tmp.data();\n    for (size_t i = 0; i &lt; tmp_size / 8; ++i) {\n        buffer tmp_section(head + i * 8, 8);\n        details::tripledes_crypt(tmp_section, compressed_buffer, schedule);\n    }\n\n    // decompress the buffer\n    buffer dest;\n    int decompress_res = decompress(compressed_buffer, dest);\n\n    switch (decompress_res) {\n    case -1:\n    case 1:\n        return Err(Exception(Exception::Kind::RuntimeError, \"qrc-decoder: memory alloc error\"));\n    case 2:\n        return Err(Exception(Exception::Kind::DataDestroy,\n                             \"qrc-decoder: data destroy when decompressing decoding lyric\"));\n    case 0:\n        break;\n    default:\n        return Err(Exception(Exception::Kind::UnknownError,\n                             \"qrc-decoder: unknown error when decompressing decoded lyric\"));\n    }\n\n    return Ok(std::string((char*) dest.data(), dest.size()));\n}\n\nstatic int decompress(const buffer&amp; src, buffer&amp; dest) {\n    // prepare receive buffer\n    size_t tmp_dest_size = src.size() * 4;\n    auto tmp_dest_head = (uint8_t*) malloc(tmp_dest_size);\n\n    // prepare input buffer\n    size_t src_size = src.size();\n    const uint8_t* src_head = src.data();\n\n    // ZEXTERN int ZEXPORT uncompress(Bytef *dest,   uLongf *destLen,\n    //                                const Bytef *source, uLong sourceLen);\n#ifdef PLATFORM_WINDOWS\n    int uncompress_res = uncompress(tmp_dest_head, (uLongf*) &amp;tmp_dest_size, src_head, src_size);\n#else\n    int uncompress_res = uncompress(tmp_dest_head, &amp;tmp_dest_size, src_head, src_size);\n#endif // PLATFORM_WINDOWS\n    switch (uncompress_res) {\n    case Z_OK:\n        break;\n    case Z_MEM_ERROR:\n        free(tmp_dest_head);\n        return -1; // mem alloc error\n        break;\n    case Z_BUF_ERROR:\n        free(tmp_dest_head);\n        return 1; // buffer too small\n        break;\n    case Z_DATA_ERROR:\n        free(tmp_dest_head);\n        return 2; // data demage\n        break;\n    default:\n        free(tmp_dest_head);\n        return 3; // unknown error\n    }\n\n    // write buffer into dest\n    dest.append(tmp_dest_head, tmp_dest_size);\n\n    free(tmp_dest_head);\n    return 0;\n}\n\n// qmc decryptor\n// def qmc1_decrypt(data: bytearray) -&gt; None:\n//     for i, _value in enumerate(data):\n//         data[i] ^= PRIVKEY[(i % 0x7FFF) &amp; 0x7F] if i &gt; 0x7FFF else PRIVKEY[i &amp; 0x7F]\nstatic void qmc1_decrypt(buffer&amp; src) {\n    uint8_t private_key[128] = {\n        0xc3, 0x4a, 0xd6, 0xca, 0x90, 0x67, 0xf7, 0x52,\n        0xd8, 0xa1, 0x66, 0x62, 0x9f, 0x5b, 0x09, 0x00,\n\n        0xc3, 0x5e, 0x95, 0x23, 0x9f, 0x13, 0x11, 0x7e,\n        0xd8, 0x92, 0x3f, 0xbc, 0x90, 0xbb, 0x74, 0x0e,\n\n        0xc3, 0x47, 0x74, 0x3d, 0x90, 0xaa, 0x3f, 0x51,\n        0xd8, 0xf4, 0x11, 0x84, 0x9f, 0xde, 0x95, 0x1d,\n\n        0xc3, 0xc6, 0x09, 0xd5, 0x9f, 0xfa, 0x66, 0xf9,\n        0xd8, 0xf0, 0xf7, 0xa0, 0x90, 0xa1, 0xd6, 0xf3,\n\n        0xc3, 0xf3, 0xd6, 0xa1, 0x90, 0xa0, 0xf7, 0xf0,\n        0xd8, 0xf9, 0x66, 0xfa, 0x9f, 0xd5, 0x09, 0xc6,\n\n        0xc3, 0x1d, 0x95, 0xde, 0x9f, 0x84, 0x11, 0xf4,\n        0xd8, 0x51, 0x3f, 0xaa, 0x90, 0x3d, 0x74, 0x47,\n\n        0xc3, 0x0e, 0x74, 0xbb, 0x90, 0xbc, 0x3f, 0x92,\n        0xd8, 0x7e, 0x11, 0x13, 0x9f, 0x23, 0x95, 0x5e,\n\n        0xc3, 0x00, 0x09, 0x5b, 0x9f, 0x62, 0x66, 0xa1,\n        0xd8, 0x52, 0xf7, 0x67, 0x90, 0xca, 0xd6, 0x4a,\n    };\n\n    size_t size = src.size();\n    uint8_t* head = src.data();\n\n    for (size_t i = 0; i &lt; size; ++i) {\n        head[i] ^= i &gt; 0x7fff ? private_key[(i % 0x7fff) &amp; 0x7f] : private_key[i &amp; 0x7f];\n    }\n}\n\nuint64_t hash33(std::string_view str, uint64_t prev) {\n    /* python code:\n     * ```\n     * def hash33(s: str, h: int = 0) -&gt; int:\n     * for c in s:\n     *     h = (h &lt;&lt; 5) + h + ord(c)\n     * return 2147483647 &amp; h\n     * ```\n     * */\n    uint64_t h = prev;\n    size_t i = 0;\n\n    /* Get single characters in utf-8 string*/\n    while (i &lt; str.length()) {\n        uint32_t codepoint = 0;\n\n        if ((str[i] &amp; 0x80) == 0) {\n            // 1 byte character (ASCII)\n            codepoint = static_cast&lt;unsigned char&gt;(str[i]);\n            i += 1;\n        } else if ((str[i] &amp; 0xE0) == 0xC0) {\n            // 2 byte character\n            codepoint = (str[i] &amp; 0x1F) &lt;&lt; 6 | (str[i + 1] &amp; 0x3F);\n            i += 2;\n        } else if ((str[i] &amp; 0xF0) == 0xE0) {\n            // 3 byte character\n            codepoint = (str[i] &amp; 0x0F) &lt;&lt; 12 | (str[i + 1] &amp; 0x3F) &lt;&lt; 6 | (str[i + 2] &amp; 0x3F);\n            i += 3;\n        } else if ((str[i] &amp; 0xF8) == 0xF0) {\n            // 4 byte character\n            codepoint = (str[i] &amp; 0x07) &lt;&lt; 18 | (str[i + 1] &amp; 0x3F) &lt;&lt; 12 | (str[i + 2] &amp; 0x3F) &lt;&lt; 6\n                        | (str[i + 3] &amp; 0x3F);\n            i += 4;\n        }\n\n        h = (h &lt;&lt; 5) + h + codepoint;\n    }\n\n    return 2147483647 &amp; h;\n}\n\nstd::string get_search_id() {\n    Botan::AutoSeeded_RNG rng;\n\n    /*random unsigned long long generator*/\n    auto randull = [&amp;rng]() -&gt; uint64_t {\n        uint64_t res = 0;\n        std::vector&lt;uint8_t&gt; buffer(sizeof(res));\n        rng.randomize(buffer);\n        memcpy(&amp;res, buffer.data(), sizeof(res));\n        return res;\n    };\n\n    auto e = randull() % 20;\n    auto t = e * 18014398509481984;\n    auto n = (randull() % 4194304) * 4294967296;\n\n#ifdef PLATFORM_APPLE\n    auto now = std::chrono::system_clock::now();\n    auto now_time_t = std::chrono::system_clock::to_time_t(now);\n    auto duration = now.time_since_epoch() % 1000;\n    auto millis = std::chrono::duration_cast&lt;std::chrono::duration&lt;double, std::milli&gt;&gt;(duration)\n                      .count();\n    std::tm local_tm{};\n    localtime_r(&amp;now_time_t, &amp;local_tm);\n    auto seconds = mktime(&amp;local_tm);\n    double ts = static_cast&lt;double&gt;(seconds) * 1000.0 + millis;\n#else\n    std::chrono::time_point&lt;std::chrono::system_clock&gt; tp{std::chrono::system_clock::now()};\n    auto zoned_time = std::chrono::zoned_time{std::chrono::current_zone(), tp};\n    double ts = std::chrono::duration&lt;double, std::milli&gt;(\n                    zoned_time.get_local_time().time_since_epoch())\n                    .count();\n#endif\n\n    uint64_t a = lround(ts);\n    auto r = a % (24 * 60 * 60 * 1000);\n\n    return std::to_string(t + n + r);\n}\n\n} // namespace qqmusic::utils\n</code></pre>"},{"location":"dictionary/cookie_8cc/","title":"File cookie.cc","text":"<p>FileList &gt; src &gt; utils &gt; cookie.cc</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"qqmusic/result.h\"</code></li> <li><code>#include &lt;format&gt;</code></li> <li><code>#include &lt;nlohmann/json.hpp&gt;</code></li> <li><code>#include &lt;qqmusic/utils/cookie.h&gt;</code></li> <li><code>#include &lt;regex&gt;</code></li> </ul>"},{"location":"dictionary/cookie_8cc/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace utils \u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027 <p>The documentation for this class was generated from the following file <code>src/utils/cookie.cc</code></p>"},{"location":"dictionary/cookie_8cc_source/","title":"File cookie.cc","text":"<p>File List &gt; src &gt; utils &gt; cookie.cc</p> <p>Go to the documentation of this file</p> <pre><code>#include \"qqmusic/result.h\"\n#include &lt;format&gt;\n#include &lt;nlohmann/json.hpp&gt;\n#include &lt;qqmusic/utils/cookie.h&gt;\n#include &lt;regex&gt;\n\nnamespace qqmusic::utils {\n\nCookieJar::CookieJar(std::string_view cookie_str, std::string_view domain, std::string_view path) {\n    auto res = parse_cookie(cookie_str);\n    if (res.isErr()) {\n        throw std::runtime_error(res.unwrapErr().what());\n    }\n    auto json = res.unwrap();\n    content = nlohmann::json{{domain, {{path, json}}}};\n}\n\nqqmusic::Result&lt;void&gt; CookieJar::set(const Cookie&amp; cookie) {\n    content[cookie.domain][cookie.path][cookie.key] = cookie.value;\n    return Ok();\n}\n\nqqmusic::Result&lt;std::string&gt; CookieJar::get(std::string_view key,\n                                            std::optional&lt;std::string&gt; domain,\n                                            std::optional&lt;std::string&gt; path) {\n    try {\n        if (domain.has_value()) {\n            if (path.has_value()) {\n                return Ok(content[domain.value()][path.value()][key].get&lt;std::string&gt;());\n            } else {\n                /*Not provided with path, search all the paths*/\n                for (auto&amp; i : content[domain.value()].items()) {\n                    if (i.key() == key) {\n                        return Ok(i.value().get&lt;std::string&gt;());\n                    }\n                }\n                return Err(Exception(\n                    Exception::JsonError,\n                    \"[CookieJar::get] -- failed to get cookie value, does not has that key\"));\n            }\n        } else {\n            /*Not provided with domain and path, search all the items*/\n            for (auto&amp; i : content.items()) {\n                for (auto&amp; j : i.value().items()) {\n                    for (auto&amp; k : j.value().items()) {\n                        if (k.key() == key) {\n                            return Ok(k.value().get&lt;std::string&gt;());\n                        }\n                    }\n                }\n            }\n            return Err(\n                Exception(Exception::JsonError,\n                          \"[CookieJar::get] -- failed to get cookie value, does not has that key\"));\n        }\n    } catch (const std::exception&amp; e) {\n        return Err(Exception(Exception::JsonError,\n                             std::format(\"[CookieJar::get] -- failed to get cookie: {}\", e.what())));\n    }\n}\n\nqqmusic::Result&lt;void&gt; CookieJar::del(std::string_view key,\n                                     std::optional&lt;std::string&gt; domain,\n                                     std::optional&lt;std::string&gt; path) {\n    try {\n        if (domain.has_value()) {\n            if (path.has_value()) {\n                if (content.contains(domain) &amp;&amp; content[domain.value()].contains(path)\n                    &amp;&amp; content[domain.value()][path.value()].contains(key)) {\n                    content[domain.value()][path.value()].erase(key);\n                    return Ok();\n                } else {\n                    return Err(Exception(\n                        Exception::JsonError,\n                        std::format(\"[CookieJar::del] -- failed to delete cookie of key {}: error \"\n                                    \"domain, path or key\",\n                                    key)));\n                }\n            } else {\n                /*Not provided with path*/\n                if (content.contains(domain)) {\n                    for (auto&amp; i : content[domain.value()].items()) {\n                        if (i.value().contains(key)) {\n                            i.value().erase(key);\n                            return Ok();\n                        }\n                    }\n                    return Err(Exception(\n                        Exception::JsonError,\n                        std::format(\"[CookieJar::del] -- failed to \"\n                                    \"delete cookie of key {}: this domain does not has that key\",\n                                    key)));\n                } else {\n                    return Err(Exception(Exception::JsonError,\n                                         std::format(\"[CookieJar::del] -- failed to \"\n                                                     \"delete cookie of key {}: error domain\",\n                                                     key)));\n                }\n            }\n        } else {\n            /*Not provided with domain or path*/\n            for (auto&amp; i : content.items()) {\n                for (auto&amp; j : i.value().items()) {\n                    if (j.value().contains(key)) {\n                        j.value().erase(key);\n                        return Ok();\n                    }\n                }\n            }\n            return Err(Exception(Exception::JsonError,\n                                 std::format(\"[CookieJar::del] -- failed to \"\n                                             \"delete cookie of key {}: does not have that key\",\n                                             key)));\n        }\n    } catch (const std::exception&amp; e) {\n        return Err(\n            Exception(Exception::JsonError,\n                      std::format(\"[CookieJar::del] -- Failed to delete cookie of key {}: {}\",\n                                  key,\n                                  e.what())));\n    }\n}\n\nqqmusic::Result&lt;std::string&gt; CookieJar::dump() {\n    try {\n        return Ok(nlohmann::to_string(content));\n    } catch (const std::exception&amp; e) {\n        return Err(Exception(\n            Exception::JsonError,\n            std::format(\"[CookieJar::dump] -- Error occured when dump content to string: {}\",\n                        e.what())));\n    }\n}\n\n/*Serialize sellected domain's cookie to cookie string*/\nqqmusic::Result&lt;std::string&gt; CookieJar::serialize(std::string_view domain, std::string_view path) {\n    /*TODO: convert json to cookie string*/\n    std::string res;\n    if (!content.contains(domain)) {\n        return Err(Exception(Exception::JsonError,\n                             std::format(\"[CookieJar::serialize] -- Does not have that domain: {}\",\n                                         domain)));\n    }\n\n    if (content[domain].contains(path)) {\n        for (auto&amp; i : content[domain][path].items()) {\n            res += i.key();\n            res += \"=\";\n            res += i.value().get&lt;std::string&gt;();\n            res += \"; \";\n        }\n    } else {\n        for (auto&amp; j : content[domain].items()) {\n            for (auto&amp; i : content[domain][j.key()].items()) {\n                res += i.key();\n                res += \"=\";\n                res += i.value().get&lt;std::string&gt;();\n                res += \"; \";\n            }\n        }\n    }\n\n    res.erase(res.size() - 2);\n\n    return Ok(res);\n}\n\nqqmusic::Result&lt;void&gt; CookieJar::clear(std::optional&lt;std::string&gt; domain,\n                                       std::optional&lt;std::string&gt; path,\n                                       std::optional&lt;std::string&gt; key) {\n    try {\n        if (domain.has_value()) {\n            if (path.has_value()) {\n                if (key.has_value()) {\n                    if (content.contains(domain.value())\n                        &amp;&amp; content[domain.value()].contains(path.value())\n                        &amp;&amp; content[domain.value()][path.value()].contains(key)) {\n                        content[domain.value()][path.value()].erase(key);\n                        return Ok();\n                    } else {\n                        /*Bad domain or path or key*/\n                        return Err(Exception(Exception::JsonError,\n                                             \"[CookieJar::clear] -- Failed to clear \"\n                                             \"cookie items: Bad domain or path or key\"));\n                    }\n                } else {\n                    /*Not provided with key, delete the given domain and path's cookie*/\n                    if (content.contains(domain.value())\n                        &amp;&amp; content[domain.value()].contains(path.value())) {\n                        content[domain.value()][path.value()].clear();\n                        return Ok();\n                    } else {\n                        /*Bad domain or path*/\n                        return Err(Exception(Exception::JsonError,\n                                             \"[CookieJar::clear] -- Failed to clear \"\n                                             \"cookie items: Bad domain or path\"));\n                    }\n                }\n            } else {\n                /*Not provided with path and key, delete given domain's cookie*/\n                if (content.contains(domain.value())) {\n                    content[domain.value()].clear();\n                    return Ok();\n                } else {\n                    /*Bad domain*/\n                    return Err(Exception(\n                        Exception::JsonError,\n                        \"[CookieJar::get] -- Failed to get cookie value, does not has that key\"));\n                }\n            }\n        } else {\n            /*default clear all*/\n            content.clear();\n            return Ok();\n        }\n    } catch (const std::exception&amp; e) {\n        return Err(\n            Exception(Exception::UnknownError,\n                      std::format(\"[CookieJar::clear] -- Cannot clear cookie jar: {}\", e.what())));\n    }\n}\n\n/*Replace cookie jar content with a new Cookie object*/\nqqmusic::Result&lt;void&gt; CookieJar::update(const CookieJar&amp; cookies) {\n    content = cookies.content;\n    return Ok();\n}\n\nqqmusic::Result&lt;void&gt; CookieJar::merge(const CookieJar&amp; cookies) {\n    try {\n        for (auto&amp; i : cookies.content.items()) {\n            auto&amp; domain = content[i.key()];\n            for (auto&amp; j : i.value().items()) {\n                auto&amp; path = domain[j.key()];\n                for (auto&amp; k : j.value().items()) {\n                    // cover the old value by new ones\n                    path[k.key()] = k.value();\n                }\n            }\n        }\n        return Ok();\n    } catch (const std::exception&amp; e) {\n        return Err(\n            Exception(Exception::UnknownError,\n                      std::format(\"[CookieJar::merge] -- Cannot merge cookie: {}\", e.what())));\n    }\n}\n\nqqmusic::Result&lt;nlohmann::json&gt; parse_cookie(std::string_view cookie_str) {\n    /*\n     * Slice cookie into single `key=value` strings, then parse values\n     * */\n    try {\n        nlohmann::json res;\n        // std::regex cookie_pattern{R\"REGEX((.*?)=(.*?)(?:;(?: |)|$))REGEX\"};\n        std::regex cookie_pattern{R\"REGEX((\\s*([^=;]+)(?:=([^;]*))?))REGEX\"};\n        std::smatch matches;\n        std::string raw = std::string(cookie_str.begin(), cookie_str.end());\n        while (std::regex_search(raw, matches, cookie_pattern)) {\n            auto key = matches[2].str();\n            auto val = matches[3].str();\n            if (!(key == \"Expires\" || key == \"Secure\" || key == \"HttpOnly\" || key == \"SameSite\"\n                  || val.size() == 0)) {\n                res[key] = val;\n            }\n            raw = matches.suffix().str();\n        }\n        return Ok(res);\n    } catch (const std::exception&amp; e) {\n        return Err(Exception(Exception::UnknownError,\n                             std::format(\"[parse_cookie] -- Cannot parse cookie: {}\", e.what())));\n    }\n}\n\n} // namespace qqmusic::utils\n</code></pre>"},{"location":"dictionary/credential_8cc/","title":"File credential.cc","text":"<p>FileList &gt; src &gt; utils &gt; credential.cc</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;format&gt;</code></li> <li><code>#include &lt;nlohmann/detail/conversions/from_json.hpp&gt;</code></li> <li><code>#include &lt;nlohmann/detail/conversions/to_json.hpp&gt;</code></li> <li><code>#include &lt;qqmusic/details/api.h&gt;</code></li> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/common.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/credential.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/session.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;string_view&gt;</code></li> </ul>"},{"location":"dictionary/credential_8cc/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace utils \u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027 <p>The documentation for this class was generated from the following file <code>src/utils/credential.cc</code></p>"},{"location":"dictionary/credential_8cc_source/","title":"File credential.cc","text":"<p>File List &gt; src &gt; utils &gt; credential.cc</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;format&gt;\n#include &lt;nlohmann/detail/conversions/from_json.hpp&gt;\n#include &lt;nlohmann/detail/conversions/to_json.hpp&gt;\n#include &lt;qqmusic/details/api.h&gt;\n#include &lt;qqmusic/result.h&gt;\n#include &lt;qqmusic/utils/common.h&gt;\n#include &lt;qqmusic/utils/credential.h&gt;\n#include &lt;qqmusic/utils/session.h&gt;\n#include &lt;string&gt;\n#include &lt;string_view&gt;\n\nnamespace qqmusic::utils {\n\n/* NOTE: Assume that only loginType and musickey field can be defaulted*/\nCredential::Credential(nlohmann::json&amp; cookie) {\n    /*Write back the update result*/\n    cookie.at(\"openid\").get_to(openid);\n    cookie.erase(\"openid\");\n    cookie.at(\"refresh_token\").get_to(refresh_token);\n    cookie.erase(\"refresh_token\");\n    cookie.at(\"access_token\").get_to(access_token);\n    cookie.erase(\"access_token\");\n    cookie.at(\"expired_at\").get_to(expired_at);\n    cookie.erase(\"expired_at\");\n    cookie.at(\"musicid\").get_to(musicid);\n    cookie.erase(\"musicid\");\n    cookie.at(\"unionid\").get_to(unionid);\n    cookie.erase(\"unionid\");\n    cookie.at(\"str_musicid\").get_to(str_musicid);\n    cookie.erase(\"str_musicid\");\n    cookie.at(\"musickey\").get_to(musickey);\n    cookie.erase(\"musickey\");\n    cookie.at(\"refresh_key\").get_to(refresh_key);\n    cookie.erase(\"refresh_key\");\n    cookie.at(\"encryptUin\").get_to(encryptUin);\n    cookie.erase(\"encryptUin\");\n    cookie.at(\"loginType\").get_to(loginType);\n    cookie.erase(\"loginType\");\n    extra_fields = cookie;\n    if (cookie.contains(\"musickey\")) {\n        musickey = cookie[\"musickey\"].get&lt;std::string&gt;();\n\n        if (!cookie.contains(\"loginType\") &amp;&amp; musickey.substr(0, 3) == \"W_X\") {\n            loginType = 1;\n        } else {\n            loginType = 2;\n        }\n    }\n}\n\n// TODO: is there a way to delete the repeat code here ?\nCredential::Credential(std::string_view cookie) {\n    auto data = nlohmann::json::parse(cookie);\n    /*Write back the update result*/\n    data.at(\"openid\").get_to(openid);\n    data.erase(\"openid\");\n    data.at(\"refresh_token\").get_to(refresh_token);\n    data.erase(\"refresh_token\");\n    data.at(\"access_token\").get_to(access_token);\n    data.erase(\"access_token\");\n    data.at(\"expired_at\").get_to(expired_at);\n    data.erase(\"expired_at\");\n    data.at(\"musicid\").get_to(musicid);\n    data.erase(\"musicid\");\n    data.at(\"unionid\").get_to(unionid);\n    data.erase(\"unionid\");\n    data.at(\"str_musicid\").get_to(str_musicid);\n    data.erase(\"str_musicid\");\n    data.at(\"musickey\").get_to(musickey);\n    data.erase(\"musickey\");\n    data.at(\"refresh_key\").get_to(refresh_key);\n    data.erase(\"refresh_key\");\n    data.at(\"encryptUin\").get_to(encryptUin);\n    data.erase(\"encryptUin\");\n    data.at(\"loginType\").get_to(loginType);\n    data.erase(\"loginType\");\n    extra_fields = data;\n    if (data.contains(\"musickey\")) {\n        musickey = data[\"musickey\"].get&lt;std::string&gt;();\n\n        if (!data.contains(\"loginType\") &amp;&amp; musickey.substr(0, 3) == \"W_X\") {\n            loginType = 1;\n        } else {\n            loginType = 2;\n        }\n    }\n}\n\nbool Credential::from_cache(std::string_view cache) {\n    /*Write back the update result*/\n    try {\n        auto data = nlohmann::json::parse(cache);\n        data.at(\"openid\").get_to(openid);\n        data.at(\"refresh_token\").get_to(refresh_token);\n        data.at(\"access_token\").get_to(access_token);\n        data.at(\"expired_at\").get_to(expired_at);\n        data.at(\"musicid\").get_to(musicid);\n        data.at(\"unionid\").get_to(unionid);\n        data.at(\"str_musicid\").get_to(str_musicid);\n        data.at(\"musickey\").get_to(musickey);\n        data.at(\"refresh_key\").get_to(refresh_key);\n        data.at(\"encryptUin\").get_to(encryptUin);\n        data.at(\"loginType\").get_to(loginType);\n        data.at(\"extra_fields\").get_to(extra_fields);\n    } catch (const std::exception&amp; e) {\n        return true;\n    }\n    return false;\n}\n\nbool Credential::from_cache(nlohmann::json&amp; cache) {\n    /*Write back the update result*/\n    try {\n        cache.at(\"openid\").get_to(openid);\n        cache.at(\"refresh_token\").get_to(refresh_token);\n        cache.at(\"access_token\").get_to(access_token);\n        cache.at(\"expired_at\").get_to(expired_at);\n        cache.at(\"musicid\").get_to(musicid);\n        cache.at(\"unionid\").get_to(unionid);\n        cache.at(\"str_musicid\").get_to(str_musicid);\n        cache.at(\"musickey\").get_to(musickey);\n        cache.at(\"refresh_key\").get_to(refresh_key);\n        cache.at(\"encryptUin\").get_to(encryptUin);\n        cache.at(\"loginType\").get_to(loginType);\n        cache.at(\"extra_fields\").get_to(extra_fields);\n    } catch (const std::exception&amp; e) {\n        return true;\n    }\n    return false;\n}\n\nbool Credential::is_valid() const {\n    if (musickey.size() == 0 || musicid == 0) {\n        /*credential have no musickey or musicid is not valid*/\n        return false;\n    }\n    return true;\n}\n\nqqmusic::Result&lt;nlohmann::json&gt; Credential::to_json() {\n    try {\n        nlohmann::json res;\n        nlohmann::to_json(res, *this);\n        res[\"extra_fields\"] = extra_fields;\n        return Ok(res);\n    } catch (const std::exception&amp; e) {\n        return Err(Exception(Exception::DataDestroy,\n                             std::format(\"[Credential::as_json] -- failed to generate json: {}\",\n                                         e.what())));\n    }\n}\n\nqqmusic::Result&lt;std::string&gt; Credential::to_string() {\n    try {\n        nlohmann::json res;\n        nlohmann::to_json(res, *this);\n        res[\"extra_fields\"] = extra_fields;\n        return Ok(res.dump());\n    } catch (const std::exception&amp; e) {\n        return Err(\n            Exception(Exception::JsonError,\n                      std::format(\"[Credential::as_string] -- failed to generate json string: {}\",\n                                  e.what())));\n    }\n}\n\nqqmusic::Task&lt;qqmusic::Result&lt;bool&gt;&gt; Credential::is_expired() {\n    auto session = SessionManager::get_instance().get_session();\n    auto api = details::Api(session, \"music.UserInfo.userInfoServer\", \"GetLoginUserInfo\", *this);\n    auto req_param_res = co_await api.prepare_request(nlohmann::json::object());\n    if (req_param_res.isErr()) {\n        co_return Err(Exception(\n            Exception::Kind(req_param_res.unwrapErr().get_error_enum()),\n            std::format(\"[Credential::is_expired] -- Error occurred when preparing request: `{}`\",\n                        req_param_res.unwrapErr().what())));\n    }\n    auto url = req_param_res.unwrap().url;\n    auto req = req_param_res.unwrap().req;\n    auto resp_res = co_await session.perform_request(url, req);\n    if (resp_res.isErr()) {\n        co_return Err(Exception(\n            Exception::Kind(resp_res.unwrapErr().get_error_enum()),\n            std::format(\"[Credential::is_expired] -- Error occurred when performing request: `{}`\",\n                        resp_res.unwrapErr().what())));\n    }\n    auto json_res = api.parse_response(resp2buf(resp_res.unwrap()));\n    if (json_res.isErr()) {\n        switch (json_res.unwrapErr().get_error_enum()) {\n            using namespace qqmusic::utils;\n        case Exception::CredendialExpiredError:\n            co_return Ok(true);\n        case Exception::SignInvalidError:\n            co_return Err(json_res.unwrapErr());\n        default:\n            co_return Ok(false);\n        }\n    }\n    co_return Ok(false);\n}\n\nqqmusic::Task&lt;qqmusic::Result&lt;void&gt;&gt; Credential::refresh() {\n    auto session = SessionManager::get_instance().get_session();\n    auto api = details::Api(session,\n                            \"music.login.LoginServer\",\n                            \"Login\",\n                            *this,\n                            {\"tmeLoginType\", std::to_string(loginType)});\n\n    nlohmann::json params = {\n        {\"refresh_key\", refresh_key},\n        {\"refresh_token\", refresh_token},\n        {\"musickey\", musickey},\n        {\"musicid\", musicid},\n    };\n\n    auto request_res = co_await api.prepare_request(params);\n    if (request_res.isErr()) {\n        co_return Err(Exception(\n            Exception::Kind(request_res.unwrapErr().get_error_enum()),\n            std::format(\"[Credential::refresh] -- Error occurred when preparing request: `{}`\",\n                        request_res.unwrapErr().what())));\n    }\n\n    auto url = request_res.unwrap().url;\n    auto req = request_res.unwrap().req;\n    auto response_res = co_await session.perform_request(url, req);\n    if (response_res.isErr()) {\n        co_return Err(Exception(response_res.unwrapErr()));\n    }\n\n    auto json_res = api.parse_response(resp2buf(response_res.unwrap()));\n    if (json_res.isErr()) {\n        co_return Err(json_res.unwrapErr());\n    }\n\n    auto json = json_res.unwrap();\n    try {\n        /*Write back the update result*/\n        json.at(\"openid\").get_to(openid);\n        json.erase(\"openid\");\n        json.at(\"refresh_token\").get_to(refresh_token);\n        json.erase(\"refresh_token\");\n        json.at(\"access_token\").get_to(access_token);\n        json.erase(\"access_token\");\n        json.at(\"expired_at\").get_to(expired_at);\n        json.erase(\"expired_at\");\n        json.at(\"musicid\").get_to(musicid);\n        json.erase(\"musicid\");\n        json.at(\"unionid\").get_to(unionid);\n        json.erase(\"unionid\");\n        json.at(\"str_musicid\").get_to(str_musicid);\n        json.erase(\"str_musicid\");\n        json.at(\"musickey\").get_to(musickey);\n        json.erase(\"musickey\");\n        json.at(\"refresh_key\").get_to(refresh_key);\n        json.erase(\"refresh_key\");\n        json.at(\"encryptUin\").get_to(encryptUin);\n        json.erase(\"encryptUin\");\n        json.at(\"loginType\").get_to(loginType);\n        json.erase(\"loginType\");\n        extra_fields = json;\n    } catch (const std::exception&amp; e) {\n        co_return Err(\n            Exception(Exception::JsonError,\n                      std::format(\"[Credential::refresh] -- Cannot write back from json: {}\",\n                                  e.what())));\n    }\n    co_return Ok();\n}\n\n} // namespace qqmusic::utils\n</code></pre>"},{"location":"dictionary/device_8cc/","title":"File device.cc","text":"<p>FileList &gt; src &gt; utils &gt; device.cc</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/uuid.hpp&gt;</code></li> <li><code>#include &lt;boost/uuid/detail/md5.hpp&gt;</code></li> <li><code>#include &lt;botan/auto_rng.h&gt;</code></li> <li><code>#include &lt;botan/hex.h&gt;</code></li> <li><code>#include &lt;exception&gt;</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;format&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;nlohmann/detail/conversions/from_json.hpp&gt;</code></li> <li><code>#include &lt;nlohmann/json.hpp&gt;</code></li> <li><code>#include &lt;qqmusic/utils/buffer.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/device.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/paths.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"dictionary/device_8cc/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace utils \u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027 <p>The documentation for this class was generated from the following file <code>src/utils/device.cc</code></p>"},{"location":"dictionary/device_8cc_source/","title":"File device.cc","text":"<p>File List &gt; src &gt; utils &gt; device.cc</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;boost/uuid.hpp&gt;\n#include &lt;boost/uuid/detail/md5.hpp&gt;\n#include &lt;botan/auto_rng.h&gt;\n#include &lt;botan/hex.h&gt;\n#include &lt;exception&gt;\n#include &lt;filesystem&gt;\n#include &lt;format&gt;\n#include &lt;fstream&gt;\n#include &lt;nlohmann/detail/conversions/from_json.hpp&gt;\n#include &lt;nlohmann/json.hpp&gt;\n#include &lt;qqmusic/utils/buffer.h&gt;\n#include &lt;qqmusic/utils/device.h&gt;\n#include &lt;qqmusic/utils/paths.h&gt;\n#include &lt;string&gt;\n\nnamespace qqmusic::utils {\n\nqqmusic::Result&lt;Device&gt; get_device_info() {\n    try {\n        auto cache_path = PathManager::get_instance().get_cache_path()\n                          / std::filesystem::path(\"device.json\");\n\n        Device device;\n\n        std::fstream fs(cache_path.c_str());\n        if (fs.good()) {\n            /*file exist, load cache*/\n            std::ostringstream oss;\n            std::string line;\n            while (std::getline(fs, line)) {\n                oss &lt;&lt; line &lt;&lt; '\\n';\n            }\n            std::string s = oss.str();\n\n            try {\n                nlohmann::json j = nlohmann::json::parse(s);\n                nlohmann::from_json(j, device);\n                return Ok(device);\n            } catch (const std::exception&amp; e) {\n                std::cout &lt;&lt; e.what() &lt;&lt; std::endl;\n                /*parse error, data destroy, create a new one*/\n                fs.close();\n                fs.open(cache_path.c_str(), std::ios::out);\n                nlohmann::json j;\n                nlohmann::to_json(j, device);\n                fs &lt;&lt; nlohmann::to_string(j);\n                fs.close();\n                return Ok(device);\n            }\n        } else {\n            /*file not exist, create a new one*/\n            fs.open(cache_path.c_str(), std::ios::out);\n            nlohmann::json j;\n            nlohmann::to_json(j, device);\n            fs &lt;&lt; nlohmann::to_string(j);\n            fs.close();\n            return Ok(device);\n        }\n    } catch (const std::exception&amp; e) {\n        return Err(Exception(Exception::UnknownError,\n                             std::format(\"[get_device_info] -- get random device info failure: {}\",\n                                         e.what())));\n    }\n}\n\nqqmusic::Result&lt;void&gt; cache_device(const Device&amp; device) {\n    auto cache_path = PathManager::get_instance().get_cache_path()\n                      / std::filesystem::path(\"device.json\");\n\n    try {\n        std::fstream fs;\n        fs.open(cache_path.c_str(), std::ios::out);\n        nlohmann::json j;\n        nlohmann::to_json(j, device);\n        fs &lt;&lt; nlohmann::to_string(j);\n        fs.close();\n        return Ok();\n    } catch (const std::exception&amp; e) {\n        return Err(Exception(Exception::UnknownError,\n                             std::format(\"[cache_device] -- cannot cache device: {}\", e.what())));\n    }\n}\n\nOSVersion::OSVersion() {\n    incremental = \"5891938\";\n    release = \"10\";\n    codename = \"REL\";\n    sdk = 29;\n}\n\nDevice::Device() {\n    /*default initialization*/\n\n    Botan::AutoSeeded_RNG rng;\n\n    /*random unsigned long long generator*/\n    auto randull = [&amp;rng]() -&gt; uint64_t {\n        uint64_t res = 0;\n        std::vector&lt;uint8_t&gt; buffer(sizeof(res));\n        rng.randomize(buffer);\n        memcpy(&amp;res, buffer.data(), sizeof(res));\n        return res;\n    };\n\n    /*random string generator*/\n    auto randstr = [&amp;randull](int len) -&gt; std::string {\n        const static char alphanum[] = \"0123456789\"\n                                       \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                                       \"abcdefghijklmnopqrstuvwxyz\";\n        std::string tmp_s;\n        tmp_s.reserve(len);\n\n        for (int i = 0; i &lt; len; ++i) {\n            tmp_s += alphanum[randull() % (sizeof(alphanum) - 1)];\n        }\n\n        return tmp_s;\n    };\n\n    /*random imei generator */\n    /*\n     * NOTE: The imei cannot pass check, either the python version.\n     *       def random_imei() -&gt; str:\n     *           \"\"\"\u751f\u6210\u968f\u673a IMEI \u53f7\u7801.\n     *           Returns:\n     *               \u968f\u673a\u751f\u6210\u7684 IMEI \u53f7\u7801\n     *           \"\"\"\n     *           imei = []\n     *           sum_ = 0\n     *           for i in range(14):\n     *               num = random.randint(0, 9)\n     *               if (i + 2) % 2 == 0:\n     *                   num *= 2\n     *                   if num &gt;= 10:\n     *                       num = (num % 10) + 1\n     *               sum_ += num\n     *               imei.append(str(num))\n     *           ctrl_digit = (sum_ * 9) % 10\n     *           imei.append(str(ctrl_digit))\n     *           return \"\".join(imei)\n     * */\n    auto randimei = [&amp;randull]() -&gt; std::string {\n        std::string res;\n        int sum = 0;\n        for (int i = 0; i &lt; 14; ++i) {\n            int num = (int) (randull() % 10);\n            if ((i + 2) % 2 == 0) {\n                num *= 2;\n                num %= 10;\n            }\n            sum += num;\n            res += (char) ('0' + num);\n        }\n        int ctrl_digit = (sum * 9) % 10;\n        res += (char) ('0' + ctrl_digit);\n        return res;\n    };\n\n    display = std::format(\"QMAPI.{}.001\", randull() % 8999999 + 1000000);\n    product = \"iarim\";\n    device = \"sagit\";\n    board = \"eomam\";\n    model = \"MI 6\";\n\n    fingerprint = std::format(\"xiaomi/iarim/sagit:10/eomam.200122.001/{}:user/release-keys\",\n                              randull() % 8999999 + 1000000);\n\n    boost::uuids::uuid u = boost::uuids::random_generator()();\n    boot_id = to_string(u);\n\n    proc_version = std::format(\"Linux 5.4.0-54-generic-{} (android-build@google.com)\", randstr(8));\n\n    imei = randimei();\n    brand = \"Xiaomi\";\n    bootloader = \"U-boot\";\n    base_band = \"\";\n    version = OSVersion();\n    sim_info = \"T-Mobile\";\n    os_type = \"android\";\n    mac_address = \"00:50:56:C0:00:08\";\n    ip_address = {10, 0, 1, 3};\n    wifi_bssid = \"00:50:56:C0:00:08\";\n    wifi_ssid = \"&lt;unknown ssid&gt;\";\n\n    /*calculate md5 sum and store as std::vector&lt;int&gt; by bytes*/\n    std::vector&lt;uint8_t&gt; imsi_buf(16);\n    rng.random_vec(imsi_buf);\n    boost::uuids::detail::md5 hash;\n    boost::uuids::detail::md5::digest_type d;\n    hash.process_bytes(imsi_buf.data(), imsi_buf.size());\n    hash.get_digest(d);\n    buffer imsi_res_buf(d, 16);\n\n    imsi_md5 = std::vector&lt;int&gt;(imsi_res_buf.begin(), imsi_res_buf.end());\n\n    std::vector&lt;uint8_t&gt; android_id_buf(8);\n    rng.randomize(android_id_buf);\n    android_id = Botan::hex_encode(android_id_buf, false);\n    apn = \"wifi\";\n    vendor_name = \"MIUI\";\n    vendor_os_name = \"qmapi\";\n}\n\n} // namespace qqmusic::utils\n</code></pre>"},{"location":"dictionary/paths_8cc/","title":"File paths.cc","text":"<p>FileList &gt; src &gt; utils &gt; paths.cc</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdlib&gt;</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;qqmusic/utils/paths.h&gt;</code></li> </ul>"},{"location":"dictionary/paths_8cc/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace utils \u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027 <p>The documentation for this class was generated from the following file <code>src/utils/paths.cc</code></p>"},{"location":"dictionary/paths_8cc_source/","title":"File paths.cc","text":"<p>File List &gt; src &gt; utils &gt; paths.cc</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;cstdlib&gt;\n#include &lt;filesystem&gt;\n#include &lt;qqmusic/utils/paths.h&gt;\n\nnamespace qqmusic::utils {\n\nPathManager&amp; PathManager::get_instance() {\n    static PathManager cm;\n    return cm;\n}\n\nstd::filesystem::path PathManager::get_log_path() const {\n    return log_path;\n}\n\nstd::filesystem::path PathManager::get_cache_path() const {\n    return cache_path;\n}\n\nstd::filesystem::path PathManager::get_download_path() const {\n    return download_path;\n}\n\nvoid PathManager::set_log_path(std::string_view path) {\n    log_path = fs::path(path);\n}\n\nvoid PathManager::set_cache_path(std::string_view path) {\n    cache_path = fs::path(path);\n}\n\nvoid PathManager::set_download_path(std::string_view path) {\n    download_path = fs::path(path);\n}\n\nvoid PathManager::set_log_path(const std::filesystem::path&amp; path) {\n    log_path = path;\n}\n\nvoid PathManager::set_cache_path(const std::filesystem::path&amp; path) {\n    cache_path = path;\n}\n\nvoid PathManager::set_download_path(const std::filesystem::path&amp; path) {\n    download_path = path;\n}\n\nPathManager::PathManager() {\n#ifdef PLATFORM_WINDOWS\n    /*Windows Related Code*/\n    auto local_app_data = getenv(\"%LOCALAPPDATA%\");\n    if (local_app_data == nullptr) {\n        auto home = getenv(\"%USERPROFILE%\");\n        if (home == nullptr) {\n            cache_path = fs::path(fs::current_path()) / fs::path(\"cache\");\n            log_path = fs::path(fs::current_path()) / fs::path(\"log\");\n            download_path = fs::path(fs::current_path()) / fs::path(\"download\");\n        } else {\n            cache_path = fs::path(home) / fs::path(\".cache/qqmusic-api-cxx/cache\");\n            log_path = fs::path(home) / fs::path(\".cache/qqmusic-api-cxx/log\");\n            download_path = fs::path(home) / fs::path(\"Downloads/qqmusic-api-cxx\");\n        }\n    } else {\n        cache_path = fs::path(local_app_data) / fs::path(\"qqmusic-api-cxx/cache\");\n        log_path = fs::path(local_app_data) / fs::path(\"qqmusic-api-cxx/log\");\n        auto home = getenv(\"%USERPROFILE%\");\n        if (home == nullptr) {\n            download_path = fs::path(fs::current_path()) / fs::path(\"download\");\n        } else {\n            download_path = fs::path(home) / fs::path(\"Downloads/qqmusic-api-cxx\");\n        }\n    }\n\n#elif defined(PLATFORM_LINUX)\n    auto xdg_cache_home = getenv(\"XDG_CACHE_HOME\");\n    if (xdg_cache_home == nullptr) {\n        auto home = getenv(\"HOME\");\n        if (home == nullptr) {\n            cache_path = fs::path(fs::current_path()) / fs::path(\"cache\");\n            log_path = fs::path(fs::current_path()) / fs::path(\"log\");\n            download_path = fs::path(fs::current_path()) / fs::path(\"download\");\n        } else {\n            cache_path = fs::path(home) / fs::path(\".cache/qqmusic-api-cxx/cache\");\n            log_path = fs::path(home) / fs::path(\".cache/qqmusic-api-cxx/log\");\n            download_path = fs::path(home) / fs::path(\"Downloads/qqmusic-api-cxx\");\n        }\n    } else {\n        cache_path = fs::path(xdg_cache_home) / fs::path(\"qqmusic-api-cxx/cache\");\n        log_path = fs::path(xdg_cache_home) / fs::path(\"qqmusic-api-cxx/log\");\n        auto home = getenv(\"HOME\");\n        if (home == nullptr) {\n            download_path = fs::path(fs::current_path()) / fs::path(\"download\");\n        } else {\n            download_path = fs::path(home) / fs::path(\"Downloads/qqmusic-api-cxx\");\n        }\n    }\n\n#elif defined(PLATFORM_APPLE)\n    /*MacOS Related Code*/\n    auto home = getenv(\"HOME\");\n    if (home == nullptr) {\n        cache_path = fs::path(fs::current_path()) / fs::path(\"cache\");\n        log_path = fs::path(fs::current_path()) / fs::path(\"log\");\n        download_path = fs::path(fs::current_path()) / fs::path(\"download\");\n    } else {\n        cache_path = fs::path(home) / fs::path(\"Library/Caches/qqmusic-api-cxx/cache\");\n        log_path = fs::path(home) / fs::path(\"Library/Caches/qqmusic-api-cxx/log\");\n        download_path = fs::path(home) / fs::path(\"Downloads/qqmusic-api-cxx\");\n    }\n#else\n    /*Warining platform not supported*/\n#error \"Platform not supported\"\n#endif\n    if (!fs::exists(cache_path)) {\n        fs::create_directories(cache_path);\n    }\n\n    if (!fs::exists(download_path)) {\n        fs::create_directories(download_path);\n    }\n\n    if (!fs::exists(log_path)) {\n        fs::create_directories(log_path);\n    }\n}\n\n} // namespace qqmusic::utils\n</code></pre>"},{"location":"dictionary/qimei_8cc/","title":"File qimei.cc","text":"<p>FileList &gt; src &gt; utils &gt; qimei.cc</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/beast.hpp&gt;</code></li> <li><code>#include &lt;boost/beast/http/impl/read.hpp&gt;</code></li> <li><code>#include &lt;boost/beast/http/impl/verb.ipp&gt;</code></li> <li><code>#include &lt;boost/beast/http/message.hpp&gt;</code></li> <li><code>#include &lt;boost/beast/http/string_body.hpp&gt;</code></li> <li><code>#include &lt;boost/beast/http/verb.hpp&gt;</code></li> <li><code>#include &lt;boost/url.hpp&gt;</code></li> <li><code>#include &lt;boost/uuid/detail/md5.hpp&gt;</code></li> <li><code>#include &lt;botan/asn1_obj.h&gt;</code></li> <li><code>#include &lt;botan/auto_rng.h&gt;</code></li> <li><code>#include &lt;botan/base64.h&gt;</code></li> <li><code>#include &lt;botan/block_cipher.h&gt;</code></li> <li><code>#include &lt;botan/cipher_mode.h&gt;</code></li> <li><code>#include &lt;botan/data_src.h&gt;</code></li> <li><code>#include &lt;botan/hex.h&gt;</code></li> <li><code>#include &lt;botan/pem.h&gt;</code></li> <li><code>#include &lt;botan/pubkey.h&gt;</code></li> <li><code>#include &lt;botan/rsa.h&gt;</code></li> <li><code>#include &lt;botan/secmem.h&gt;</code></li> <li><code>#include &lt;botan/x509_key.h&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;ctime&gt;</code></li> <li><code>#include &lt;format&gt;</code></li> <li><code>#include &lt;nlohmann/json.hpp&gt;</code></li> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/buffer.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/device.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/qimei.h&gt;</code></li> <li><code>#include &lt;set&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"dictionary/qimei_8cc/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const char APP_KEY   = <code>\"0AND0HD6FE4HY80F\"</code> const char PUBLIC_KEY   = <code>/* multi line expression */</code> const char SECRET   = <code>\"ZdJqM15EeO2zWc08\"</code>"},{"location":"dictionary/qimei_8cc/#public-static-functions","title":"Public Static Functions","text":"Type Name qqmusic::Result&lt; qqmusic::utils::buffer &gt; aes_encrypt (qqmusic::utils::buffer &amp; key, qqmusic::utils::buffer &amp; buf)  nlohmann::json load_rand_payload (qqmusic::utils::Device &amp; device, std::string_view version)  std::string random_beacon_id ()  qqmusic::Result&lt; qqmusic::utils::buffer &gt; rsa_encrypt (qqmusic::utils::buffer &amp; buf)"},{"location":"dictionary/qimei_8cc/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"dictionary/qimei_8cc/#variable-app_key","title":"variable APP_KEY","text":"<pre><code>const char APP_KEY[];\n</code></pre>"},{"location":"dictionary/qimei_8cc/#variable-public_key","title":"variable PUBLIC_KEY","text":"<pre><code>const char PUBLIC_KEY[];\n</code></pre>"},{"location":"dictionary/qimei_8cc/#variable-secret","title":"variable SECRET","text":"<pre><code>const char SECRET[];\n</code></pre>"},{"location":"dictionary/qimei_8cc/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"dictionary/qimei_8cc/#function-aes_encrypt","title":"function aes_encrypt","text":"<pre><code>static qqmusic::Result&lt; qqmusic::utils::buffer &gt; aes_encrypt (\n    qqmusic::utils::buffer &amp; key,\n    qqmusic::utils::buffer &amp; buf\n) \n</code></pre>"},{"location":"dictionary/qimei_8cc/#function-load_rand_payload","title":"function load_rand_payload","text":"<pre><code>static nlohmann::json load_rand_payload (\n    qqmusic::utils::Device &amp; device,\n    std::string_view version\n) \n</code></pre>"},{"location":"dictionary/qimei_8cc/#function-random_beacon_id","title":"function random_beacon_id","text":"<pre><code>static std::string random_beacon_id () \n</code></pre>"},{"location":"dictionary/qimei_8cc/#function-rsa_encrypt","title":"function rsa_encrypt","text":"<pre><code>static qqmusic::Result&lt; qqmusic::utils::buffer &gt; rsa_encrypt (\n    qqmusic::utils::buffer &amp; buf\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/utils/qimei.cc</code></p>"},{"location":"dictionary/qimei_8cc_source/","title":"File qimei.cc","text":"<p>File List &gt; src &gt; utils &gt; qimei.cc</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;boost/beast.hpp&gt;\n#include &lt;boost/beast/http/impl/read.hpp&gt;\n#include &lt;boost/beast/http/impl/verb.ipp&gt;\n#include &lt;boost/beast/http/message.hpp&gt;\n#include &lt;boost/beast/http/string_body.hpp&gt;\n#include &lt;boost/beast/http/verb.hpp&gt;\n#include &lt;boost/url.hpp&gt;\n#include &lt;boost/uuid/detail/md5.hpp&gt;\n#include &lt;botan/asn1_obj.h&gt;\n#include &lt;botan/auto_rng.h&gt;\n#include &lt;botan/base64.h&gt;\n#include &lt;botan/block_cipher.h&gt;\n#include &lt;botan/cipher_mode.h&gt;\n#include &lt;botan/data_src.h&gt;\n#include &lt;botan/hex.h&gt;\n#include &lt;botan/pem.h&gt;\n#include &lt;botan/pubkey.h&gt;\n#include &lt;botan/rsa.h&gt;\n#include &lt;botan/secmem.h&gt;\n#include &lt;botan/x509_key.h&gt;\n#include &lt;chrono&gt;\n#include &lt;ctime&gt;\n#include &lt;format&gt;\n#include &lt;nlohmann/json.hpp&gt;\n#include &lt;qqmusic/result.h&gt;\n#include &lt;qqmusic/utils/buffer.h&gt;\n#include &lt;qqmusic/utils/device.h&gt;\n#include &lt;qqmusic/utils/qimei.h&gt;\n#include &lt;set&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nconst static char PUBLIC_KEY[] = \"-----BEGIN PUBLIC KEY-----\\n\\\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDEIxgwoutfwoJxcGQeedgP7FG9qaIuS0qzf\\\nR8gWkrkTZKM2iWHn2ajQpBRZjMSoSf6+KJGvar2ORhBfpDXyVtZCKpqLQ+FLkpncClKVIrBwv6\\\nPHyUvuCb0rIarmgDnzkfQAqVufEtR64iazGDKatvJ9y6B9NMbHddGSAUmRTCrHQIDAQAB\\n\\\n-----END PUBLIC KEY-----\";\nconst static char SECRET[] = \"ZdJqM15EeO2zWc08\";\nconst static char APP_KEY[] = \"0AND0HD6FE4HY80F\";\n\nstatic qqmusic::Result&lt;qqmusic::utils::buffer&gt; rsa_encrypt(qqmusic::utils::buffer&amp; buf);\nstatic qqmusic::Result&lt;qqmusic::utils::buffer&gt; aes_encrypt(qqmusic::utils::buffer&amp; key,\n                                                           qqmusic::utils::buffer&amp; buf);\nstatic std::string random_beacon_id();\n/*load random payload by device*/\nstatic nlohmann::json load_rand_payload(qqmusic::utils::Device&amp; device, std::string_view version);\n\nqqmusic::Result&lt;qqmusic::utils::QimeiResult&gt; qqmusic::utils::get_qimei(\n    qqmusic::utils::Device&amp; device, std::string_view version) {\n    using namespace boost::beast;\n\n    /*if generate error, return default qimei*/\n    const char QIMEI_ENTRY[] = \"https://api.tencentmusic.com/tme/trpc/proxy\";\n    Botan::AutoSeeded_RNG rng;\n\n    try {\n        auto gen_hex_strings = [&amp;rng](int len) {\n            const char table[] = \"abcdef1234567890\";\n            uint64_t randi = 0;\n            std::vector&lt;uint8_t&gt; buffer(sizeof(randi));\n            rng.randomize(buffer);\n            memcpy(&amp;randi, buffer.data(), sizeof(randi));\n            std::vector&lt;char&gt; res(len);\n            for (auto&amp; i : res) {\n                rng.randomize(buffer);\n                memcpy(&amp;randi, buffer.data(), sizeof(randi));\n                i = table[randi % 16];\n            }\n            return std::string(res.data(), res.size());\n        };\n\n        auto crypt_key = gen_hex_strings(16);\n        auto nonce = gen_hex_strings(16);\n\n        std::string key;\n        std::string params;\n\n        qqmusic::utils::buffer crypt_key_buf((uint8_t*) crypt_key.data(), crypt_key.size());\n        auto rsa_res = rsa_encrypt(crypt_key_buf);\n        if (rsa_res.isErr()) {\n            return Err(\n                qqmusic::utils::Exception(qqmusic::utils::Exception::DataDestroy,\n                                          std::format(\"[get_qimei] -- failed to get qimei: {}\",\n                                                      rsa_res.unwrapErr().what())));\n        } else {\n            key = Botan::base64_encode(rsa_res.unwrap());\n        }\n\n        auto payload = nlohmann::to_string(load_rand_payload(device, version));\n        qqmusic::utils::buffer buf((uint8_t*) payload.data(), payload.size());\n        auto aes_res = aes_encrypt(crypt_key_buf, buf);\n        if (aes_res.isErr()) {\n            return Err(\n                qqmusic::utils::Exception(qqmusic::utils::Exception::DataDestroy,\n                                          std::format(\"[get_qimei] -- failed to get qimei: {}\",\n                                                      rsa_res.unwrapErr().what())));\n        } else {\n            params = Botan::base64_encode(aes_res.unwrap());\n        }\n\n        std::string extra = R\"({\"appKey\":\")\";\n        extra += APP_KEY;\n        extra += R\"(\"})\";\n\n        /*get time stamp by second*/\n        uint64_t ts = std::chrono::time_point&lt;std::chrono::system_clock&gt;(\n                          std::chrono::system_clock::now())\n                          .time_since_epoch()\n                          .count();\n        ts /= 1000000000;\n\n        boost::uuids::detail::md5 hash;\n        boost::uuids::detail::md5::digest_type d;\n        std::string ts_s = std::to_string(ts * 1000);\n        auto hash_buf = key + params + ts_s + nonce + SECRET + extra;\n        hash.process_bytes(hash_buf.data(), hash_buf.size());\n        hash.get_digest(d);\n        std::string sign = Botan::hex_encode(d, sizeof(d), false);\n\n        /*prepare params*/\n        boost::uuids::detail::md5 header_hash;\n        boost::uuids::detail::md5::digest_type hd;\n        ts_s = std::to_string(ts);\n        auto header_sign_buf = \"qimei_qq_androidpzAuCmaFAaFaHrdakPjLIEqKrGnSOOvH\" + ts_s;\n        header_hash.process_bytes(header_sign_buf.data(), header_sign_buf.size());\n        header_hash.get_digest(hd);\n\n        /*request header table*/\n        nlohmann::json headers = {{\"Host\", \"api.tencentmusic.com\"},\n                                  {\"method\", \"GetQimei\"},\n                                  {\"service\", \"trpc.tme_datasvr.qimeiproxy.QimeiProxy\"},\n                                  {\"appid\", \"qimei_qq_android\"},\n                                  {\"sign\", Botan::hex_encode(hd, sizeof(hd), false)},\n                                  {\"user-agent\", \"QQMusic\"},\n                                  {\"timestamp\", ts_s},\n                                  {\"content-type\", \"application/json\"},\n                                  {\"accept\", \"*/*\"},\n                                  {\"accept-encoding\", \"gzip, deflate\"}};\n\n        /*request body table*/\n        nlohmann::json body = {\n            {\"app\", 0},\n            {\"os\", 1},\n            {\"qimeiParams\",\n             {\n                 {\"key\", key},\n                 {\"params\", params},\n                 {\"time\", ts_s},\n                 {\"nonce\", nonce},\n                 {\"sign\", sign},\n                 {\"extra\", extra},\n             }},\n        };\n\n        boost::urls::url url(QIMEI_ENTRY);\n        http::request&lt;http::string_body&gt; req{http::verb::post, url, 11};\n        for (auto&amp; i : headers.items()) {\n            req.set(i.key(), i.value());\n        }\n\n        req.body() = body.dump();\n        req.prepare_payload();\n\n        boost::asio::io_context ioc;\n        tcp_stream tcps(ioc);\n        auto resolver = boost::asio::ip::tcp::resolver(ioc);\n        tcps.connect(resolver.resolve(url.host(), \"http\"));\n\n        http::write(tcps, req);\n        flat_buffer fb;\n        http::response&lt;http::dynamic_body&gt; res;\n        http::read(tcps, fb, res);\n\n        /*raw_json_res[\"data\"] is string*/\n        auto qimei_res = nlohmann::json::parse(\n            std::string(nlohmann::json::parse(buffers_to_string(res.body().data()))[\"data\"]));\n\n        if (qimei_res[\"code\"] != 0) {\n            /*get qimei failure*/\n            return Ok(qqmusic::utils::QimeiResult{.q16 = \"\",\n                                                  .q36 = \"6c9d3cd110abca9b16311cee10001e717614\"});\n        } else {\n            /*get qimei success*/\n            return Ok(qqmusic::utils::QimeiResult{.q16 = qimei_res[\"data\"][\"q16\"],\n                                                  .q36 = qimei_res[\"data\"][\"q36\"]});\n        }\n\n    } catch (const std::exception&amp; e) {\n        /*exception, for debug*/\n        // return Err(\n        //     qqmusic::utils::Exception(qqmusic::utils::Exception::UnknownError,\n        //                               std::format(\"[get_qimei] -- Error ocurred: {}\",\n        //                               e.what())));\n        return Ok(\n            qqmusic::utils::QimeiResult{.q16 = \"\", .q36 = \"6c9d3cd110abca9b16311cee10001e717614\"});\n    }\n}\n\n/*rsa encrypt, padding: PKCS1v15*/\nstatic qqmusic::Result&lt;qqmusic::utils::buffer&gt; rsa_encrypt(qqmusic::utils::buffer&amp; buf) {\n    try {\n        /*construct a random number generator*/\n        Botan::AutoSeeded_RNG rng;\n        /*load public key*/\n        auto ds = Botan::DataSource_Memory(PUBLIC_KEY);\n        std::unique_ptr&lt;Botan::Public_Key&gt; pub_key(Botan::X509::load_key(ds));\n\n        /*construct an encryptor*/\n        Botan::PK_Encryptor_EME enc(*pub_key, rng, \"PKCS1v15\");\n\n        /*encrypt data*/\n        auto res = enc.encrypt(buf.data(), buf.size(), rng);\n        return Ok(qqmusic::utils::buffer(res.data(), res.size()));\n    } catch (const std::exception&amp; e) {\n        /*encrypt failed*/\n        return Err(qqmusic::utils::Exception(qqmusic::utils::Exception::DataDestroy,\n                                             std::format(\"[rsa_encrypt] -- encrypt failed: {}\",\n                                                         e.what())));\n    }\n}\n\n/*aes encrypt*/\nstatic qqmusic::Result&lt;qqmusic::utils::buffer&gt; aes_encrypt(qqmusic::utils::buffer&amp; key,\n                                                           qqmusic::utils::buffer&amp; buf) {\n    try {\n        /*construct a random number generator*/\n        Botan::AutoSeeded_RNG rng;\n\n        /*calculate padding size*/\n        size_t padding_size = 16 - (buf.size()) % 16;\n\n        /*prepare cipher encryptor*/\n        std::unique_ptr&lt;Botan::Cipher_Mode&gt; enc\n            = Botan::Cipher_Mode::create(\"AES-128/CBC\", Botan::Cipher_Dir::Encryption);\n        if (!enc) {\n            return Err(qqmusic::utils::Exception(qqmusic::utils::Exception::DataDestroy,\n                                                 \"[aes_encrypt] -- cipher mode create failure...\"));\n        }\n        enc-&gt;set_key(key.data(), key.size());\n\n        /*use padding_size as char to pad after buffer*/\n        qqmusic::utils::buffer padding(padding_size, (char) ('\\0' + padding_size));\n        buf.insert(buf.end(), padding.begin(), padding.end());\n        enc-&gt;start(key);\n        enc-&gt;update(buf);\n        enc-&gt;finish(key);\n\n        return Ok(buf);\n    } catch (const std::exception&amp; e) {\n        return Err(\n            qqmusic::utils::Exception(qqmusic::utils::Exception::DataDestroy,\n                                      std::format(\"[aes_encrypt] -- error ocurred: {}\", e.what())));\n    }\n}\n\nstatic nlohmann::json load_rand_payload(qqmusic::utils::Device&amp; device, std::string_view version) {\n    Botan::AutoSeeded_RNG rng;\n    /*generate an uint64_t range(0, 14400)*/\n    auto fixed_rand = [&amp;rng]() {\n        uint64_t res = 0;\n        std::vector&lt;uint8_t&gt; buffer(sizeof(res));\n        rng.randomize(buffer);\n        memcpy(&amp;res, buffer.data(), sizeof(res));\n        return res;\n    }() % 14400;\n\n    std::chrono::time_point&lt;std::chrono::system_clock&gt; tp(std::chrono::system_clock::now());\n    /*add random offset*/\n    tp -= std::chrono::duration(std::chrono::seconds(fixed_rand));\n    /*zoned time with random offset*/\n#ifdef PLATFORM_APPLE\n    auto now = std::chrono::system_clock::now();\n    auto now_time_t = std::chrono::system_clock::to_time_t(now);\n    std::tm local_tm{};\n    localtime_r(&amp;now_time_t, &amp;local_tm);\n    auto duration = now.time_since_epoch();\n    auto millis = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(duration).count() % 1000;\n    std::string uptimes = std::format(\"{:04}-{:02}-{:02} {:02}:{:02}:{:02}.{:03}\",\n                                      local_tm.tm_year + 1900,\n                                      local_tm.tm_mon + 1,\n                                      local_tm.tm_mday,\n                                      local_tm.tm_hour,\n                                      local_tm.tm_min,\n                                      local_tm.tm_sec,\n                                      millis);\n#else\n    auto zoned_time = std::chrono::zoned_time{std::chrono::current_zone(), tp};\n    std::string uptimes = std::format(\"{0:%F} {0:%H}:{0:%M}:{0:%OS}\", zoned_time);\n#endif\n\n    nlohmann::json reserved = {{\"harmony\", \"0\"},\n                               {\"clone\", \"0\"},\n                               {\"containe\", \"\"},\n                               {\"oz\", \"UhYmelwouA+V2nPWbOvLTgN2/m8jwGB+yUB5v9tysQg=\"},\n                               {\"oo\", \"Xecjt+9S1+f8Pz2VLSxgpw==\"},\n                               {\"kelong\", \"0\"},\n                               {\"uptimes\", uptimes},\n                               {\"multiUser\", \"0\"},\n                               {\"bod\", device.brand},\n                               {\"dv\", device.device},\n                               {\"firstLevel\", \"\"},\n                               {\"manufact\", device.brand},\n                               {\"name\", device.model},\n                               {\"host\", \"se.infra\"},\n                               {\"kernel\", device.proc_version}};\n    return nlohmann::json{\n        {\"androidId\", device.android_id},\n        {\"platformId\", 1},\n        {\"appKey\", APP_KEY},\n        {\"appVersion\", version},\n        {\"beaconIdSrc\", random_beacon_id()},\n        {\"brand\", device.brand},\n        {\"channelId\", \"10003505\"},\n        {\"cid\", \"\"},\n        {\"imei\", device.imei},\n        {\"imsi\", \"\"},\n        {\"mac\", \"\"},\n        {\"model\", device.model},\n        {\"networkType\", \"unknown\"},\n        {\"oaid\", \"\"},\n        {\"osVersion\",\n         std::format(\"Android {},level {}\", device.version.release, device.version.sdk)},\n        {\"qimei\", \"\"},\n        {\"qimei36\", \"\"},\n        {\"sdkVersion\", \"1.2.13.6\"},\n        {\"targetSdkVersion\", \"33\"},\n        {\"audit\", \"\"},\n        {\"userId\", \"{}\"},\n        {\"packageId\", \"com.tencent.qqmusic\"},\n        {\"deviceType\", \"Phone\"},\n        {\"sdkName\", \"\"},\n        {\"reserved\", nlohmann::to_string(reserved)},\n    };\n};\n\nstatic std::string random_beacon_id() {\n    std::ostringstream beacon_id;\n    const static std::set&lt;int&gt; numtable\n        = {1, 2, 13, 14, 17, 18, 21, 22, 25, 26, 29, 30, 33, 34, 37, 38};\n\n    auto now = std::chrono::system_clock::now();\n    auto time_t_now = std::chrono::system_clock::to_time_t(now);\n    std::tm tm_now{};\n    /*use a thread safe function*/\n    localtime_r(&amp;time_t_now, &amp;tm_now);\n\n    std::ostringstream time_month;\n    time_month &lt;&lt; std::put_time(&amp;tm_now, \"%Y-%m-\") &lt;&lt; \"01\";\n\n    Botan::AutoSeeded_RNG rng;\n\n    /*random unsigned long long generator*/\n    auto randull = [&amp;rng]() -&gt; uint64_t {\n        uint64_t res = 0;\n        std::vector&lt;uint8_t&gt; buffer(sizeof(res));\n        rng.randomize(buffer);\n        memcpy(&amp;res, buffer.data(), sizeof(res));\n        return res;\n    };\n\n    auto rand1 = randull() % 899999 + 100000;\n    auto rand2 = randull() % 899999999 + 100000000;\n\n    for (int i = 1; i &lt;= 40; ++i) {\n        if (numtable.contains(i)) {\n            beacon_id &lt;&lt; \"k\" &lt;&lt; i &lt;&lt; \":\" &lt;&lt; time_month.str() &lt;&lt; rand1 &lt;&lt; \".\" &lt;&lt; rand2;\n        } else if (i == 3) {\n            beacon_id &lt;&lt; \"k3:0000000000000000\";\n        } else if (i == 4) {\n            beacon_id &lt;&lt; \"k4:\";\n            for (int j = 0; j &lt; 16; ++j) {\n                const char hex_chars[] = \"123456789abcdef\";\n                beacon_id &lt;&lt; hex_chars[randull() % 16];\n            }\n        } else {\n            beacon_id &lt;&lt; \"k\" &lt;&lt; i &lt;&lt; \":\" &lt;&lt; randull() % 10000;\n        }\n        beacon_id &lt;&lt; \";\";\n    }\n\n    return beacon_id.str();\n}\n</code></pre>"},{"location":"dictionary/session_8cc/","title":"File session.cc","text":"<p>FileList &gt; src &gt; utils &gt; session.cc</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/asio/use_awaitable.hpp&gt;</code></li> <li><code>#include &lt;boost/beast.hpp&gt;</code></li> <li><code>#include &lt;boost/beast/core/buffers_to_string.hpp&gt;</code></li> <li><code>#include &lt;boost/beast/core/stream_traits.hpp&gt;</code></li> <li><code>#include &lt;boost/beast/http/message.hpp&gt;</code></li> <li><code>#include &lt;boost/beast/ssl.hpp&gt;</code></li> <li><code>#include &lt;boost/url.hpp&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;qqmusic/result.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/cookie.h&gt;</code></li> <li><code>#include &lt;qqmusic/utils/session.h&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"dictionary/session_8cc/#namespaces","title":"Namespaces","text":"Type Name namespace qqmusic namespace utils \u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027"},{"location":"dictionary/session_8cc/#public-static-functions","title":"Public Static Functions","text":"Type Name qqmusic::Task&lt; qqmusic::Result&lt; qqmusic::utils::HttpResponse &gt; &gt; handle_http_redirecting (qqmusic::utils::Session &amp; self, boost::url_view url, boost::beast::http::request&lt; boost::beast::http::string_body &gt; &amp; req, qqmusic::utils::HttpResponse &amp; resp)  qqmusic::Task&lt; qqmusic::Result&lt; qqmusic::utils::HttpResponse &gt; &gt; handle_https_redirecting (qqmusic::utils::Session &amp; self, boost::url_view url, boost::beast::http::request&lt; boost::beast::http::string_body &gt; &amp; req, qqmusic::utils::HttpResponse &amp; resp, std::shared_ptr&lt; boost::asio::ssl::context &gt; ssl_ctx)"},{"location":"dictionary/session_8cc/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"dictionary/session_8cc/#function-handle_http_redirecting","title":"function handle_http_redirecting","text":"<pre><code>static qqmusic::Task&lt; qqmusic::Result&lt; qqmusic::utils::HttpResponse &gt; &gt; handle_http_redirecting (\n    qqmusic::utils::Session &amp; self,\n    boost::url_view url,\n    boost::beast::http::request&lt; boost::beast::http::string_body &gt; &amp; req,\n    qqmusic::utils::HttpResponse &amp; resp\n) \n</code></pre>"},{"location":"dictionary/session_8cc/#function-handle_https_redirecting","title":"function handle_https_redirecting","text":"<pre><code>static qqmusic::Task&lt; qqmusic::Result&lt; qqmusic::utils::HttpResponse &gt; &gt; handle_https_redirecting (\n    qqmusic::utils::Session &amp; self,\n    boost::url_view url,\n    boost::beast::http::request&lt; boost::beast::http::string_body &gt; &amp; req,\n    qqmusic::utils::HttpResponse &amp; resp,\n    std::shared_ptr&lt; boost::asio::ssl::context &gt; ssl_ctx\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/utils/session.cc</code></p>"},{"location":"dictionary/session_8cc_source/","title":"File session.cc","text":"<p>File List &gt; src &gt; utils &gt; session.cc</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;boost/asio/use_awaitable.hpp&gt;\n#include &lt;boost/beast.hpp&gt;\n#include &lt;boost/beast/core/buffers_to_string.hpp&gt;\n#include &lt;boost/beast/core/stream_traits.hpp&gt;\n#include &lt;boost/beast/http/message.hpp&gt;\n#include &lt;boost/beast/ssl.hpp&gt;\n#include &lt;boost/url.hpp&gt;\n#include &lt;memory&gt;\n#include &lt;mutex&gt;\n#include &lt;qqmusic/result.h&gt;\n#include &lt;qqmusic/utils/cookie.h&gt;\n#include &lt;qqmusic/utils/session.h&gt;\n#include &lt;utility&gt;\n\nstatic qqmusic::Task&lt;qqmusic::Result&lt;qqmusic::utils::HttpResponse&gt;&gt; handle_http_redirecting(\n    qqmusic::utils::Session&amp; self,\n    boost::url_view url,\n    boost::beast::http::request&lt;boost::beast::http::string_body&gt;&amp; req,\n    qqmusic::utils::HttpResponse&amp; resp);\n\nstatic qqmusic::Task&lt;qqmusic::Result&lt;qqmusic::utils::HttpResponse&gt;&gt; handle_https_redirecting(\n    qqmusic::utils::Session&amp; self,\n    boost::url_view url,\n    boost::beast::http::request&lt;boost::beast::http::string_body&gt;&amp; req,\n    qqmusic::utils::HttpResponse&amp; resp,\n    std::shared_ptr&lt;boost::asio::ssl::context&gt; ssl_ctx);\n\nnamespace qqmusic::utils {\n\nSessionManager::SessionManager()\n    : ctx(qqmusic::details::NetworkContext())\n    , ioc(std::make_shared&lt;asio::io_context&gt;())\n    , ssl_ctx(std::make_shared&lt;asio::ssl::context&gt;(asio::ssl::context::tlsv12_client)) {\n    ssl_ctx-&gt;set_default_verify_paths();\n}\n\nSessionManager&amp; SessionManager::get_instance() {\n    static std::unique_ptr&lt;SessionManager&gt; instance;\n    static std::once_flag flag;\n    std::call_once(flag, []() { instance.reset(new SessionManager()); });\n    return *instance;\n}\n\nSession SessionManager::get_session() {\n    return {ctx, ioc, ssl_ctx, lock};\n}\n\nvoid SessionManager::set_context(const qqmusic::details::NetworkContext&amp; context) {\n    std::lock_guard&lt;std::mutex&gt; lg(lock);\n    ctx = context;\n}\n\nvoid SessionManager::push_context(qqmusic::details::NetworkContext&amp;&amp; context) {\n    std::lock_guard&lt;std::mutex&gt; lg(lock);\n    context_stack.push(std::move(ctx));\n    ctx = std::move(context);\n}\n\nvoid SessionManager::pop_context() {\n    std::lock_guard&lt;std::mutex&gt; lg(lock);\n    ctx = std::move(context_stack.top());\n    context_stack.pop();\n}\n\nqqmusic::details::NetworkContext&amp; Session::get_context_ref() {\n    return local_ctx;\n}\n\nvoid Session::sync_global() {\n    std::lock_guard&lt;std::mutex&gt; lg(lock);\n    global_ctx = local_ctx;\n}\n\nvoid Session::update_local() {\n    std::lock_guard&lt;std::mutex&gt; lg(lock);\n    local_ctx = global_ctx;\n}\n\nqqmusic::Task&lt;qqmusic::Result&lt;HttpResponse&gt;&gt; Session::perform_request(\n    boost::url_view url, http::request&lt;http::string_body&gt;&amp; req, bool auto_redirecting) {\n    namespace beast = boost::beast;\n    namespace asio = boost::asio;\n\n    if (url.scheme() == \"http\") {\n        /*handle http requests*/\n        auto res = co_await handle_http_request(url, req, auto_redirecting);\n        if (res.isOk()) {\n            co_return Ok(res.unwrap());\n        } else {\n            co_return Err(res.unwrapErr());\n        }\n    } else if (url.scheme() == \"https\") {\n        /*handle https requests*/\n        auto res = co_await handle_https_request(url, req, auto_redirecting);\n        if (res.isOk()) {\n            co_return Ok(res.unwrap());\n        } else {\n            co_return Err(res.unwrapErr());\n        }\n    } else {\n        co_return Err(\n            Exception(Exception::NetworkError,\n                      std::format(\"[Session::perform_request] -- Invalid url scheme: `{}`\",\n                                  std::string(url.scheme()))));\n    }\n}\n\nqqmusic::Task&lt;qqmusic::Result&lt;HttpResponse&gt;&gt; Session::handle_http_request(\n    boost::url_view url, http::request&lt;http::string_body&gt;&amp; req, bool auto_redirecting) {\n    namespace beast = boost::beast;\n    namespace asio = boost::asio;\n\n    beast::tcp_stream tcps{asio::use_awaitable_t&lt;asio::any_io_executor&gt;::as_default_on(\n        beast::tcp_stream(co_await asio::this_coro::executor))};\n\n    auto resolver = asio::use_awaitable_t&lt;asio::any_io_executor&gt;::as_default_on(\n        asio::ip::tcp::resolver(co_await asio::this_coro::executor));\n    auto resolv_res = co_await resolver.async_resolve(url.host(), \"http\");\n\n    beast::get_lowest_layer(tcps).expires_after(local_ctx.timeout);\n\n    try {\n        /*Connect to endpoint*/\n        co_await boost::beast::get_lowest_layer(tcps).async_connect(resolv_res);\n    } catch (const boost::system::system_error&amp; e) {\n        if (e.code() == boost::asio::error::timed_out) {\n            co_return qqmusic::utils::Exception(\n                qqmusic::utils::Exception::OperationOutOfTime,\n                std::format(\"[perform_request] -- connecting to host `{}` out of time\", url.host()));\n        }\n        co_return Err(qqmusic::utils::Exception(\n            qqmusic::utils::Exception::NetworkError,\n            std::format(\"[perform_request] -- connecting to host `{}` failed, reason: `{}`\",\n                        url.host(),\n                        e.what())));\n    }\n\n    req.prepare_payload();\n\n    try {\n        /*Send the request*/\n        co_await beast::http::async_write(tcps, req);\n    } catch (const boost::system::system_error&amp; e) {\n        if (e.code() == boost::asio::error::timed_out) {\n            co_return qqmusic::utils::Exception(\n                qqmusic::utils::Exception::OperationOutOfTime,\n                std::format(\"[perform_request] -- connecting to host `{}` out of time\", url.host()));\n        }\n        co_return Err(qqmusic::utils::Exception(\n            qqmusic::utils::Exception::NetworkError,\n            std::format(\"[perform_request] -- connecting to host `{}` failed, reason: `{}`\",\n                        url.host(),\n                        e.what())));\n    }\n\n    http::response&lt;http::dynamic_body&gt; res;\n    boost::beast::flat_buffer buffer;\n    try {\n        /*Receive HTTP response*/\n        co_await http::async_read(tcps, buffer, res);\n    } catch (const boost::system::system_error&amp; e) {\n        if (e.code() == boost::asio::error::timed_out) {\n            co_return Err(qqmusic::utils::Exception(qqmusic::utils::Exception::OperationOutOfTime,\n                                                    \"Read operation timed out\"));\n        }\n        co_return Err(\n            qqmusic::utils::Exception(qqmusic::utils::Exception::NetworkError,\n                                      std::format(\"[perform_request] -- Read operation error: `{}`\",\n                                                  e.what())));\n    }\n\n    /*Shutdown the connection*/\n    boost::system::error_code ec = tcps.socket()\n                                       .shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n    if (!ec || ec == asio::error::eof || ec == boost::beast::error::timeout) {\n        /*here we got the request performed successfully*/\n        if (res.base().find(http::field::set_cookie) != res.base().end()) {\n            /*set cookie*/\n            CookieJar cookie_new;\n            std::ostringstream oss;\n            for (auto&amp; field : res.base()) {\n                if (field.name() == http::field::set_cookie) {\n                    auto cookie_res = parse_cookie(field.value());\n                    if (cookie_res.isErr()) {\n                        co_return Err(Exception(\n                            Exception::JsonError,\n                            std::format(\"[Session::perform_request] -- Cookie parse error: `{}`\",\n                                        cookie_res.unwrapErr().what())));\n                    }\n                    auto cookie_dict = cookie_res.unwrap();\n                    std::string domain, path = \"/\";\n                    if (cookie_dict.contains(\"Domain\")) {\n                        domain = cookie_dict[\"Domain\"].get&lt;std::string&gt;();\n                        cookie_dict.erase(\"Domain\");\n                    }\n                    if (cookie_dict.contains(\"Path\")) {\n                        path = cookie_dict[\"Path\"].get&lt;std::string&gt;();\n                        cookie_dict.erase(\"Path\");\n                    }\n                    for (auto&amp; i : cookie_dict.items()) {\n                        cookie_new.set({\n                            .domain = domain,\n                            .path = path,\n                            .key = i.key(),\n                            .value = i.value().get&lt;std::string&gt;(),\n                        });\n                    }\n                }\n            }\n            local_ctx.cookies.merge(cookie_new);\n            /*write the change back to global context*/\n            sync_global();\n        }\n\n        if (auto_redirecting\n            &amp;&amp; (res.result() == http::status::found\n                || res.result() == http::status::moved_permanently\n                || res.result() == http::status::permanent_redirect)) {\n            /*handle redirecting*/\n\n            auto final_res = co_await handle_http_redirecting(*this, url, req, res);\n            if (final_res.isErr()) {\n                co_return Err(Exception(final_res.unwrapErr()));\n            }\n            co_return Ok(final_res.unwrap());\n        }\n\n        co_return Ok(res);\n    }\n\n    co_return Err(\n        qqmusic::utils::Exception(qqmusic::utils::Exception::UnknownError,\n                                  std::format(\"[perform_request] -- Unknown error ocurred: `{}`\",\n                                              ec.message())));\n}\n\nqqmusic::Task&lt;qqmusic::Result&lt;HttpResponse&gt;&gt; Session::handle_https_request(\n    boost::url_view url, http::request&lt;http::string_body&gt;&amp; req, bool auto_redirecting) {\n    using executor_with_default\n        = asio::use_awaitable_t&lt;&gt;::executor_with_default&lt;asio::any_io_executor&gt;;\n    using tcp_stream =\n        typename boost::beast::tcp_stream::rebind_executor&lt;executor_with_default&gt;::other;\n    using tcp = boost::asio::ip::tcp;\n\n    auto resolver = asio::use_awaitable_t&lt;boost::asio::any_io_executor&gt;::as_default_on(\n        tcp::resolver(co_await asio::this_coro::executor));\n\n    // We construct the ssl stream from the already rebound tcp_stream.\n    boost::beast::ssl_stream&lt;tcp_stream&gt;\n        stream{boost::asio::use_awaitable_t&lt;boost::asio::any_io_executor&gt;::as_default_on(\n                   boost::beast::tcp_stream(co_await asio::this_coro::executor)),\n               *ssl_ctx};\n\n    // Set SNI Hostname (many hosts need this to handshake successfully)\n    if (!SSL_set_tlsext_host_name(stream.native_handle(), url.host().c_str()))\n        throw boost::system::system_error(static_cast&lt;int&gt;(::ERR_get_error()),\n                                          asio::error::get_ssl_category());\n\n    // Look up the domain name\n    auto const results = co_await resolver.async_resolve(url.host(), \"https\");\n\n    // Set the timeout.\n    boost::beast::get_lowest_layer(stream).expires_after(local_ctx.timeout);\n\n    // Make the connection on the IP address we get from a lookup\n    try {\n        co_await boost::beast::get_lowest_layer(stream).async_connect(results);\n    } catch (const boost::system::system_error&amp; e) {\n        if (e.code() == asio::error::timed_out) {\n            co_return Err(Exception(Exception::OperationOutOfTime,\n                                    \"[Session::handle_https_request] -- Connection timed out\"));\n        }\n        co_return Err(Exception(\n            Exception::NetworkError,\n            std::format(\"[Session::handle_https_request] -- Error occurred when connecting: `{}`\",\n                        e.what())));\n    }\n\n    // Set the timeout.\n    boost::beast::get_lowest_layer(stream).expires_after(local_ctx.timeout);\n\n    // Perform the SSL handshake\n    try {\n        co_await stream.async_handshake(asio::ssl::stream_base::client);\n    } catch (const boost::system::system_error&amp; e) {\n        co_return Err(Exception(Exception::SslError,\n                                std::format(\"[Session::handle_https_request] -- Error occurred \"\n                                            \"when performing ssl handshake: `{}`\",\n                                            e.what())));\n    }\n\n    req.prepare_payload();\n\n    // Set the timeout\n    boost::beast::get_lowest_layer(stream).expires_after(local_ctx.timeout);\n\n    // Send the HTTP request to the remote host\n    try {\n        co_await http::async_write(stream, req);\n    } catch (const boost::system::system_error&amp; e) {\n        if (e.code() == asio::error::timed_out) {\n            co_return Err(\n                Exception(Exception::OperationOutOfTime,\n                          \"[Session::handle_https_request] -- Write operation timed out\"));\n        }\n        co_return Err(Exception(Exception::NetworkError,\n                                std::format(\"[Session::handle_https_request] -- Error occurred \"\n                                            \"when doing writing operation: `{}`\",\n                                            e.what())));\n    }\n\n    // Declare a container to hold the response\n    http::response&lt;http::dynamic_body&gt; res;\n\n    boost::beast::flat_buffer buffer;\n\n    // Receive the HTTP response\n    try {\n        co_await http::async_read(stream, buffer, res);\n    } catch (const boost::system::system_error&amp; e) {\n        if (e.code() == asio::error::timed_out) {\n            co_return Err(Exception(Exception::OperationOutOfTime,\n                                    \"[Session::handle_https_request] -- Read operation timed out\"));\n        }\n        co_return Err(Exception(Exception::NetworkError,\n                                std::format(\"[Session::handle_https_request] -- Error occurred \"\n                                            \"when doing reading operation: `{}`\",\n                                            e.what())));\n    }\n\n    boost::beast::get_lowest_layer(stream).expires_after(local_ctx.timeout);\n\n    // Gracefully close the stream - do not threat every error as an exception!\n    auto [ec] = co_await stream.async_shutdown(asio::as_tuple(asio::use_awaitable));\n    if (!ec || ec == asio::error::eof\n        || (local_ctx.ignore_ssl_error &amp;&amp; ec == asio::ssl::error::stream_truncated)\n        || ec == boost::beast::error::timeout || ec == boost::asio::ssl::error::stream_truncated) {\n        /*here we got the request performed successfully*/\n        if (res.base().find(http::field::set_cookie) != res.base().end()) {\n            /*set cookie*/\n            CookieJar cookie_new;\n            std::ostringstream oss;\n            for (auto&amp; field : res.base()) {\n                if (field.name() == http::field::set_cookie) {\n                    auto cookie_res = parse_cookie(field.value());\n                    if (cookie_res.isErr()) {\n                        co_return Err(Exception(\n                            Exception::JsonError,\n                            std::format(\"[Session::perform_request] -- Cookie parse error: `{}`\",\n                                        cookie_res.unwrapErr().what())));\n                    }\n                    auto cookie_dict = cookie_res.unwrap();\n                    std::string domain, path = \"/\";\n                    if (cookie_dict.contains(\"Domain\")) {\n                        domain = cookie_dict[\"Domain\"].get&lt;std::string&gt;();\n                        cookie_dict.erase(\"Domain\");\n                    }\n                    if (cookie_dict.contains(\"Path\")) {\n                        path = cookie_dict[\"Path\"].get&lt;std::string&gt;();\n                        cookie_dict.erase(\"Path\");\n                    }\n                    for (auto&amp; i : cookie_dict.items()) {\n                        cookie_new.set({\n                            .domain = domain,\n                            .path = path,\n                            .key = i.key(),\n                            .value = i.value().get&lt;std::string&gt;(),\n                        });\n                    }\n                }\n            }\n            local_ctx.cookies.merge(cookie_new);\n            /*write the change back to global context*/\n            sync_global();\n        }\n\n        if (auto_redirecting\n            &amp;&amp; (res.result() == http::status::found\n                || res.result() == http::status::moved_permanently\n                || res.result() == http::status::permanent_redirect)) {\n            /*handle redirecting*/\n            auto final_res = co_await handle_https_redirecting(*this, url, req, res, ssl_ctx);\n            if (final_res.isErr()) {\n                co_return Err(Exception(final_res.unwrapErr()));\n            }\n            co_return Ok(final_res.unwrap());\n        }\n\n        co_return Ok(res);\n    }\n\n    co_return Err(\n        Exception(Exception::UnknownError,\n                  std::format(\"[Session::handle_https_request] -- Error occurred in the end: `{}`\",\n                              ec.message())));\n}\n\n} // namespace qqmusic::utils\n\nstatic qqmusic::Task&lt;qqmusic::Result&lt;qqmusic::utils::HttpResponse&gt;&gt; handle_http_redirecting(\n    qqmusic::utils::Session&amp; self,\n    boost::url_view url,\n    boost::beast::http::request&lt;boost::beast::http::string_body&gt;&amp; req,\n    qqmusic::utils::HttpResponse&amp; resp) {\n    using namespace qqmusic::utils;\n    const unsigned int REDIRECT_MAX_COUNT = 100;\n    unsigned int count = 0;\n    try {\n        boost::beast::tcp_stream tcps{asio::use_awaitable_t&lt;asio::any_io_executor&gt;::as_default_on(\n            boost::beast::tcp_stream(co_await asio::this_coro::executor))};\n        auto resolver = asio::use_awaitable_t&lt;asio::any_io_executor&gt;::as_default_on(\n            asio::ip::tcp::resolver(co_await asio::this_coro::executor));\n        auto&amp; local_context = self.get_context_ref();\n        /*filter location*/\n        auto location = resp.base().find(http::field::location)-&gt;value();\n\n        auto prepare_verb = [](http::request&lt;http::string_body&gt;&amp; req_old,\n                               HttpResponse&amp; resp_old) -&gt; http::verb {\n            http::verb verb = req_old.method();\n            if (resp_old.result() == http::status::see_other &amp;&amp; verb != http::verb::head) {\n                verb = http::verb::get;\n            }\n            if (resp_old.result() == http::status::found &amp;&amp; verb != http::verb::head) {\n                verb = http::verb::get;\n            }\n            if (resp_old.result() == http::status::moved_permanently &amp;&amp; verb == http::verb::post) {\n                verb = http::verb::get;\n            }\n            return verb;\n        };\n\n        auto prepare_url = [](boost::url_view old, std::string_view location) -&gt; boost::url {\n            boost::url url_new{location};\n            /*if a url has no scheme and host, it is a relative url*/\n            if (!url_new.has_scheme() &amp;&amp; url_new.host().empty()) {\n                url_new.set_host(old.host());\n            }\n            /*if url is not absolute*/\n            if (!url_new.is_path_absolute()) {\n                url_new.resolve(old);\n            }\n            /*add fragment*/\n            if (old.has_fragment() &amp;&amp; !url_new.has_fragment()) {\n                url_new.set_fragment(old.fragment());\n            }\n            return url_new;\n        };\n\n        auto prepare_header = [](boost::url_view url_new,\n                                 http::request&lt;http::string_body&gt;&amp; old,\n                                 http::request&lt;http::string_body&gt;&amp; req_new) {\n            req_new.set(http::field::host, url_new.host());\n            for (auto&amp; i : old.base()) {\n                if (i.name_string() != \"Authorization\" || i.name_string() != \"Content-Length\"\n                    || i.name_string() != \"Cookie\" || i.name_string() != \"Host\") {\n                    req_new.set(i.name(), i.value());\n                }\n            }\n        };\n\n        boost::url url_next = prepare_url(url, location);\n        http::request&lt;http::string_body&gt; req_next{prepare_verb(req, resp), url_next, 11};\n        prepare_header(url_next, req, req_next);\n        auto path = url_next.path();\n        if (path.size() != 0) {\n            auto cookie_res = local_context.cookies.serialize(url_next.host(), path);\n            if (cookie_res.isOk()) {\n                req_next.set(http::field::cookie, cookie_res.unwrap());\n            }\n        } else {\n            auto cookie_res = local_context.cookies.serialize(url_next.host());\n            if (cookie_res.isOk()) {\n                req_next.set(http::field::cookie, cookie_res.unwrap());\n            }\n        }\n\n        while (count &lt; REDIRECT_MAX_COUNT) {\n            /*redirecting*/\n            qqmusic::utils::HttpResponse res;\n\n            /*send request*/\n            auto resolv_res = co_await resolver.async_resolve(url_next.host(), \"http\");\n            boost::beast::get_lowest_layer(tcps).expires_after(local_context.timeout);\n            try {\n                /*Connect to endpoint*/\n                co_await boost::beast::get_lowest_layer(tcps).async_connect(resolv_res);\n            } catch (const boost::system::system_error&amp; e) {\n                if (e.code() == boost::asio::error::timed_out) {\n                    co_return qqmusic::utils::Exception(\n                        qqmusic::utils::Exception::OperationOutOfTime,\n                        std::format(\n                            \"[handle_http_redirecting] -- connecting to host `{}` out of time\",\n                            url.host()));\n                }\n                co_return Err(\n                    qqmusic::utils::Exception(qqmusic::utils::Exception::NetworkError,\n                                              std::format(\"[handle_http_redirecting] -- connecting \"\n                                                          \"to host `{}` failed, reason: `{}`\",\n                                                          url.host(),\n                                                          e.what())));\n            }\n\n            req_next.prepare_payload();\n\n            try {\n                /*Send the request*/\n                co_await boost::beast::http::async_write(tcps, req);\n            } catch (const boost::system::system_error&amp; e) {\n                if (e.code() == boost::asio::error::timed_out) {\n                    co_return qqmusic::utils::Exception(\n                        qqmusic::utils::Exception::OperationOutOfTime,\n                        std::format(\n                            \"[handle_http_redirecting] -- connecting to host `{}` out of time\",\n                            url.host()));\n                }\n                co_return Err(qqmusic::utils::Exception(\n                    qqmusic::utils::Exception::NetworkError,\n                    std::format(\"[handle_http_redirecting] -- connecting to \"\n                                \"host `{}` failed, reason: `{}`\",\n                                url.host(),\n                                e.what())));\n            }\n\n            boost::beast::flat_buffer buffer;\n            try {\n                /*Receive HTTP response*/\n                co_await http::async_read(tcps, buffer, res);\n            } catch (const boost::system::system_error&amp; e) {\n                if (e.code() == boost::asio::error::timed_out) {\n                    co_return Err(\n                        qqmusic::utils::Exception(qqmusic::utils::Exception::OperationOutOfTime,\n                                                  \"Read operation timed out\"));\n                }\n                co_return Err(qqmusic::utils::Exception(\n                    qqmusic::utils::Exception::NetworkError,\n                    std::format(\"[handle_http_redirecting] -- Read operation error: `{}`\",\n                                e.what())));\n            }\n\n            /*Shutdown the connection*/\n            boost::system::error_code ec\n                = tcps.socket().shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n            if (!ec || ec == asio::error::eof || ec == boost::beast::error::timeout) {\n                if (res.base().find(http::field::set_cookie) != res.base().end()) {\n                    /*set cookie*/\n                    CookieJar cookie_new;\n                    std::ostringstream oss;\n                    for (auto&amp; field : res.base()) {\n                        if (field.name() == http::field::set_cookie) {\n                            auto cookie_res = parse_cookie(field.value());\n                            if (cookie_res.isErr()) {\n                                co_return Err(Exception(Exception::JsonError,\n                                                        std::format(\"[Session::perform_request] -- \"\n                                                                    \"Cookie parse error: `{}`\",\n                                                                    cookie_res.unwrapErr().what())));\n                            }\n                            auto cookie_dict = cookie_res.unwrap();\n                            std::string domain, path = \"/\";\n                            if (cookie_dict.contains(\"Domain\")) {\n                                domain = cookie_dict[\"Domain\"].get&lt;std::string&gt;();\n                                cookie_dict.erase(\"Domain\");\n                            }\n                            if (cookie_dict.contains(\"Path\")) {\n                                path = cookie_dict[\"Path\"].get&lt;std::string&gt;();\n                                cookie_dict.erase(\"Path\");\n                            }\n                            for (auto&amp; i : cookie_dict.items()) {\n                                cookie_new.set({\n                                    .domain = domain,\n                                    .path = path,\n                                    .key = i.key(),\n                                    .value = i.value().get&lt;std::string&gt;(),\n                                });\n                            }\n                        }\n                    }\n                    local_context.cookies.merge(cookie_new);\n                    /*write the change back to global context*/\n                    self.sync_global();\n                }\n\n                if (res.result() == http::status::found\n                    || res.result() == http::status::moved_permanently\n                    || res.result() == http::status::permanent_redirect) {\n                    /*handle redirecting*/\n                    auto url_prev = url_next;\n                    auto req_old = req_next;\n                    location = resp.base().find(http::field::location)-&gt;value();\n                    url_next = prepare_url(url_prev, location);\n                    req_next = http::request&lt;http::string_body&gt;{prepare_verb(req_old, res),\n                                                                url_next,\n                                                                11};\n                    prepare_header(url_next, req_old, req_next);\n                    auto path = url_next.path();\n                    if (path.size() != 0) {\n                        auto cookie_res = local_context.cookies.serialize(url_next.host(), path);\n                        if (cookie_res.isOk()) {\n                            req_next.set(http::field::cookie, cookie_res.unwrap());\n                        }\n                    } else {\n                        auto cookie_res = local_context.cookies.serialize(url_next.host());\n                        if (cookie_res.isOk()) {\n                            req_next.set(http::field::cookie, cookie_res.unwrap());\n                        }\n                    }\n\n                    count++;\n\n                } else {\n                    co_return Ok(res);\n                }\n            }\n        }\n        co_return Err(Exception(Exception::NetworkError,\n                                \"[handle_http_redirecting] -- Redirecting too many times\"));\n    } catch (const std::exception&amp; e) {\n        co_return Err(Exception(Exception::UnknownError,\n                                std::format(\"[handle_http_redirecting] -- Error occurred when \"\n                                            \"handling redirecting: `{}`\",\n                                            e.what())));\n    }\n}\n\nstatic qqmusic::Task&lt;qqmusic::Result&lt;qqmusic::utils::HttpResponse&gt;&gt; handle_https_redirecting(\n    qqmusic::utils::Session&amp; self,\n    boost::url_view url,\n    boost::beast::http::request&lt;boost::beast::http::string_body&gt;&amp; req,\n    qqmusic::utils::HttpResponse&amp; resp,\n    std::shared_ptr&lt;boost::asio::ssl::context&gt; ssl_ctx) {\n    using namespace qqmusic::utils;\n\n    try {\n        using executor_with_default\n            = asio::use_awaitable_t&lt;&gt;::executor_with_default&lt;asio::any_io_executor&gt;;\n        using tcp_stream =\n            typename boost::beast::tcp_stream::rebind_executor&lt;executor_with_default&gt;::other;\n        using tcp = boost::asio::ip::tcp;\n        auto&amp; local_ctx = self.get_context_ref();\n        auto location = resp.base().find(http::field::location)-&gt;value();\n        auto resolver = asio::use_awaitable_t&lt;boost::asio::any_io_executor&gt;::as_default_on(\n            tcp::resolver(co_await asio::this_coro::executor));\n\n        auto prepare_verb = [](http::request&lt;http::string_body&gt;&amp; req_old,\n                               HttpResponse&amp; resp_old) -&gt; http::verb {\n            http::verb verb = req_old.method();\n            if (resp_old.result() == http::status::see_other &amp;&amp; verb != http::verb::head) {\n                verb = http::verb::get;\n            }\n            if (resp_old.result() == http::status::found &amp;&amp; verb != http::verb::head) {\n                verb = http::verb::get;\n            }\n            if (resp_old.result() == http::status::moved_permanently &amp;&amp; verb == http::verb::post) {\n                verb = http::verb::get;\n            }\n            return verb;\n        };\n\n        auto prepare_url = [](boost::url_view old, std::string_view location) -&gt; boost::url {\n            boost::url url_new{location};\n            /*if a url has no scheme and host, it is a relative url*/\n            if (!url_new.has_scheme() &amp;&amp; url_new.host().empty()) {\n                url_new.set_host(old.host());\n            }\n            /*if url is not absolute*/\n            if (!url_new.is_path_absolute()) {\n                url_new.resolve(old);\n            }\n            /*add fragment*/\n            if (old.has_fragment() &amp;&amp; !url_new.has_fragment()) {\n                url_new.set_fragment(old.fragment());\n            }\n            return url_new;\n        };\n\n        auto prepare_header = [](boost::url_view url_new,\n                                 http::request&lt;http::string_body&gt;&amp; old,\n                                 http::request&lt;http::string_body&gt;&amp; req_new) {\n            req_new.set(http::field::host, url_new.host());\n            for (auto&amp; i : old.base()) {\n                if (i.name() != http::field::authorization\n                    &amp;&amp; i.name() != http::field::content_length &amp;&amp; i.name() != http::field::cookie\n                    &amp;&amp; i.name() != http::field::host) {\n                    req_new.set(i.name(), i.value());\n                }\n            }\n        };\n\n        boost::url url_next = prepare_url(url, location);\n        http::request&lt;http::string_body&gt; req_next{prepare_verb(req, resp), url_next, 11};\n        prepare_header(url_next, req, req_next);\n        auto path = url_next.path();\n        if (path.size() != 0) {\n            auto cookie_res = local_ctx.cookies.serialize(url_next.host(), path);\n            if (cookie_res.isOk()) {\n                req_next.set(http::field::cookie, cookie_res.unwrap());\n            }\n        } else {\n            auto cookie_res = local_ctx.cookies.serialize(url_next.host());\n            if (cookie_res.isOk()) {\n                req_next.set(http::field::cookie, cookie_res.unwrap());\n            }\n        }\n\n        unsigned int count = 0;\n        const unsigned int REDIRECT_MAX_COUNT = 100;\n        while (count &lt; REDIRECT_MAX_COUNT) {\n            /*redirecting*/\n            qqmusic::utils::HttpResponse res;\n            boost::beast::flat_buffer buffer;\n\n            // We construct the ssl stream from the already rebound tcp_stream.\n            boost::beast::ssl_stream&lt;tcp_stream&gt;\n                stream{boost::asio::use_awaitable_t&lt;boost::asio::any_io_executor&gt;::as_default_on(\n                           boost::beast::tcp_stream(co_await asio::this_coro::executor)),\n                       *ssl_ctx};\n\n            // Set SNI Hostname (many hosts need this to handshake successfully)\n            if (!SSL_set_tlsext_host_name(stream.native_handle(), url_next.host().c_str()))\n                throw boost::system::system_error(static_cast&lt;int&gt;(::ERR_get_error()),\n                                                  asio::error::get_ssl_category());\n\n            // Look up the domain name\n            auto const results = co_await resolver.async_resolve(url_next.host(), \"https\");\n\n            // Set the timeout.\n            boost::beast::get_lowest_layer(stream).expires_after(local_ctx.timeout);\n\n            // Make the connection on the IP address we get from a lookup\n            try {\n                co_await boost::beast::get_lowest_layer(stream).async_connect(results);\n            } catch (const boost::system::system_error&amp; e) {\n                if (e.code() == asio::error::timed_out) {\n                    co_return Err(Exception(Exception::OperationOutOfTime,\n                                            \"[handle_https_redirecting] -- Connection timed out\"));\n                }\n                co_return Err(Exception(Exception::NetworkError,\n                                        std::format(\"[handle_https_redirecting] -- Error occurred \"\n                                                    \"when connecting: `{}`\",\n                                                    e.what())));\n            }\n\n            // Set the timeout.\n            boost::beast::get_lowest_layer(stream).expires_after(local_ctx.timeout);\n\n            // Perform the SSL handshake\n            try {\n                co_await stream.async_handshake(asio::ssl::stream_base::client);\n            } catch (const boost::system::system_error&amp; e) {\n                co_return Err(Exception(Exception::SslError,\n                                        std::format(\"[handle_https_redirecting] -- Error occurred \"\n                                                    \"when performing ssl handshake: `{}`\",\n                                                    e.what())));\n            }\n\n            req_next.prepare_payload();\n\n            // Set the timeout\n            boost::beast::get_lowest_layer(stream).expires_after(local_ctx.timeout);\n\n            // Send the HTTP request to the remote host\n            try {\n                co_await http::async_write(stream, req_next);\n            } catch (const boost::system::system_error&amp; e) {\n                if (e.code() == asio::error::timed_out) {\n                    co_return Err(\n                        Exception(Exception::OperationOutOfTime,\n                                  \"[handle_https_redirecting] -- Write operation timed out\"));\n                }\n                co_return Err(Exception(Exception::NetworkError,\n                                        std::format(\"[handle_https_redirecting] -- Error occurred \"\n                                                    \"when doing writing operation: `{}`\",\n                                                    e.what())));\n            }\n\n            // Receive the HTTP response\n            try {\n                co_await http::async_read(stream, buffer, res);\n            } catch (const boost::system::system_error&amp; e) {\n                if (e.code() == asio::error::timed_out) {\n                    co_return Err(\n                        Exception(Exception::OperationOutOfTime,\n                                  \"[handle_https_redirecting] -- Read operation timed out\"));\n                }\n                co_return Err(Exception(Exception::NetworkError,\n                                        std::format(\"[handle_https_redirecting] -- Error occurred \"\n                                                    \"when doing reading operation: `{}`\",\n                                                    e.what())));\n            }\n\n            boost::beast::get_lowest_layer(stream).expires_after(local_ctx.timeout);\n\n            // Gracefully close the stream - do not threat every error as an exception!\n            auto [ec] = co_await stream.async_shutdown(asio::as_tuple(asio::use_awaitable));\n            if (!ec || ec == asio::error::eof\n                || (local_ctx.ignore_ssl_error &amp;&amp; ec == asio::ssl::error::stream_truncated)\n                || ec == boost::beast::error::timeout\n                || ec == boost::asio::ssl::error::stream_truncated) {\n                // If we get here then the connection is closed gracefully\n                if (res.base().find(http::field::set_cookie) != res.base().end()) {\n                    /*set cookie*/\n                    CookieJar cookie_new;\n                    std::ostringstream oss;\n                    for (auto&amp; field : res.base()) {\n                        if (field.name() == http::field::set_cookie) {\n                            auto cookie_res = parse_cookie(field.value());\n                            if (cookie_res.isErr()) {\n                                co_return Err(Exception(Exception::JsonError,\n                                                        std::format(\"[Session::perform_request] -- \"\n                                                                    \"Cookie parse error: `{}`\",\n                                                                    cookie_res.unwrapErr().what())));\n                            }\n                            auto cookie_dict = cookie_res.unwrap();\n                            std::string domain, path = \"/\";\n                            if (cookie_dict.contains(\"Domain\")) {\n                                domain = cookie_dict[\"Domain\"].get&lt;std::string&gt;();\n                                cookie_dict.erase(\"Domain\");\n                            }\n                            if (cookie_dict.contains(\"Path\")) {\n                                path = cookie_dict[\"Path\"].get&lt;std::string&gt;();\n                                cookie_dict.erase(\"Path\");\n                            }\n                            for (auto&amp; i : cookie_dict.items()) {\n                                cookie_new.set({\n                                    .domain = domain,\n                                    .path = path,\n                                    .key = i.key(),\n                                    .value = i.value().get&lt;std::string&gt;(),\n                                });\n                            }\n                        }\n                    }\n                    local_ctx.cookies.merge(cookie_new);\n                    /*write the change back to global context*/\n                    self.sync_global();\n                }\n\n                if (res.result() == http::status::found\n                    || res.result() == http::status::moved_permanently\n                    || res.result() == http::status::permanent_redirect) {\n                    /*prepare next request*/\n                    auto url_prev = url_next;\n                    auto req_old = req_next;\n                    location = resp.base().find(http::field::location)-&gt;value();\n                    url_next = prepare_url(url_prev, location);\n                    req_next = http::request&lt;http::string_body&gt;{prepare_verb(req_old, res),\n                                                                url_next,\n                                                                11};\n                    prepare_header(url_next, req_old, req_next);\n                    auto path = url_next.path();\n                    if (path.size() != 0) {\n                        auto cookie_res = local_ctx.cookies.serialize(url_next.host(), path);\n                        if (cookie_res.isOk()) {\n                            req_next.set(http::field::cookie, cookie_res.unwrap());\n                        }\n                    } else {\n                        auto cookie_res = local_ctx.cookies.serialize(url_next.host());\n                        if (cookie_res.isOk()) {\n                            req_next.set(http::field::cookie, cookie_res.unwrap());\n                        }\n                    }\n\n                    count++;\n                } else {\n                    co_return Ok(res);\n                }\n            }\n            co_return Err(Exception(\n                Exception::UnknownError,\n                std::format(\"[handle_https_redirecting] -- Error occurred in the end: `{}`\",\n                            ec.message())));\n        }\n        co_return Err(Exception(Exception::NetworkError,\n                                \"[handle_https_redirecting] -- Redirecting too many times\"));\n    } catch (const std::exception&amp; e) {\n        co_return Err(Exception(Exception::UnknownError,\n                                std::format(\"[handle_https_redirecting] -- Error occurred when \"\n                                            \"handling redirecting: `{}`\",\n                                            e.what())));\n    }\n}\n</code></pre>"},{"location":"dictionary/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace concepts </li> <li>namespace details <ul> <li>namespace And <ul> <li>namespace impl </li> </ul> </li> <li>namespace Or <ul> <li>namespace impl </li> </ul> </li> <li>namespace Other <ul> <li>namespace impl </li> </ul> </li> <li>namespace err <ul> <li>namespace impl </li> </ul> </li> <li>namespace impl </li> <li>namespace ok <ul> <li>namespace impl </li> </ul> </li> </ul> </li> <li>namespace qqmusic <ul> <li>namespace crypto <ul> <li>namespace TeaCipher </li> </ul> </li> <li>namespace details </li> <li>namespace utils \u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027 </li> </ul> </li> <li>namespace std </li> <li>namespace types </li> </ul>"},{"location":"dictionary/classes/","title":"Class Index","text":""},{"location":"dictionary/classes/#a","title":"a","text":"<ul> <li>Api (qqmusic::details)</li> <li>ApiConfig (qqmusic::details)</li> <li>AsyncExecutor (qqmusic::utils)</li> </ul>"},{"location":"dictionary/classes/#b","title":"b","text":"<ul> <li>BaseMediaFileType (qqmusic)</li> <li>buffer (qqmusic::utils)</li> </ul>"},{"location":"dictionary/classes/#c","title":"c","text":"<ul> <li>Cipher (qqmusic::crypto)</li> <li>Constructor (details)</li> <li>Constructor&lt; void, E &gt; (details)</li> <li>Cookie (qqmusic::utils)</li> <li>CookieJar (qqmusic::utils)</li> <li>CoreData</li> <li>CoreData</li> <li>Credential (qqmusic::utils)</li> </ul>"},{"location":"dictionary/classes/#d","title":"d","text":"<ul> <li>Decoder (qqmusic::crypto)</li> <li>Device (qqmusic::utils)</li> </ul>"},{"location":"dictionary/classes/#e","title":"e","text":"<ul> <li>Else (details::Or)</li> <li>Else (details::Or::impl)</li> <li>Else&lt; Result&lt; T, F &gt;(Arg)&gt; (details::Or::impl)</li> <li>Else&lt; Result&lt; T, F &gt;(void)&gt; (details::Or::impl)</li> <li>Else&lt; Ret(*)(Args...)&gt; (details::Or)</li> <li>Else&lt; Ret(*)(Args...)&gt; (details::Or::impl)</li> <li>Else&lt; Ret(Cls::*)(Args...) const &gt; (details::Or)</li> <li>Else&lt; Ret(Cls::*)(Args...) const &gt; (details::Or::impl)</li> <li>Else&lt; Ret(Cls::*)(Args...)&gt; (details::Or)</li> <li>Else&lt; Ret(Cls::*)(Args...)&gt; (details::Or::impl)</li> <li>EncryptedSongFileType (qqmusic)</li> <li>EqualityComparable (concepts)</li> <li>EqualityComparable&lt; T, typename std::enable_if&lt; true, typename details::void_t&lt; decltype(std::declval&lt; T &gt;()==std::declval&lt; T &gt;())&gt;::type &gt;::type &gt; (concepts)</li> <li>Err (types)</li> <li>err_tag (details)</li> <li>Exception (qqmusic::utils)</li> </ul>"},{"location":"dictionary/classes/#i","title":"i","text":"<ul> <li>IsResult (details)</li> <li>IsResult&lt; Result&lt; T, E &gt; &gt; (details)</li> </ul>"},{"location":"dictionary/classes/#k","title":"k","text":"<ul> <li>KeyDerive (qqmusic::crypto)</li> </ul>"},{"location":"dictionary/classes/#l","title":"l","text":"<ul> <li>Lyric (qqmusic)</li> </ul>"},{"location":"dictionary/classes/#m","title":"m","text":"<ul> <li>Map (details::err)</li> <li>Map (details::err::impl)</li> <li>Map (details::ok)</li> <li>Map (details::ok::impl)</li> <li>Map&lt; Result&lt; U, E &gt;(Arg)&gt; (details::ok::impl)</li> <li>Map&lt; Result&lt; U, E &gt;(void)&gt; (details::ok::impl)</li> <li>Map&lt; Ret(*)(Args...)&gt; (details::ok)</li> <li>Map&lt; Ret(Arg)&gt; (details::ok::impl)</li> <li>Map&lt; Ret(Cls::*)(Arg) const &gt; (details::err::impl)</li> <li>Map&lt; Ret(Cls::*)(Arg) const &gt; (details::ok::impl)</li> <li>Map&lt; Ret(Cls::*)(Arg)&gt; (details::ok::impl)</li> <li>Map&lt; Ret(Cls::*)(Args...) const &gt; (details::ok)</li> <li>Map&lt; Ret(Cls::*)(Args...)&gt; (details::ok)</li> <li>Map&lt; Ret(void)&gt; (details::ok::impl)</li> <li>Map&lt; std::function&lt; Ret(Args...)&gt; &gt; (details::ok)</li> <li>Map&lt; void(Arg)&gt; (details::ok::impl)</li> <li>Map&lt; void(void)&gt; (details::ok::impl)</li> <li>MapCipher (qqmusic::crypto)</li> <li>MvUrl (qqmusic)</li> </ul>"},{"location":"dictionary/classes/#n","title":"n","text":"<ul> <li>NetworkContext (qqmusic::details)</li> </ul>"},{"location":"dictionary/classes/#o","title":"o","text":"<ul> <li>Ok (types)</li> <li>Ok&lt; void &gt; (types)</li> <li>ok_tag (details)</li> <li>OSVersion (qqmusic::utils)</li> </ul>"},{"location":"dictionary/classes/#p","title":"p","text":"<ul> <li>PathManager (qqmusic::utils)</li> <li>PhoneLoginEvent</li> <li>PhoneLoginResult (qqmusic)</li> </ul>"},{"location":"dictionary/classes/#q","title":"q","text":"<ul> <li>QimeiResult (qqmusic::utils)</li> <li>QRCode (qqmusic)</li> <li>QRCodeLoginEvent (qqmusic)</li> <li>QRCodeLoginResult (qqmusic)</li> </ul>"},{"location":"dictionary/classes/#r","title":"r","text":"<ul> <li>RC4Cipher (qqmusic::crypto)</li> <li>RequestParam (qqmusic::details)</li> <li>Result</li> <li>result_of (details::impl)</li> <li>result_of (details)</li> <li>result_of&lt; Ret(*)(Args...)&gt; (details)</li> <li>result_of&lt; Ret(Args...)&gt; (details::impl)</li> <li>result_of&lt; Ret(Cls::*)(Args...) const &gt; (details)</li> <li>result_of&lt; Ret(Cls::*)(Args...)&gt; (details::impl)</li> <li>ResultErrType (details)</li> <li>ResultErrType&lt; Result&lt; T, E &gt; &gt; (details)</li> <li>ResultOkType (details)</li> <li>ResultOkType&lt; Result&lt; T, E &gt; &gt; (details)</li> </ul>"},{"location":"dictionary/classes/#s","title":"s","text":"<ul> <li>Session (qqmusic::utils)</li> <li>SessionGuard (qqmusic::utils)</li> <li>SessionManager (qqmusic::utils)</li> <li>SongFileType (qqmusic)</li> <li>SongInfo (qqmusic)</li> <li>Storage (details)</li> <li>Storage&lt; void, E &gt; (details)</li> </ul>"},{"location":"dictionary/classes/#t","title":"t","text":"<ul> <li>Tab</li> <li>TabType (qqmusic)</li> <li>Then (details::And)</li> <li>Then (details::And::impl)</li> <li>Then&lt; Ret(*)(Args...)&gt; (details::And)</li> <li>Then&lt; Ret(*)(Args...)&gt; (details::And::impl)</li> <li>Then&lt; Ret(Arg)&gt; (details::And::impl)</li> <li>Then&lt; Ret(Cls::*)(Args...) const &gt; (details::And)</li> <li>Then&lt; Ret(Cls::*)(Args...) const &gt; (details::And::impl)</li> <li>Then&lt; Ret(Cls::*)(Args...)&gt; (details::And)</li> <li>Then&lt; Ret(Cls::*)(Args...)&gt; (details::And::impl)</li> <li>Then&lt; Ret(void)&gt; (details::And::impl)</li> </ul>"},{"location":"dictionary/classes/#v","title":"v","text":"<ul> <li>void_t (details)</li> </ul>"},{"location":"dictionary/classes/#w","title":"w","text":"<ul> <li>Wise (details::Other)</li> <li>Wise (details::Other::impl)</li> <li>Wise&lt; Ret(*)(Args...)&gt; (details::Other)</li> <li>Wise&lt; Ret(*)(Args...)&gt; (details::Other::impl)</li> <li>Wise&lt; Ret(Arg)&gt; (details::Other::impl)</li> <li>Wise&lt; Ret(Cls::*)(Args...) const &gt; (details::Other)</li> <li>Wise&lt; Ret(Cls::*)(Args...) const &gt; (details::Other::impl)</li> <li>Wise&lt; Ret(Cls::*)(Args...)&gt; (details::Other)</li> <li>Wise&lt; Ret(Cls::*)(Args...)&gt; (details::Other::impl)</li> </ul>"},{"location":"dictionary/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class qqmusic::BaseMediaFileType \u5a92\u4f53\u6587\u4ef6\u7c7b\u578b\u57fa\u7c7b <ul> <li>class qqmusic::EncryptedSongFileType \u52a0\u5bc6\u6b4c\u66f2\u6587\u4ef6\u7c7b\u578b </li> <li>class qqmusic::SongFileType \u672a\u52a0\u5bc6\u7684\u6b4c\u66f2\u6587\u4ef6\u7c7b\u679a\u4e3e </li> </ul> </li> <li>class qqmusic::QRCodeLoginEvent \u4e8c\u7ef4\u7801\u767b\u9646\u4e8b\u4ef6 </li> <li>class qqmusic::TabType \u6807\u7b7e\u7c7b </li> <li>class qqmusic::crypto::Cipher <ul> <li>class qqmusic::crypto::MapCipher </li> <li>class qqmusic::crypto::RC4Cipher </li> </ul> </li> <li>class qqmusic::crypto::Decoder </li> <li>class qqmusic::crypto::KeyDerive </li> <li>class qqmusic::details::Api Api\u7c7b, \u7b80\u5316\u8bf7\u6c42\u62a5\u6587\u7ec4\u88c5\u548c\u8fd4\u56de\u62a5\u6587\u89e3\u6790\u8fc7\u7a0b </li> <li>class qqmusic::utils::AsyncExecutor \u5168\u5c40\u8c03\u5ea6\u5668\u7c7b </li> <li>class qqmusic::utils::CookieJar \u7b80\u6613Cookie\u7ba1\u7406\u5668, \u8d1f\u8d23cookie\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316, \u4f9d\u8d56 <code>nlohmann::json</code> \u5b9e\u73b0 \u76ee\u524d\u4e0d\u652f\u6301\u8def\u5f84\u5d4c\u5957\u548c<code>Expires</code> \u548c<code>HttpOnly</code> \u8fd9\u6837\u7684\u7279\u6027</li> <li>class qqmusic::utils::Credential \u51ed\u636e\u4fe1\u606f\u7c7b </li> <li>class qqmusic::utils::Exception \u5168\u5c40\u5f02\u5e38\u7c7b </li> <li>class qqmusic::utils::PathManager \u8fd4\u56de\u9ed8\u8ba4\u8def\u5f84 </li> <li>class qqmusic::utils::Session \u4e0a\u4e0b\u6587 </li> <li>class qqmusic::utils::SessionGuard \u4e00\u4e2a <code>RAII</code> \u98ce\u683c\u7684Session\u5207\u6362\u5668</li> <li>class qqmusic::utils::SessionManager \u5168\u5c40\u5355\u4f8b\u7684Session\u7ba1\u7406\u5668, \u8d1f\u8d23\u7ef4\u62a4\u5168\u5c40\u4e0a\u4e0b\u6587\u6808, \u5e76\u8d1f\u8d23 <code>session</code> \u5b9e\u4f8b\u7684\u751f\u6210</li> <li>struct PhoneLoginEvent \u624b\u673a\u53f7\u767b\u9646\u4e8b\u4ef6\u5305\u88c5\u5668 </li> <li>struct Result </li> <li>struct details::And::impl::Then </li> <li>struct details::And::impl::Then&lt; Ret(Arg)&gt; </li> <li>struct details::And::impl::Then&lt; Ret(void)&gt; </li> <li>struct details::Constructor </li> <li>struct details::Constructor&lt; void, E &gt; </li> <li>struct details::Or::impl::Else </li> <li>struct details::Or::impl::Else&lt; Result&lt; T, F &gt;(Arg)&gt; </li> <li>struct details::Or::impl::Else&lt; Result&lt; T, F &gt;(void)&gt; </li> <li>struct details::Other::impl::Wise </li> <li>struct details::Other::impl::Wise&lt; Ret(Arg)&gt; </li> <li>struct details::ResultErrType </li> <li>struct details::ResultErrType&lt; Result&lt; T, E &gt; &gt; </li> <li>struct details::ResultOkType </li> <li>struct details::ResultOkType&lt; Result&lt; T, E &gt; &gt; </li> <li>struct details::Storage </li> <li>struct details::Storage&lt; void, E &gt; </li> <li>struct details::err::impl::Map </li> <li>struct details::err::impl::Map&lt; Ret(Cls::*)(Arg) const &gt; </li> <li>struct details::err_tag </li> <li>struct details::impl::result_of </li> <li>struct details::impl::result_of&lt; Ret(Args...)&gt; <ul> <li>struct details::impl::result_of&lt; Ret(Cls::*)(Args...)&gt; </li> </ul> </li> <li>struct details::ok::impl::Map <ul> <li>struct details::ok::Map </li> </ul> </li> <li>struct details::ok::impl::Map&lt; Result&lt; U, E &gt;(Arg)&gt; </li> <li>struct details::ok::impl::Map&lt; Result&lt; U, E &gt;(void)&gt; </li> <li>struct details::ok::impl::Map&lt; Ret(Arg)&gt; <ul> <li>struct details::ok::impl::Map&lt; Ret(Cls::*)(Arg) const &gt; </li> <li>struct details::ok::impl::Map&lt; Ret(Cls::*)(Arg)&gt; </li> </ul> </li> <li>struct details::ok::impl::Map&lt; Ret(void)&gt; </li> <li>struct details::ok::impl::Map&lt; void(Arg)&gt; </li> <li>struct details::ok::impl::Map&lt; void(void)&gt; </li> <li>struct details::ok_tag </li> <li>struct details::result_of&lt; Ret(*)(Args...)&gt; </li> <li>struct details::result_of&lt; Ret(Cls::*)(Args...) const &gt; </li> <li>struct details::void_t </li> <li>struct qqmusic::Lyric \u6b4c\u8bcd </li> <li>struct qqmusic::MvUrl Mv url\u5c01\u88dd </li> <li>struct qqmusic::PhoneLoginResult </li> <li>struct qqmusic::QRCode \u4e8c\u7ef4\u7801\u4fe1\u606f </li> <li>struct qqmusic::QRCodeLoginResult \u4e8c\u7ef4\u7801\u767b\u9646\u7ed3\u679c\u5c01\u88c5 </li> <li>struct qqmusic::SongInfo </li> <li>struct qqmusic::details::ApiConfig Api\u76f8\u5173\u5e38\u91cf </li> <li>struct qqmusic::details::NetworkContext \u6253\u5305\u7684\u4e0a\u4e0b\u6587 </li> <li>struct qqmusic::details::RequestParam \u5305\u88c5\u8bf7\u6c42\u6240\u9700\u7684\u53c2\u6570 </li> <li>struct qqmusic::utils::Cookie \u4ee3\u8868\u4e00\u6761Cookie </li> <li>struct qqmusic::utils::Device \u8bbe\u5907\u4fe1\u606f </li> <li>struct qqmusic::utils::OSVersion </li> <li>struct qqmusic::utils::QimeiResult </li> <li>struct qqmusic::EncryptedSongFileType::CoreData </li> <li>struct qqmusic::SongFileType::CoreData </li> <li>struct qqmusic::TabType::Tab \u6807\u7b7e\u4fe1\u606f\u7ed3\u6784 </li> <li>struct types::Err </li> <li>struct types::Ok </li> <li>struct types::Ok&lt; void &gt; </li> <li>class std::vector&lt; uint8_t &gt; <ul> <li>class qqmusic::utils::buffer \u4e8c\u8fdb\u5236\u7f13\u51b2\u533a\u7684\u7edf\u4e00\u8868\u793a </li> </ul> </li> <li>class std::false_type <ul> <li>struct concepts::EqualityComparable </li> <li>struct details::IsResult </li> </ul> </li> <li>class std::true_type <ul> <li>struct concepts::EqualityComparable&lt; T, typename std::enable_if&lt; true, typename details::void_t&lt; decltype(std::declval&lt; T &gt;()==std::declval&lt; T &gt;())&gt;::type &gt;::type &gt; </li> <li>struct details::IsResult&lt; Result&lt; T, E &gt; &gt; </li> </ul> </li> </ul>"},{"location":"dictionary/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"dictionary/todo/","title":"Todo","text":"<p>\u5f85\u529e\u4e8b\u9879\u5217\u8868</p>"},{"location":"dictionary/todo/#qqmusicutilscookiejar","title":"\u7c7b qqmusic::utils::CookieJar","text":"<p>\u9700\u8981\u652f\u6301\u5d4c\u5957\u7684\u8def\u5f84, \u652f\u6301\u975e\u952e\u503c\u5bf9\u5f62\u5f0f\u7684Cookie </p>"},{"location":"dictionary/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p> <ul> <li>\u5f85\u529e\u4e8b\u9879\u5217\u8868 </li> </ul>"},{"location":"dictionary/class_members/","title":"Class Members","text":""},{"location":"dictionary/class_members/#a","title":"a","text":"<ul> <li>Align (details::Storage)</li> <li>Api (qqmusic::details::Api)</li> <li>api_config (qqmusic::details::NetworkContext)</li> <li>AsyncExecutor (qqmusic::utils::AsyncExecutor)</li> <li>async_exec (qqmusic::utils::AsyncExecutor)</li> <li>access_token (qqmusic::utils::Credential)</li> <li>android_id (qqmusic::utils::Device)</li> <li>apn (qqmusic::utils::Device)</li> <li>append (qqmusic::utils::buffer)</li> </ul>"},{"location":"dictionary/class_members/#b","title":"b","text":"<ul> <li>buf_in (qqmusic::crypto::Decoder)</li> <li>buf_out (qqmusic::crypto::Decoder)</li> <li>base_band (qqmusic::utils::Device)</li> <li>board (qqmusic::utils::Device)</li> <li>boot_id (qqmusic::utils::Device)</li> <li>bootloader (qqmusic::utils::Device)</li> <li>brand (qqmusic::utils::Device)</li> <li>buffer (qqmusic::utils::buffer)</li> </ul>"},{"location":"dictionary/class_members/#c","title":"c","text":"<ul> <li>copy (details::Constructor, details::Constructor&lt; void, E &gt;)</li> <li>construct (details::Storage, details::Storage&lt; void, E &gt;)</li> <li>credential (qqmusic::QRCodeLoginResult, qqmusic::details::Api, qqmusic::details::NetworkContext)</li> <li>cipher (qqmusic::crypto::Decoder)</li> <li>common (qqmusic::details::Api)</li> <li>cookies (qqmusic::details::NetworkContext)</li> <li>CookieJar (qqmusic::utils::CookieJar)</li> <li>clear (qqmusic::utils::CookieJar)</li> <li>content (qqmusic::utils::CookieJar)</li> <li>Credential (qqmusic::utils::Credential)</li> <li>codename (qqmusic::utils::OSVersion)</li> <li>cache_path (qqmusic::utils::PathManager)</li> <li>context_stack (qqmusic::utils::SessionManager)</li> <li>ctx (qqmusic::utils::SessionManager)</li> </ul>"},{"location":"dictionary/class_members/#d","title":"d","text":"<ul> <li>destroy (details::Storage, details::Storage&lt; void, E &gt;)</li> <li>data (qqmusic::QRCode)</li> <li>decrypt (qqmusic::crypto::Cipher, qqmusic::crypto::Decoder, qqmusic::crypto::MapCipher, qqmusic::crypto::RC4Cipher)</li> <li>Decoder (qqmusic::crypto::Decoder)</li> <li>DeriveV2Key1 (qqmusic::crypto::KeyDerive)</li> <li>DeriveV2Key2 (qqmusic::crypto::KeyDerive)</li> <li>decrypt_tencent_tea (qqmusic::crypto::KeyDerive)</li> <li>derive (qqmusic::crypto::KeyDerive)</li> <li>derive_V1 (qqmusic::crypto::KeyDerive)</li> <li>derive_V2 (qqmusic::crypto::KeyDerive)</li> <li>device (qqmusic::details::NetworkContext, qqmusic::utils::Device)</li> <li>domain (qqmusic::utils::Cookie)</li> <li>del (qqmusic::utils::CookieJar)</li> <li>dump (qqmusic::utils::CookieJar)</li> <li>Device (qqmusic::utils::Device)</li> <li>display (qqmusic::utils::Device)</li> <li>download_path (qqmusic::utils::PathManager)</li> </ul>"},{"location":"dictionary/class_members/#e","title":"e","text":"<ul> <li>expect (Result)</li> <li>expect_impl (Result)</li> <li>encrypted (qqmusic::BaseMediaFileType, qqmusic::EncryptedSongFileType, qqmusic::SongFileType)</li> <li>expandation (qqmusic::BaseMediaFileType, qqmusic::EncryptedSongFileType, qqmusic::SongFileType)</li> <li>EncryptedSongFileType (qqmusic::EncryptedSongFileType)</li> <li>event (qqmusic::PhoneLoginResult)</li> <li>ekey (qqmusic::SongInfo, qqmusic::crypto::Decoder)</li> <li>enable_sign (qqmusic::details::ApiConfig)</li> <li>enc_endpoint (qqmusic::details::ApiConfig)</li> <li>endpoint (qqmusic::details::ApiConfig)</li> <li>encryptUin (qqmusic::utils::Credential)</li> <li>expired_at (qqmusic::utils::Credential)</li> <li>extra_fields (qqmusic::utils::Credential)</li> <li>Exception (qqmusic::utils::Exception)</li> <li>extention (qqmusic::EncryptedSongFileType::CoreData, qqmusic::SongFileType::CoreData)</li> <li>Err (types::Err)</li> </ul>"},{"location":"dictionary/class_members/#f","title":"f","text":"<ul> <li>from_cache (qqmusic::utils::Credential)</li> <li>fingerprint (qqmusic::utils::Device)</li> </ul>"},{"location":"dictionary/class_members/#g","title":"g","text":"<ul> <li>get (details::Storage, details::Storage&lt; void, E &gt;, qqmusic::utils::CookieJar)</li> <li>get_id (qqmusic::TabType)</li> <li>get_name (qqmusic::TabType)</li> <li>get_instance (qqmusic::utils::AsyncExecutor, qqmusic::utils::PathManager, qqmusic::utils::SessionManager)</li> <li>get_error_enum (qqmusic::utils::Exception)</li> <li>get_cache_path (qqmusic::utils::PathManager)</li> <li>get_download_path (qqmusic::utils::PathManager)</li> <li>get_log_path (qqmusic::utils::PathManager)</li> <li>get_context_ref (qqmusic::utils::Session)</li> <li>global_ctx (qqmusic::utils::Session)</li> <li>get_session (qqmusic::utils::SessionManager)</li> </ul>"},{"location":"dictionary/class_members/#h","title":"h","text":"<ul> <li>hls (qqmusic::MvUrl)</li> <li>HttpResponseCodeMap (qqmusic::utils::Exception)</li> <li>handle_http_request (qqmusic::utils::Session)</li> <li>handle_https_request (qqmusic::utils::Session)</li> </ul>"},{"location":"dictionary/class_members/#i","title":"i","text":"<ul> <li>isErr (Result)</li> <li>isOk (Result)</li> <li>initialized_ (details::Storage, details::Storage&lt; void, E &gt;)</li> <li>inner (qqmusic::EncryptedSongFileType, qqmusic::SongFileType, qqmusic::TabType)</li> <li>identifier (qqmusic::QRCode)</li> <li>ignore_ssl_error (qqmusic::details::NetworkContext)</li> <li>ioc (qqmusic::utils::AsyncExecutor, qqmusic::utils::Session, qqmusic::utils::SessionManager)</li> <li>ioc_thread (qqmusic::utils::AsyncExecutor)</li> <li>is_expired (qqmusic::utils::Credential)</li> <li>is_valid (qqmusic::utils::Credential)</li> <li>imei (qqmusic::utils::Device)</li> <li>imsi_md5 (qqmusic::utils::Device)</li> <li>ip_address (qqmusic::utils::Device)</li> <li>incremental (qqmusic::utils::OSVersion)</li> </ul>"},{"location":"dictionary/class_members/#k","title":"k","text":"<ul> <li>key (qqmusic::crypto::Decoder, qqmusic::crypto::MapCipher, qqmusic::crypto::RC4Cipher, qqmusic::utils::Cookie)</li> <li>Kind (qqmusic::utils::Exception)</li> <li>kind (qqmusic::utils::Exception)</li> <li>kind_code (qqmusic::utils::Exception)</li> </ul>"},{"location":"dictionary/class_members/#l","title":"l","text":"<ul> <li>lyric (qqmusic::Lyric)</li> <li>loginType (qqmusic::utils::Credential)</li> <li>log_path (qqmusic::utils::PathManager)</li> <li>local_ctx (qqmusic::utils::Session)</li> <li>lock (qqmusic::utils::Session, qqmusic::utils::SessionManager)</li> </ul>"},{"location":"dictionary/class_members/#m","title":"m","text":"<ul> <li>map (Result, details::err::impl::Map&lt; Ret(Cls::*)(Arg) const &gt;, details::ok::impl::Map&lt; Result&lt; U, E &gt;(Arg)&gt;, details::ok::impl::Map&lt; Result&lt; U, E &gt;(void)&gt;, details::ok::impl::Map&lt; Ret(Arg)&gt;, details::ok::impl::Map&lt; Ret(void)&gt;, details::ok::impl::Map&lt; void(Arg)&gt;, details::ok::impl::Map&lt; void(void)&gt;)</li> <li>mapError (Result)</li> <li>move (details::Constructor, details::Constructor&lt; void, E &gt;)</li> <li>mp4 (qqmusic::MvUrl)</li> <li>msg (qqmusic::PhoneLoginResult)</li> <li>mimie_type (qqmusic::QRCode)</li> <li>mid (qqmusic::SongInfo)</li> <li>makeSimpleKey (qqmusic::crypto::KeyDerive)</li> <li>MapCipher (qqmusic::crypto::MapCipher)</li> <li>method (qqmusic::details::Api)</li> <li>merge (qqmusic::utils::CookieJar)</li> <li>musicid (qqmusic::utils::Credential)</li> <li>musickey (qqmusic::utils::Credential)</li> <li>mac_address (qqmusic::utils::Device)</li> <li>model (qqmusic::utils::Device)</li> </ul>"},{"location":"dictionary/class_members/#n","title":"n","text":"<ul> <li>name (qqmusic::QRCodeLoginEvent)</li> <li>name_map (qqmusic::QRCodeLoginEvent)</li> <li>NetworkContext (qqmusic::details::NetworkContext)</li> <li>NLOHMANN_DEFINE_TYPE_INTRUSIVE (qqmusic::utils::Credential, qqmusic::utils::Device, qqmusic::utils::OSVersion, qqmusic::utils::QimeiResult)</li> </ul>"},{"location":"dictionary/class_members/#o","title":"o","text":"<ul> <li>ok_ (Result)</li> <li>orElse (Result, details::Or::impl::Else&lt; Result&lt; T, F &gt;(Arg)&gt;, details::Or::impl::Else&lt; Result&lt; T, F &gt;(void)&gt;)</li> <li>otherwise (Result, details::Other::impl::Wise&lt; Ret(Arg)&gt;)</li> <li>operator!= (qqmusic::QRCodeLoginEvent)</li> <li>operator== (qqmusic::QRCodeLoginEvent)</li> <li>operator= (qqmusic::utils::AsyncExecutor, qqmusic::utils::SessionManager, qqmusic::utils::buffer)</li> <li>openid (qqmusic::utils::Credential)</li> <li>os_type (qqmusic::utils::Device)</li> <li>OSVersion (qqmusic::utils::OSVersion)</li> <li>operator+ (qqmusic::utils::buffer)</li> <li>operator+= (qqmusic::utils::buffer)</li> <li>Ok (types::Ok)</li> </ul>"},{"location":"dictionary/class_members/#p","title":"p","text":"<ul> <li>prefix (qqmusic::BaseMediaFileType, qqmusic::EncryptedSongFileType, qqmusic::SongFileType)</li> <li>parse_response (qqmusic::details::Api)</li> <li>prepare_request (qqmusic::details::Api)</li> <li>path (qqmusic::utils::Cookie)</li> <li>proc_version (qqmusic::utils::Device)</li> <li>product (qqmusic::utils::Device)</li> <li>PathManager (qqmusic::utils::PathManager)</li> <li>perform_request (qqmusic::utils::Session)</li> <li>pop_context (qqmusic::utils::SessionManager)</li> <li>push_context (qqmusic::utils::SessionManager)</li> </ul>"},{"location":"dictionary/class_members/#q","title":"q","text":"<ul> <li>qr_type (qqmusic::QRCode)</li> <li>QRCodeLoginEvent (qqmusic::QRCodeLoginEvent)</li> <li>qimei (qqmusic::details::NetworkContext, qqmusic::utils::Device)</li> <li>q16 (qqmusic::utils::QimeiResult)</li> <li>q36 (qqmusic::utils::QimeiResult)</li> </ul>"},{"location":"dictionary/class_members/#r","title":"r","text":"<ul> <li>Result (Result)</li> <li>rawConstruct (details::Storage, details::Storage&lt; void, E &gt;)</li> <li>roma (qqmusic::Lyric)</li> <li>read2buf (qqmusic::crypto::Decoder)</li> <li>RC4Cipher (qqmusic::crypto::RC4Cipher)</li> <li>req (qqmusic::details::RequestParam)</li> <li>refresh (qqmusic::utils::Credential)</li> <li>refresh_key (qqmusic::utils::Credential)</li> <li>refresh_token (qqmusic::utils::Credential)</li> <li>ReasonKindMap (qqmusic::utils::Exception)</li> <li>reason (qqmusic::utils::Exception)</li> <li>release (qqmusic::utils::OSVersion)</li> </ul>"},{"location":"dictionary/class_members/#s","title":"s","text":"<ul> <li>storage (Result)</li> <li>storage_ (Result, details::Storage, details::Storage&lt; void, E &gt;)</li> <li>storage_type (Result)</li> <li>Size (details::Storage)</li> <li>Storage (details::Storage)</li> <li>Status (qqmusic::QRCodeLoginEvent)</li> <li>status (qqmusic::QRCodeLoginEvent, qqmusic::QRCodeLoginResult)</li> <li>SongFileType (qqmusic::SongFileType)</li> <li>session (qqmusic::details::Api)</li> <li>shutdown (qqmusic::utils::AsyncExecutor)</li> <li>serialize (qqmusic::utils::CookieJar)</li> <li>set (qqmusic::utils::CookieJar)</li> <li>str_musicid (qqmusic::utils::Credential)</li> <li>sim_info (qqmusic::utils::Device)</li> <li>sdk (qqmusic::utils::OSVersion)</li> <li>set_cache_path (qqmusic::utils::PathManager)</li> <li>set_download_path (qqmusic::utils::PathManager)</li> <li>set_log_path (qqmusic::utils::PathManager)</li> <li>Session (qqmusic::utils::Session)</li> <li>ssl_ctx (qqmusic::utils::Session, qqmusic::utils::SessionManager)</li> <li>sync_global (qqmusic::utils::Session)</li> <li>SessionGuard (qqmusic::utils::SessionGuard)</li> <li>session_manager (qqmusic::utils::SessionGuard)</li> <li>SessionManager (qqmusic::utils::SessionManager)</li> <li>set_context (qqmusic::utils::SessionManager)</li> <li>start_id (qqmusic::EncryptedSongFileType::CoreData, qqmusic::SongFileType::CoreData)</li> </ul>"},{"location":"dictionary/class_members/#t","title":"t","text":"<ul> <li>then (Result, details::And::impl::Then&lt; Ret(Arg)&gt;, details::And::impl::Then&lt; Ret(void)&gt;)</li> <li>type (details::ResultErrType, details::ResultErrType&lt; Result&lt; T, E &gt; &gt;, details::ResultOkType, details::ResultOkType&lt; Result&lt; T, E &gt; &gt;, details::Storage, details::Storage&lt; void, E &gt;, details::impl::result_of&lt; Ret(Args...)&gt;, details::result_of&lt; Ret(*)(Args...)&gt;, details::result_of&lt; Ret(Cls::*)(Args...) const &gt;, details::void_t)</li> <li>Type (qqmusic::EncryptedSongFileType, qqmusic::SongFileType, qqmusic::TabType)</li> <li>table (qqmusic::EncryptedSongFileType, qqmusic::SongFileType)</li> <li>trans (qqmusic::Lyric)</li> <li>TabType (qqmusic::TabType)</li> <li>tab_data (qqmusic::TabType)</li> <li>timeout (qqmusic::details::NetworkContext)</li> <li>to_json (qqmusic::utils::Credential)</li> <li>to_string (qqmusic::utils::Credential)</li> <li>tab_id (qqmusic::TabType::Tab)</li> <li>tab_name (qqmusic::TabType::Tab)</li> </ul>"},{"location":"dictionary/class_members/#u","title":"u","text":"<ul> <li>unwrap (Result)</li> <li>unwrapErr (Result)</li> <li>unwrapOr (Result)</li> <li>url (qqmusic::SongInfo, qqmusic::details::RequestParam)</li> <li>update (qqmusic::utils::CookieJar)</li> <li>unionid (qqmusic::utils::Credential)</li> <li>update_local (qqmusic::utils::Session)</li> </ul>"},{"location":"dictionary/class_members/#v","title":"v","text":"<ul> <li>vid (qqmusic::MvUrl)</li> <li>version (qqmusic::details::ApiConfig, qqmusic::utils::Device)</li> <li>version_code (qqmusic::details::ApiConfig)</li> <li>value (qqmusic::utils::Cookie)</li> <li>vendor_name (qqmusic::utils::Device)</li> <li>vendor_os_name (qqmusic::utils::Device)</li> <li>val (types::Err, types::Ok)</li> </ul>"},{"location":"dictionary/class_members/#w","title":"w","text":"<ul> <li>when_all (qqmusic::utils::AsyncExecutor)</li> <li>wifi_bssid (qqmusic::utils::Device)</li> <li>wifi_ssid (qqmusic::utils::Device)</li> <li>what (qqmusic::utils::Exception)</li> </ul>"},{"location":"dictionary/class_members/#_1","title":"~","text":"<ul> <li>~Result (Result)</li> <li>~BaseMediaFileType (qqmusic::BaseMediaFileType)</li> <li>~EncryptedSongFileType (qqmusic::EncryptedSongFileType)</li> <li>~SongFileType (qqmusic::SongFileType)</li> <li>~Cipher (qqmusic::crypto::Cipher)</li> <li>~AsyncExecutor (qqmusic::utils::AsyncExecutor)</li> <li>~SessionGuard (qqmusic::utils::SessionGuard)</li> <li>~buffer (qqmusic::utils::buffer)</li> </ul>"},{"location":"dictionary/class_member_functions/","title":"Class Member Functions","text":""},{"location":"dictionary/class_member_functions/#a","title":"a","text":"<ul> <li>Api (qqmusic::details::Api)</li> <li>AsyncExecutor (qqmusic::utils::AsyncExecutor)</li> <li>async_exec (qqmusic::utils::AsyncExecutor)</li> <li>append (qqmusic::utils::buffer)</li> </ul>"},{"location":"dictionary/class_member_functions/#b","title":"b","text":"<ul> <li>buffer (qqmusic::utils::buffer)</li> </ul>"},{"location":"dictionary/class_member_functions/#c","title":"c","text":"<ul> <li>copy (details::Constructor, details::Constructor&lt; void, E &gt;)</li> <li>construct (details::Storage, details::Storage&lt; void, E &gt;)</li> <li>CookieJar (qqmusic::utils::CookieJar)</li> <li>clear (qqmusic::utils::CookieJar)</li> <li>Credential (qqmusic::utils::Credential)</li> </ul>"},{"location":"dictionary/class_member_functions/#d","title":"d","text":"<ul> <li>destroy (details::Storage, details::Storage&lt; void, E &gt;)</li> <li>decrypt (qqmusic::crypto::Cipher, qqmusic::crypto::Decoder, qqmusic::crypto::MapCipher, qqmusic::crypto::RC4Cipher)</li> <li>Decoder (qqmusic::crypto::Decoder)</li> <li>decrypt_tencent_tea (qqmusic::crypto::KeyDerive)</li> <li>derive (qqmusic::crypto::KeyDerive)</li> <li>derive_V1 (qqmusic::crypto::KeyDerive)</li> <li>derive_V2 (qqmusic::crypto::KeyDerive)</li> <li>del (qqmusic::utils::CookieJar)</li> <li>dump (qqmusic::utils::CookieJar)</li> <li>Device (qqmusic::utils::Device)</li> </ul>"},{"location":"dictionary/class_member_functions/#e","title":"e","text":"<ul> <li>expect (Result)</li> <li>expect_impl (Result)</li> <li>encrypted (qqmusic::BaseMediaFileType, qqmusic::EncryptedSongFileType, qqmusic::SongFileType)</li> <li>expandation (qqmusic::BaseMediaFileType, qqmusic::EncryptedSongFileType, qqmusic::SongFileType)</li> <li>EncryptedSongFileType (qqmusic::EncryptedSongFileType)</li> <li>Exception (qqmusic::utils::Exception)</li> <li>Err (types::Err)</li> </ul>"},{"location":"dictionary/class_member_functions/#f","title":"f","text":"<ul> <li>from_cache (qqmusic::utils::Credential)</li> </ul>"},{"location":"dictionary/class_member_functions/#g","title":"g","text":"<ul> <li>get (details::Storage, details::Storage&lt; void, E &gt;, qqmusic::utils::CookieJar)</li> <li>get_id (qqmusic::TabType)</li> <li>get_name (qqmusic::TabType)</li> <li>get_instance (qqmusic::utils::AsyncExecutor, qqmusic::utils::PathManager, qqmusic::utils::SessionManager)</li> <li>get_error_enum (qqmusic::utils::Exception)</li> <li>get_cache_path (qqmusic::utils::PathManager)</li> <li>get_download_path (qqmusic::utils::PathManager)</li> <li>get_log_path (qqmusic::utils::PathManager)</li> <li>get_context_ref (qqmusic::utils::Session)</li> <li>get_session (qqmusic::utils::SessionManager)</li> </ul>"},{"location":"dictionary/class_member_functions/#h","title":"h","text":"<ul> <li>handle_http_request (qqmusic::utils::Session)</li> <li>handle_https_request (qqmusic::utils::Session)</li> </ul>"},{"location":"dictionary/class_member_functions/#i","title":"i","text":"<ul> <li>isErr (Result)</li> <li>isOk (Result)</li> <li>is_expired (qqmusic::utils::Credential)</li> <li>is_valid (qqmusic::utils::Credential)</li> </ul>"},{"location":"dictionary/class_member_functions/#k","title":"k","text":"<ul> <li>kind (qqmusic::utils::Exception)</li> </ul>"},{"location":"dictionary/class_member_functions/#m","title":"m","text":"<ul> <li>map (Result, details::err::impl::Map&lt; Ret(Cls::*)(Arg) const &gt;, details::ok::impl::Map&lt; Result&lt; U, E &gt;(Arg)&gt;, details::ok::impl::Map&lt; Result&lt; U, E &gt;(void)&gt;, details::ok::impl::Map&lt; Ret(Arg)&gt;, details::ok::impl::Map&lt; Ret(void)&gt;, details::ok::impl::Map&lt; void(Arg)&gt;, details::ok::impl::Map&lt; void(void)&gt;)</li> <li>mapError (Result)</li> <li>move (details::Constructor, details::Constructor&lt; void, E &gt;)</li> <li>makeSimpleKey (qqmusic::crypto::KeyDerive)</li> <li>MapCipher (qqmusic::crypto::MapCipher)</li> <li>merge (qqmusic::utils::CookieJar)</li> </ul>"},{"location":"dictionary/class_member_functions/#n","title":"n","text":"<ul> <li>name (qqmusic::QRCodeLoginEvent)</li> <li>NetworkContext (qqmusic::details::NetworkContext)</li> <li>NLOHMANN_DEFINE_TYPE_INTRUSIVE (qqmusic::utils::Credential, qqmusic::utils::Device, qqmusic::utils::OSVersion, qqmusic::utils::QimeiResult)</li> </ul>"},{"location":"dictionary/class_member_functions/#o","title":"o","text":"<ul> <li>orElse (Result, details::Or::impl::Else&lt; Result&lt; T, F &gt;(Arg)&gt;, details::Or::impl::Else&lt; Result&lt; T, F &gt;(void)&gt;)</li> <li>otherwise (Result, details::Other::impl::Wise&lt; Ret(Arg)&gt;)</li> <li>operator!= (qqmusic::QRCodeLoginEvent)</li> <li>operator== (qqmusic::QRCodeLoginEvent)</li> <li>operator= (qqmusic::utils::AsyncExecutor, qqmusic::utils::SessionManager, qqmusic::utils::buffer)</li> <li>OSVersion (qqmusic::utils::OSVersion)</li> <li>operator+ (qqmusic::utils::buffer)</li> <li>operator+= (qqmusic::utils::buffer)</li> <li>Ok (types::Ok)</li> </ul>"},{"location":"dictionary/class_member_functions/#p","title":"p","text":"<ul> <li>prefix (qqmusic::BaseMediaFileType, qqmusic::EncryptedSongFileType, qqmusic::SongFileType)</li> <li>parse_response (qqmusic::details::Api)</li> <li>prepare_request (qqmusic::details::Api)</li> <li>PathManager (qqmusic::utils::PathManager)</li> <li>perform_request (qqmusic::utils::Session)</li> <li>pop_context (qqmusic::utils::SessionManager)</li> <li>push_context (qqmusic::utils::SessionManager)</li> </ul>"},{"location":"dictionary/class_member_functions/#q","title":"q","text":"<ul> <li>QRCodeLoginEvent (qqmusic::QRCodeLoginEvent)</li> </ul>"},{"location":"dictionary/class_member_functions/#r","title":"r","text":"<ul> <li>Result (Result)</li> <li>rawConstruct (details::Storage, details::Storage&lt; void, E &gt;)</li> <li>read2buf (qqmusic::crypto::Decoder)</li> <li>RC4Cipher (qqmusic::crypto::RC4Cipher)</li> <li>refresh (qqmusic::utils::Credential)</li> </ul>"},{"location":"dictionary/class_member_functions/#s","title":"s","text":"<ul> <li>storage (Result)</li> <li>Storage (details::Storage)</li> <li>SongFileType (qqmusic::SongFileType)</li> <li>shutdown (qqmusic::utils::AsyncExecutor)</li> <li>serialize (qqmusic::utils::CookieJar)</li> <li>set (qqmusic::utils::CookieJar)</li> <li>set_cache_path (qqmusic::utils::PathManager)</li> <li>set_download_path (qqmusic::utils::PathManager)</li> <li>set_log_path (qqmusic::utils::PathManager)</li> <li>Session (qqmusic::utils::Session)</li> <li>sync_global (qqmusic::utils::Session)</li> <li>SessionGuard (qqmusic::utils::SessionGuard)</li> <li>SessionManager (qqmusic::utils::SessionManager)</li> <li>set_context (qqmusic::utils::SessionManager)</li> </ul>"},{"location":"dictionary/class_member_functions/#t","title":"t","text":"<ul> <li>then (Result, details::And::impl::Then&lt; Ret(Arg)&gt;, details::And::impl::Then&lt; Ret(void)&gt;)</li> <li>TabType (qqmusic::TabType)</li> <li>to_json (qqmusic::utils::Credential)</li> <li>to_string (qqmusic::utils::Credential)</li> </ul>"},{"location":"dictionary/class_member_functions/#u","title":"u","text":"<ul> <li>unwrap (Result)</li> <li>unwrapErr (Result)</li> <li>unwrapOr (Result)</li> <li>update (qqmusic::utils::CookieJar)</li> <li>update_local (qqmusic::utils::Session)</li> </ul>"},{"location":"dictionary/class_member_functions/#w","title":"w","text":"<ul> <li>when_all (qqmusic::utils::AsyncExecutor)</li> <li>what (qqmusic::utils::Exception)</li> </ul>"},{"location":"dictionary/class_member_functions/#_1","title":"~","text":"<ul> <li>~Result (Result)</li> <li>~BaseMediaFileType (qqmusic::BaseMediaFileType)</li> <li>~EncryptedSongFileType (qqmusic::EncryptedSongFileType)</li> <li>~SongFileType (qqmusic::SongFileType)</li> <li>~Cipher (qqmusic::crypto::Cipher)</li> <li>~AsyncExecutor (qqmusic::utils::AsyncExecutor)</li> <li>~SessionGuard (qqmusic::utils::SessionGuard)</li> <li>~buffer (qqmusic::utils::buffer)</li> </ul>"},{"location":"dictionary/class_member_variables/","title":"Class Member Variables","text":""},{"location":"dictionary/class_member_variables/#a","title":"a","text":"<ul> <li>Align (details::Storage)</li> <li>api_config (qqmusic::details::NetworkContext)</li> <li>access_token (qqmusic::utils::Credential)</li> <li>android_id (qqmusic::utils::Device)</li> <li>apn (qqmusic::utils::Device)</li> </ul>"},{"location":"dictionary/class_member_variables/#b","title":"b","text":"<ul> <li>buf_in (qqmusic::crypto::Decoder)</li> <li>buf_out (qqmusic::crypto::Decoder)</li> <li>base_band (qqmusic::utils::Device)</li> <li>board (qqmusic::utils::Device)</li> <li>boot_id (qqmusic::utils::Device)</li> <li>bootloader (qqmusic::utils::Device)</li> <li>brand (qqmusic::utils::Device)</li> </ul>"},{"location":"dictionary/class_member_variables/#c","title":"c","text":"<ul> <li>credential (qqmusic::QRCodeLoginResult, qqmusic::details::Api, qqmusic::details::NetworkContext)</li> <li>cipher (qqmusic::crypto::Decoder)</li> <li>common (qqmusic::details::Api)</li> <li>cookies (qqmusic::details::NetworkContext)</li> <li>content (qqmusic::utils::CookieJar)</li> <li>codename (qqmusic::utils::OSVersion)</li> <li>cache_path (qqmusic::utils::PathManager)</li> <li>context_stack (qqmusic::utils::SessionManager)</li> <li>ctx (qqmusic::utils::SessionManager)</li> </ul>"},{"location":"dictionary/class_member_variables/#d","title":"d","text":"<ul> <li>data (qqmusic::QRCode)</li> <li>DeriveV2Key1 (qqmusic::crypto::KeyDerive)</li> <li>DeriveV2Key2 (qqmusic::crypto::KeyDerive)</li> <li>device (qqmusic::details::NetworkContext, qqmusic::utils::Device)</li> <li>domain (qqmusic::utils::Cookie)</li> <li>display (qqmusic::utils::Device)</li> <li>download_path (qqmusic::utils::PathManager)</li> </ul>"},{"location":"dictionary/class_member_variables/#e","title":"e","text":"<ul> <li>event (qqmusic::PhoneLoginResult)</li> <li>ekey (qqmusic::SongInfo, qqmusic::crypto::Decoder)</li> <li>enable_sign (qqmusic::details::ApiConfig)</li> <li>enc_endpoint (qqmusic::details::ApiConfig)</li> <li>endpoint (qqmusic::details::ApiConfig)</li> <li>encryptUin (qqmusic::utils::Credential)</li> <li>expired_at (qqmusic::utils::Credential)</li> <li>extra_fields (qqmusic::utils::Credential)</li> <li>extention (qqmusic::EncryptedSongFileType::CoreData, qqmusic::SongFileType::CoreData)</li> </ul>"},{"location":"dictionary/class_member_variables/#f","title":"f","text":"<ul> <li>fingerprint (qqmusic::utils::Device)</li> </ul>"},{"location":"dictionary/class_member_variables/#g","title":"g","text":"<ul> <li>global_ctx (qqmusic::utils::Session)</li> </ul>"},{"location":"dictionary/class_member_variables/#h","title":"h","text":"<ul> <li>hls (qqmusic::MvUrl)</li> <li>HttpResponseCodeMap (qqmusic::utils::Exception)</li> </ul>"},{"location":"dictionary/class_member_variables/#i","title":"i","text":"<ul> <li>initialized_ (details::Storage, details::Storage&lt; void, E &gt;)</li> <li>inner (qqmusic::EncryptedSongFileType, qqmusic::SongFileType, qqmusic::TabType)</li> <li>identifier (qqmusic::QRCode)</li> <li>ignore_ssl_error (qqmusic::details::NetworkContext)</li> <li>ioc (qqmusic::utils::AsyncExecutor, qqmusic::utils::Session, qqmusic::utils::SessionManager)</li> <li>ioc_thread (qqmusic::utils::AsyncExecutor)</li> <li>imei (qqmusic::utils::Device)</li> <li>imsi_md5 (qqmusic::utils::Device)</li> <li>ip_address (qqmusic::utils::Device)</li> <li>incremental (qqmusic::utils::OSVersion)</li> </ul>"},{"location":"dictionary/class_member_variables/#k","title":"k","text":"<ul> <li>key (qqmusic::crypto::Decoder, qqmusic::crypto::MapCipher, qqmusic::crypto::RC4Cipher, qqmusic::utils::Cookie)</li> <li>kind_code (qqmusic::utils::Exception)</li> </ul>"},{"location":"dictionary/class_member_variables/#l","title":"l","text":"<ul> <li>lyric (qqmusic::Lyric)</li> <li>loginType (qqmusic::utils::Credential)</li> <li>log_path (qqmusic::utils::PathManager)</li> <li>local_ctx (qqmusic::utils::Session)</li> <li>lock (qqmusic::utils::Session, qqmusic::utils::SessionManager)</li> </ul>"},{"location":"dictionary/class_member_variables/#m","title":"m","text":"<ul> <li>mp4 (qqmusic::MvUrl)</li> <li>msg (qqmusic::PhoneLoginResult)</li> <li>mimie_type (qqmusic::QRCode)</li> <li>mid (qqmusic::SongInfo)</li> <li>method (qqmusic::details::Api)</li> <li>musicid (qqmusic::utils::Credential)</li> <li>musickey (qqmusic::utils::Credential)</li> <li>mac_address (qqmusic::utils::Device)</li> <li>model (qqmusic::utils::Device)</li> </ul>"},{"location":"dictionary/class_member_variables/#n","title":"n","text":"<ul> <li>name_map (qqmusic::QRCodeLoginEvent)</li> </ul>"},{"location":"dictionary/class_member_variables/#o","title":"o","text":"<ul> <li>ok_ (Result)</li> <li>openid (qqmusic::utils::Credential)</li> <li>os_type (qqmusic::utils::Device)</li> </ul>"},{"location":"dictionary/class_member_variables/#p","title":"p","text":"<ul> <li>path (qqmusic::utils::Cookie)</li> <li>proc_version (qqmusic::utils::Device)</li> <li>product (qqmusic::utils::Device)</li> </ul>"},{"location":"dictionary/class_member_variables/#q","title":"q","text":"<ul> <li>qr_type (qqmusic::QRCode)</li> <li>qimei (qqmusic::details::NetworkContext, qqmusic::utils::Device)</li> <li>q16 (qqmusic::utils::QimeiResult)</li> <li>q36 (qqmusic::utils::QimeiResult)</li> </ul>"},{"location":"dictionary/class_member_variables/#r","title":"r","text":"<ul> <li>roma (qqmusic::Lyric)</li> <li>req (qqmusic::details::RequestParam)</li> <li>refresh_key (qqmusic::utils::Credential)</li> <li>refresh_token (qqmusic::utils::Credential)</li> <li>ReasonKindMap (qqmusic::utils::Exception)</li> <li>reason (qqmusic::utils::Exception)</li> <li>release (qqmusic::utils::OSVersion)</li> </ul>"},{"location":"dictionary/class_member_variables/#s","title":"s","text":"<ul> <li>storage_ (Result, details::Storage, details::Storage&lt; void, E &gt;)</li> <li>Size (details::Storage)</li> <li>status (qqmusic::QRCodeLoginEvent, qqmusic::QRCodeLoginResult)</li> <li>session (qqmusic::details::Api)</li> <li>str_musicid (qqmusic::utils::Credential)</li> <li>sim_info (qqmusic::utils::Device)</li> <li>sdk (qqmusic::utils::OSVersion)</li> <li>ssl_ctx (qqmusic::utils::Session, qqmusic::utils::SessionManager)</li> <li>session_manager (qqmusic::utils::SessionGuard)</li> <li>start_id (qqmusic::EncryptedSongFileType::CoreData, qqmusic::SongFileType::CoreData)</li> </ul>"},{"location":"dictionary/class_member_variables/#t","title":"t","text":"<ul> <li>table (qqmusic::EncryptedSongFileType, qqmusic::SongFileType)</li> <li>trans (qqmusic::Lyric)</li> <li>tab_data (qqmusic::TabType)</li> <li>timeout (qqmusic::details::NetworkContext)</li> <li>tab_id (qqmusic::TabType::Tab)</li> <li>tab_name (qqmusic::TabType::Tab)</li> </ul>"},{"location":"dictionary/class_member_variables/#u","title":"u","text":"<ul> <li>url (qqmusic::SongInfo, qqmusic::details::RequestParam)</li> <li>unionid (qqmusic::utils::Credential)</li> </ul>"},{"location":"dictionary/class_member_variables/#v","title":"v","text":"<ul> <li>vid (qqmusic::MvUrl)</li> <li>version (qqmusic::details::ApiConfig, qqmusic::utils::Device)</li> <li>version_code (qqmusic::details::ApiConfig)</li> <li>value (qqmusic::utils::Cookie)</li> <li>vendor_name (qqmusic::utils::Device)</li> <li>vendor_os_name (qqmusic::utils::Device)</li> <li>val (types::Err, types::Ok)</li> </ul>"},{"location":"dictionary/class_member_variables/#w","title":"w","text":"<ul> <li>wifi_bssid (qqmusic::utils::Device)</li> <li>wifi_ssid (qqmusic::utils::Device)</li> </ul>"},{"location":"dictionary/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"dictionary/class_member_typedefs/#s","title":"s","text":"<ul> <li>storage_type (Result)</li> </ul>"},{"location":"dictionary/class_member_typedefs/#t","title":"t","text":"<ul> <li>type (details::ResultErrType, details::ResultErrType&lt; Result&lt; T, E &gt; &gt;, details::ResultOkType, details::ResultOkType&lt; Result&lt; T, E &gt; &gt;, details::Storage, details::Storage&lt; void, E &gt;, details::impl::result_of&lt; Ret(Args...)&gt;, details::result_of&lt; Ret(*)(Args...)&gt;, details::result_of&lt; Ret(Cls::*)(Args...) const &gt;, details::void_t)</li> </ul>"},{"location":"dictionary/class_member_enums/","title":"Class Member Enums","text":""},{"location":"dictionary/class_member_enums/#k","title":"k","text":"<ul> <li>Kind (qqmusic::utils::Exception)</li> </ul>"},{"location":"dictionary/class_member_enums/#s","title":"s","text":"<ul> <li>Status (qqmusic::QRCodeLoginEvent)</li> </ul>"},{"location":"dictionary/class_member_enums/#t","title":"t","text":"<ul> <li>Type (qqmusic::EncryptedSongFileType, qqmusic::SongFileType, qqmusic::TabType)</li> </ul>"},{"location":"dictionary/namespace_members/","title":"Namespace Members","text":""},{"location":"dictionary/namespace_members/#a","title":"a","text":"<ul> <li>AreaType (qqmusic)</li> </ul>"},{"location":"dictionary/namespace_members/#b","title":"b","text":"<ul> <li>bitnum (qqmusic::details)</li> <li>bitnum_intl (qqmusic::details)</li> <li>bitnum_intr (qqmusic::details)</li> </ul>"},{"location":"dictionary/namespace_members/#c","title":"c","text":"<ul> <li>CoverSize (qqmusic)</li> <li>check_qq_qr (qqmusic)</li> <li>check_wx_qr (qqmusic)</li> <li>crypt (qqmusic::details)</li> <li>cache_device (qqmusic::utils)</li> <li>custom_co_spawn_entry_point (qqmusic::utils)</li> </ul>"},{"location":"dictionary/namespace_members/#d","title":"d","text":"<ul> <li>decrypt (qqmusic::crypto::TeaCipher)</li> <li>decompress (qqmusic::utils)</li> </ul>"},{"location":"dictionary/namespace_members/#g","title":"g","text":"<ul> <li>GenderType (qqmusic)</li> <li>GenreType (qqmusic)</li> <li>general_search (qqmusic)</li> <li>get_album_cover_url (qqmusic)</li> <li>get_album_detail (qqmusic)</li> <li>get_album_list (qqmusic)</li> <li>get_album_list_all (qqmusic)</li> <li>get_album_songs (qqmusic)</li> <li>get_created_songlist (qqmusic)</li> <li>get_euin (qqmusic)</li> <li>get_fans (qqmusic)</li> <li>get_fav_album (qqmusic)</li> <li>get_fav_mv (qqmusic)</li> <li>get_fav_num (qqmusic)</li> <li>get_fav_song (qqmusic)</li> <li>get_fav_songlist (qqmusic)</li> <li>get_follow_singers (qqmusic)</li> <li>get_follow_usr (qqmusic)</li> <li>get_friend_list (qqmusic)</li> <li>get_homepage (qqmusic)</li> <li>get_labels (qqmusic)</li> <li>get_lyric (qqmusic)</li> <li>get_music_gene (qqmusic)</li> <li>get_musicid (qqmusic)</li> <li>get_mv_detail (qqmusic)</li> <li>get_mv_list (qqmusic)</li> <li>get_mv_list_all (qqmusic)</li> <li>get_mv_urls (qqmusic)</li> <li>get_other_version (qqmusic)</li> <li>get_producer_info (qqmusic)</li> <li>get_qrcode (qqmusic)</li> <li>get_related_mv (qqmusic)</li> <li>get_related_songlist (qqmusic)</li> <li>get_sheet (qqmusic)</li> <li>get_similar_singers (qqmusic)</li> <li>get_similar_songs (qqmusic)</li> <li>get_singer_desc (qqmusic)</li> <li>get_singer_info (qqmusic)</li> <li>get_singer_list (qqmusic)</li> <li>get_singer_list_index (qqmusic)</li> <li>get_singer_list_index_all (qqmusic)</li> <li>get_song_detail (qqmusic)</li> <li>get_song_urls (qqmusic)</li> <li>get_songlist (qqmusic)</li> <li>get_songlist_detail (qqmusic)</li> <li>get_songs_list (qqmusic)</li> <li>get_songs_list_all (qqmusic)</li> <li>get_tab_detail (qqmusic)</li> <li>get_toplist_category (qqmusic)</li> <li>get_toplist_item_detail (qqmusic)</li> <li>get_try_url (qqmusic)</li> <li>get_vip_info (qqmusic)</li> <li>get_device_info (qqmusic::utils)</li> <li>get_qimei (qqmusic::utils)</li> <li>get_search_id (qqmusic::utils)</li> </ul>"},{"location":"dictionary/namespace_members/#h","title":"h","text":"<ul> <li>hotkey (qqmusic)</li> <li>HttpResponse (qqmusic::utils)</li> <li>hash33 (qqmusic::utils)</li> <li>head (qqmusic::utils)</li> <li>hex2buf (qqmusic::utils)</li> </ul>"},{"location":"dictionary/namespace_members/#i","title":"i","text":"<ul> <li>IndexType (qqmusic)</li> <li>initial_permutation (qqmusic::details)</li> <li>inverse_permutation (qqmusic::details)</li> </ul>"},{"location":"dictionary/namespace_members/#k","title":"k","text":"<ul> <li>keyword_complete (qqmusic)</li> <li>key_schedule (qqmusic::details)</li> </ul>"},{"location":"dictionary/namespace_members/#m","title":"m","text":"<ul> <li>map (details)</li> <li>mapError (details)</li> <li>middle (qqmusic::utils)</li> </ul>"},{"location":"dictionary/namespace_members/#o","title":"o","text":"<ul> <li>orElse (details)</li> <li>otherwise (details)</li> </ul>"},{"location":"dictionary/namespace_members/#p","title":"p","text":"<ul> <li>PhoneLoginEvent (qqmusic)</li> <li>phone_authorize (qqmusic)</li> <li>parse_cookie (qqmusic::utils)</li> </ul>"},{"location":"dictionary/namespace_members/#q","title":"q","text":"<ul> <li>QRLoginType (qqmusic)</li> <li>qmc1_decrypt (qqmusic::utils)</li> <li>qrc_decode (qqmusic::utils)</li> <li>qrc_type (qqmusic::utils)</li> <li>query_song (qqmusic)</li> <li>quick_search (qqmusic)</li> </ul>"},{"location":"dictionary/namespace_members/#r","title":"r","text":"<ul> <li>Result (qqmusic)</li> <li>read2buf (qqmusic::crypto)</li> <li>resp2buf (qqmusic::utils)</li> </ul>"},{"location":"dictionary/namespace_members/#s","title":"s","text":"<ul> <li>SearchType (qqmusic)</li> <li>sbox_bit (qqmusic::details)</li> <li>sign (qqmusic::utils)</li> <li>sync_exec (qqmusic::utils)</li> <li>search_by_type (qqmusic)</li> <li>send_authcode (qqmusic)</li> <li>songlist_add_songs (qqmusic)</li> <li>songlist_create (qqmusic)</li> <li>songlist_delete (qqmusic)</li> <li>songlist_delete_songs (qqmusic)</li> </ul>"},{"location":"dictionary/namespace_members/#t","title":"t","text":"<ul> <li>then (details)</li> <li>Task (qqmusic)</li> <li>transform (qqmusic::details)</li> <li>tripledes_crypt (qqmusic::details)</li> <li>tripledes_crypt_mode (qqmusic::details)</li> <li>tripledes_key_schedule (qqmusic::details)</li> <li>tripledes_key_setup (qqmusic::details)</li> <li>tail (qqmusic::utils)</li> </ul>"},{"location":"dictionary/namespace_members/#v","title":"v","text":"<ul> <li>VERSION (qqmusic::details)</li> <li>VERSION_CODE (qqmusic::details)</li> </ul>"},{"location":"dictionary/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"dictionary/namespace_member_functions/#b","title":"b","text":"<ul> <li>bitnum (qqmusic::details)</li> <li>bitnum_intl (qqmusic::details)</li> <li>bitnum_intr (qqmusic::details)</li> </ul>"},{"location":"dictionary/namespace_member_functions/#c","title":"c","text":"<ul> <li>check_qq_qr (qqmusic)</li> <li>check_wx_qr (qqmusic)</li> <li>crypt (qqmusic::details)</li> <li>cache_device (qqmusic::utils)</li> <li>custom_co_spawn_entry_point (qqmusic::utils)</li> </ul>"},{"location":"dictionary/namespace_member_functions/#d","title":"d","text":"<ul> <li>decrypt (qqmusic::crypto::TeaCipher)</li> <li>decompress (qqmusic::utils)</li> </ul>"},{"location":"dictionary/namespace_member_functions/#g","title":"g","text":"<ul> <li>general_search (qqmusic)</li> <li>get_album_cover_url (qqmusic)</li> <li>get_album_detail (qqmusic)</li> <li>get_album_list (qqmusic)</li> <li>get_album_list_all (qqmusic)</li> <li>get_album_songs (qqmusic)</li> <li>get_created_songlist (qqmusic)</li> <li>get_euin (qqmusic)</li> <li>get_fans (qqmusic)</li> <li>get_fav_album (qqmusic)</li> <li>get_fav_mv (qqmusic)</li> <li>get_fav_num (qqmusic)</li> <li>get_fav_song (qqmusic)</li> <li>get_fav_songlist (qqmusic)</li> <li>get_follow_singers (qqmusic)</li> <li>get_follow_usr (qqmusic)</li> <li>get_friend_list (qqmusic)</li> <li>get_homepage (qqmusic)</li> <li>get_labels (qqmusic)</li> <li>get_lyric (qqmusic)</li> <li>get_music_gene (qqmusic)</li> <li>get_musicid (qqmusic)</li> <li>get_mv_detail (qqmusic)</li> <li>get_mv_list (qqmusic)</li> <li>get_mv_list_all (qqmusic)</li> <li>get_mv_urls (qqmusic)</li> <li>get_other_version (qqmusic)</li> <li>get_producer_info (qqmusic)</li> <li>get_qrcode (qqmusic)</li> <li>get_related_mv (qqmusic)</li> <li>get_related_songlist (qqmusic)</li> <li>get_sheet (qqmusic)</li> <li>get_similar_singers (qqmusic)</li> <li>get_similar_songs (qqmusic)</li> <li>get_singer_desc (qqmusic)</li> <li>get_singer_info (qqmusic)</li> <li>get_singer_list (qqmusic)</li> <li>get_singer_list_index (qqmusic)</li> <li>get_singer_list_index_all (qqmusic)</li> <li>get_song_detail (qqmusic)</li> <li>get_song_urls (qqmusic)</li> <li>get_songlist (qqmusic)</li> <li>get_songlist_detail (qqmusic)</li> <li>get_songs_list (qqmusic)</li> <li>get_songs_list_all (qqmusic)</li> <li>get_tab_detail (qqmusic)</li> <li>get_toplist_category (qqmusic)</li> <li>get_toplist_item_detail (qqmusic)</li> <li>get_try_url (qqmusic)</li> <li>get_vip_info (qqmusic)</li> <li>get_device_info (qqmusic::utils)</li> <li>get_qimei (qqmusic::utils)</li> <li>get_search_id (qqmusic::utils)</li> </ul>"},{"location":"dictionary/namespace_member_functions/#h","title":"h","text":"<ul> <li>hotkey (qqmusic)</li> <li>hash33 (qqmusic::utils)</li> <li>head (qqmusic::utils)</li> <li>hex2buf (qqmusic::utils)</li> </ul>"},{"location":"dictionary/namespace_member_functions/#i","title":"i","text":"<ul> <li>initial_permutation (qqmusic::details)</li> <li>inverse_permutation (qqmusic::details)</li> </ul>"},{"location":"dictionary/namespace_member_functions/#k","title":"k","text":"<ul> <li>keyword_complete (qqmusic)</li> <li>key_schedule (qqmusic::details)</li> </ul>"},{"location":"dictionary/namespace_member_functions/#m","title":"m","text":"<ul> <li>map (details)</li> <li>mapError (details)</li> <li>middle (qqmusic::utils)</li> </ul>"},{"location":"dictionary/namespace_member_functions/#o","title":"o","text":"<ul> <li>orElse (details)</li> <li>otherwise (details)</li> </ul>"},{"location":"dictionary/namespace_member_functions/#p","title":"p","text":"<ul> <li>phone_authorize (qqmusic)</li> <li>parse_cookie (qqmusic::utils)</li> </ul>"},{"location":"dictionary/namespace_member_functions/#q","title":"q","text":"<ul> <li>qmc1_decrypt (qqmusic::utils)</li> <li>qrc_decode (qqmusic::utils)</li> <li>query_song (qqmusic)</li> <li>quick_search (qqmusic)</li> </ul>"},{"location":"dictionary/namespace_member_functions/#r","title":"r","text":"<ul> <li>read2buf (qqmusic::crypto)</li> <li>resp2buf (qqmusic::utils)</li> </ul>"},{"location":"dictionary/namespace_member_functions/#s","title":"s","text":"<ul> <li>sbox_bit (qqmusic::details)</li> <li>sign (qqmusic::utils)</li> <li>sync_exec (qqmusic::utils)</li> <li>search_by_type (qqmusic)</li> <li>send_authcode (qqmusic)</li> <li>songlist_add_songs (qqmusic)</li> <li>songlist_create (qqmusic)</li> <li>songlist_delete (qqmusic)</li> <li>songlist_delete_songs (qqmusic)</li> </ul>"},{"location":"dictionary/namespace_member_functions/#t","title":"t","text":"<ul> <li>then (details)</li> <li>transform (qqmusic::details)</li> <li>tripledes_crypt (qqmusic::details)</li> <li>tripledes_key_setup (qqmusic::details)</li> <li>tail (qqmusic::utils)</li> </ul>"},{"location":"dictionary/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"dictionary/namespace_member_variables/#v","title":"v","text":"<ul> <li>VERSION (qqmusic::details)</li> <li>VERSION_CODE (qqmusic::details)</li> </ul>"},{"location":"dictionary/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"dictionary/namespace_member_typedefs/#h","title":"h","text":"<ul> <li>HttpResponse (qqmusic::utils)</li> </ul>"},{"location":"dictionary/namespace_member_typedefs/#r","title":"r","text":"<ul> <li>Result (qqmusic)</li> </ul>"},{"location":"dictionary/namespace_member_typedefs/#t","title":"t","text":"<ul> <li>Task (qqmusic)</li> <li>tripledes_key_schedule (qqmusic::details)</li> </ul>"},{"location":"dictionary/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"dictionary/namespace_member_enums/#a","title":"a","text":"<ul> <li>AreaType (qqmusic)</li> </ul>"},{"location":"dictionary/namespace_member_enums/#c","title":"c","text":"<ul> <li>CoverSize (qqmusic)</li> </ul>"},{"location":"dictionary/namespace_member_enums/#g","title":"g","text":"<ul> <li>GenderType (qqmusic)</li> <li>GenreType (qqmusic)</li> </ul>"},{"location":"dictionary/namespace_member_enums/#i","title":"i","text":"<ul> <li>IndexType (qqmusic)</li> </ul>"},{"location":"dictionary/namespace_member_enums/#p","title":"p","text":"<ul> <li>PhoneLoginEvent (qqmusic)</li> </ul>"},{"location":"dictionary/namespace_member_enums/#q","title":"q","text":"<ul> <li>QRLoginType (qqmusic)</li> <li>qrc_type (qqmusic::utils)</li> </ul>"},{"location":"dictionary/namespace_member_enums/#s","title":"s","text":"<ul> <li>SearchType (qqmusic)</li> </ul>"},{"location":"dictionary/namespace_member_enums/#t","title":"t","text":"<ul> <li>tripledes_crypt_mode (qqmusic::details)</li> </ul>"},{"location":"dictionary/functions/","title":"Functions","text":""},{"location":"dictionary/functions/#a","title":"a","text":"<ul> <li>auth_qq_qr (login.cc)</li> <li>auth_wx_qr (login.cc)</li> <li>aes_encrypt (qimei.cc)</li> </ul>"},{"location":"dictionary/functions/#e","title":"e","text":"<ul> <li>Err (details/result.h)</li> </ul>"},{"location":"dictionary/functions/#h","title":"h","text":"<ul> <li>handle_http_redirecting (session.cc)</li> <li>handle_https_redirecting (session.cc)</li> </ul>"},{"location":"dictionary/functions/#l","title":"l","text":"<ul> <li>load_rand_payload (qimei.cc)</li> </ul>"},{"location":"dictionary/functions/#o","title":"o","text":"<ul> <li>Ok (details/result.h)</li> <li>operator== (details/result.h)</li> </ul>"},{"location":"dictionary/functions/#r","title":"r","text":"<ul> <li>random_beacon_id (qimei.cc)</li> <li>rsa_encrypt (qimei.cc)</li> </ul>"},{"location":"dictionary/macros/","title":"Macros","text":""},{"location":"dictionary/macros/#t","title":"t","text":"<ul> <li>TRY (details/result.h)</li> </ul>"},{"location":"dictionary/variables/","title":"Variables","text":""},{"location":"dictionary/variables/#a","title":"a","text":"<ul> <li>APP_KEY (qimei.cc)</li> </ul>"},{"location":"dictionary/variables/#p","title":"p","text":"<ul> <li>PUBLIC_KEY (qimei.cc)</li> </ul>"},{"location":"dictionary/variables/#s","title":"s","text":"<ul> <li>SECRET (qimei.cc)</li> </ul>"},{"location":"dictionary/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}